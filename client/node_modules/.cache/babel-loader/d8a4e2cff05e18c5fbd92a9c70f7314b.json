{"ast":null,"code":"var _defineProperty = require(\"/Users/singco/dev/projects/S07P12C104/client/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\n\nvar _toConsumableArray = require(\"/Users/singco/dev/projects/S07P12C104/client/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _toArray = require(\"/Users/singco/dev/projects/S07P12C104/client/node_modules/@babel/runtime/helpers/toArray.js\").default;\n\nvar _inherits = require(\"/Users/singco/dev/projects/S07P12C104/client/node_modules/@babel/runtime/helpers/inherits.js\").default;\n\nvar _createSuper = require(\"/Users/singco/dev/projects/S07P12C104/client/node_modules/@babel/runtime/helpers/createSuper.js\").default;\n\nvar _wrapNativeSuper = require(\"/Users/singco/dev/projects/S07P12C104/client/node_modules/@babel/runtime/helpers/wrapNativeSuper.js\").default;\n\nvar _classCallCheck = require(\"/Users/singco/dev/projects/S07P12C104/client/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\n\nvar _createClass = require(\"/Users/singco/dev/projects/S07P12C104/client/node_modules/@babel/runtime/helpers/createClass.js\").default;\n\nvar _regeneratorRuntime = require(\"/Users/singco/dev/projects/S07P12C104/client/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\n\nvar _asyncToGenerator = require(\"/Users/singco/dev/projects/S07P12C104/client/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\n\nvar _slicedToArray = require(\"/Users/singco/dev/projects/S07P12C104/client/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar _createForOfIteratorHelper = require(\"/Users/singco/dev/projects/S07P12C104/client/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\n\nvar __spreadValues = function __spreadValues(a, b) {\n  for (var prop in b || (b = {})) {\n    if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n\n  if (__getOwnPropSymbols) {\n    var _iterator = _createForOfIteratorHelper(__getOwnPropSymbols(b)),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var prop = _step.value;\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return a;\n};\n\nvar __spreadProps = function __spreadProps(a, b) {\n  return __defProps(a, __getOwnPropDescs(b));\n};\n\nvar __objRest = function __objRest(source, exclude) {\n  var target = {};\n\n  for (var prop in source) {\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n  }\n\n  if (source != null && __getOwnPropSymbols) {\n    var _iterator2 = _createForOfIteratorHelper(__getOwnPropSymbols(source)),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var prop = _step2.value;\n        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  return target;\n};\n\nvar __export = function __export(target, all) {\n  for (var name in all) {\n    __defProp(target, name, {\n      get: all[name],\n      enumerable: true\n    });\n  }\n};\n\nvar __copyProps = function __copyProps(to, from, except, desc) {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    var _iterator3 = _createForOfIteratorHelper(__getOwnPropNames(from)),\n        _step3;\n\n    try {\n      var _loop = function _loop() {\n        var key = _step3.value;\n        if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n          get: function get() {\n            return from[key];\n          },\n          enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n      };\n\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        _loop();\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n\n  return to;\n};\n\nvar __toESM = function __toESM(mod, isNodeMode, target) {\n  return target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n    value: mod,\n    enumerable: true\n  }) : target, mod);\n};\n\nvar __toCommonJS = function __toCommonJS(mod) {\n  return __copyProps(__defProp({}, \"__esModule\", {\n    value: true\n  }), mod);\n}; // src/index.ts\n\n\nvar src_exports = {};\n\n__export(src_exports, {\n  GraphQLHandler: function GraphQLHandler() {\n    return _GraphQLHandler;\n  },\n  MockedRequest: function MockedRequest() {\n    return _MockedRequest;\n  },\n  RESTMethods: function RESTMethods() {\n    return _RESTMethods;\n  },\n  RequestHandler: function RequestHandler() {\n    return _RequestHandler;\n  },\n  RestHandler: function RestHandler() {\n    return _RestHandler;\n  },\n  cleanUrl: function cleanUrl() {\n    return _cleanUrl;\n  },\n  compose: function compose() {\n    return _compose;\n  },\n  context: function context() {\n    return context_exports;\n  },\n  createResponseComposition: function createResponseComposition() {\n    return _createResponseComposition;\n  },\n  defaultContext: function defaultContext() {\n    return _defaultContext;\n  },\n  defaultResponse: function defaultResponse() {\n    return _defaultResponse;\n  },\n  graphql: function graphql() {\n    return _graphql;\n  },\n  graphqlContext: function graphqlContext() {\n    return _graphqlContext;\n  },\n  handleRequest: function handleRequest() {\n    return _handleRequest;\n  },\n  matchRequestUrl: function matchRequestUrl() {\n    return _matchRequestUrl;\n  },\n  response: function response() {\n    return _response;\n  },\n  rest: function rest() {\n    return _rest;\n  },\n  restContext: function restContext() {\n    return _restContext;\n  },\n  setupWorker: function setupWorker() {\n    return _setupWorker;\n  }\n});\n\nmodule.exports = __toCommonJS(src_exports); // src/context/index.ts\n\nvar context_exports = {};\n\n__export(context_exports, {\n  body: function body() {\n    return _body;\n  },\n  cookie: function cookie() {\n    return _cookie;\n  },\n  data: function data() {\n    return _data;\n  },\n  delay: function delay() {\n    return _delay;\n  },\n  errors: function errors() {\n    return _errors;\n  },\n  extensions: function extensions() {\n    return _extensions;\n  },\n  fetch: function fetch() {\n    return _fetch;\n  },\n  json: function json() {\n    return _json;\n  },\n  set: function set() {\n    return _set;\n  },\n  status: function status() {\n    return _status;\n  },\n  text: function text() {\n    return _text;\n  },\n  xml: function xml() {\n    return _xml;\n  }\n}); // src/context/status.ts\n\n\nvar import_codes = __toESM(require(\"statuses/codes.json\"));\n\nvar _status = function _status(statusCode, statusText) {\n  return function (res) {\n    res.status = statusCode;\n    res.statusText = statusText || import_codes.default[String(statusCode)];\n    return res;\n  };\n}; // src/context/set.ts\n\n\nvar import_headers_polyfill = require(\"headers-polyfill\");\n\nfunction _set() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return function (res) {\n    var name = args[0],\n        value = args[1];\n\n    if (typeof name === \"string\") {\n      res.headers.append(name, value);\n    } else {\n      var headers = (0, import_headers_polyfill.objectToHeaders)(name);\n      headers.forEach(function (value2, name2) {\n        res.headers.append(name2, value2);\n      });\n    }\n\n    return res;\n  };\n} // src/context/cookie.ts\n\n\nvar cookieUtils = __toESM(require(\"cookie\"));\n\nvar _cookie = function _cookie(name, value, options) {\n  return function (res) {\n    var serializedCookie = cookieUtils.serialize(name, value, options);\n    res.headers.append(\"Set-Cookie\", serializedCookie);\n\n    if (typeof document !== \"undefined\") {\n      document.cookie = serializedCookie;\n    }\n\n    return res;\n  };\n}; // src/context/body.ts\n\n\nvar _body = function _body(value) {\n  return function (res) {\n    res.body = value;\n    return res;\n  };\n}; // src/utils/internal/jsonParse.ts\n\n\nfunction jsonParse(value) {\n  try {\n    return JSON.parse(value);\n  } catch (error2) {\n    return void 0;\n  }\n} // src/utils/internal/isObject.ts\n\n\nfunction isObject(value) {\n  return value != null && typeof value === \"object\" && !Array.isArray(value);\n} // src/utils/internal/mergeRight.ts\n\n\nfunction mergeRight(left, right) {\n  return Object.entries(right).reduce(function (result, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        rightValue = _ref2[1];\n\n    var leftValue = result[key];\n\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue);\n      return result;\n    }\n\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue);\n      return result;\n    }\n\n    result[key] = rightValue;\n    return result;\n  }, Object.assign({}, left));\n} // src/context/json.ts\n\n\nvar _json = function _json(body2) {\n  return function (res) {\n    res.headers.set(\"Content-Type\", \"application/json\");\n    res.body = JSON.stringify(body2);\n    return res;\n  };\n}; // src/context/data.ts\n\n\nvar _data = function _data(payload) {\n  return function (res) {\n    var prevBody = jsonParse(res.body) || {};\n    var nextBody = mergeRight(prevBody, {\n      data: payload\n    });\n    return _json(nextBody)(res);\n  };\n}; // src/context/extensions.ts\n\n\nvar _extensions = function _extensions(payload) {\n  return function (res) {\n    var prevBody = jsonParse(res.body) || {};\n    var nextBody = mergeRight(prevBody, {\n      extensions: payload\n    });\n    return _json(nextBody)(res);\n  };\n}; // src/context/delay.ts\n\n\nvar import_is_node_process = require(\"is-node-process\");\n\nvar SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647;\nvar MIN_SERVER_RESPONSE_TIME = 100;\nvar MAX_SERVER_RESPONSE_TIME = 400;\nvar NODE_SERVER_RESPONSE_TIME = 5;\n\nvar getRandomServerResponseTime = function getRandomServerResponseTime() {\n  if ((0, import_is_node_process.isNodeProcess)()) {\n    return NODE_SERVER_RESPONSE_TIME;\n  }\n\n  return Math.floor(Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) + MIN_SERVER_RESPONSE_TIME);\n};\n\nvar _delay = function _delay(durationOrMode) {\n  return function (res) {\n    var delayTime;\n\n    if (typeof durationOrMode === \"string\") {\n      switch (durationOrMode) {\n        case \"infinite\":\n          {\n            delayTime = SET_TIMEOUT_MAX_ALLOWED_INT;\n            break;\n          }\n\n        case \"real\":\n          {\n            delayTime = getRandomServerResponseTime();\n            break;\n          }\n\n        default:\n          {\n            throw new Error(\"Failed to delay a response: unknown delay mode \\\"\".concat(durationOrMode, \"\\\". Please make sure you provide one of the supported modes (\\\"real\\\", \\\"infinite\\\") or a number to \\\"ctx.delay\\\".\"));\n          }\n      }\n    } else if (typeof durationOrMode === \"undefined\") {\n      delayTime = getRandomServerResponseTime();\n    } else {\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(\"Failed to delay a response: provided delay duration (\".concat(durationOrMode, \") exceeds the maximum allowed duration for \\\"setTimeout\\\" (\").concat(SET_TIMEOUT_MAX_ALLOWED_INT, \"). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \\\"infinite\\\" delay mode to delay the response indefinitely.\"));\n      }\n\n      delayTime = durationOrMode;\n    }\n\n    res.delay = delayTime;\n    return res;\n  };\n}; // src/context/errors.ts\n\n\nvar _errors = function _errors(errorsList) {\n  return function (res) {\n    if (errorsList == null) {\n      return res;\n    }\n\n    var prevBody = jsonParse(res.body) || {};\n    var nextBody = mergeRight(prevBody, {\n      errors: errorsList\n    });\n    return _json(nextBody)(res);\n  };\n}; // src/context/fetch.ts\n\n\nvar import_is_node_process2 = require(\"is-node-process\");\n\nvar import_headers_polyfill2 = require(\"headers-polyfill\");\n\nvar useFetch = (0, import_is_node_process2.isNodeProcess)() ? require(\"node-fetch\") : window.fetch;\n\nvar augmentRequestInit = function augmentRequestInit(requestInit) {\n  var headers = new import_headers_polyfill2.Headers(requestInit.headers);\n  headers.set(\"x-msw-bypass\", \"true\");\n  return __spreadProps(__spreadValues({}, requestInit), {\n    headers: headers.all()\n  });\n};\n\nvar createFetchRequestParameters = function createFetchRequestParameters(input) {\n  var body2 = input.body,\n      method = input.method;\n\n  var requestParameters = __spreadProps(__spreadValues({}, input), {\n    body: void 0\n  });\n\n  if ([\"GET\", \"HEAD\"].includes(method)) {\n    return requestParameters;\n  }\n\n  if (typeof body2 === \"object\" || typeof body2 === \"number\" || typeof body2 === \"boolean\") {\n    requestParameters.body = JSON.stringify(body2);\n  } else {\n    requestParameters.body = body2;\n  }\n\n  return requestParameters;\n};\n\nvar _fetch = function _fetch(input) {\n  var requestInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof input === \"string\") {\n    return useFetch(input, augmentRequestInit(requestInit));\n  }\n\n  var requestParameters = createFetchRequestParameters(input);\n  var derivedRequestInit = augmentRequestInit(requestParameters);\n  return useFetch(input.url.href, derivedRequestInit);\n}; // src/context/text.ts\n\n\nvar _text = function _text(body2) {\n  return function (res) {\n    res.headers.set(\"Content-Type\", \"text/plain\");\n    res.body = body2;\n    return res;\n  };\n}; // src/context/xml.ts\n\n\nvar _xml = function _xml(body2) {\n  return function (res) {\n    res.headers.set(\"Content-Type\", \"text/xml\");\n    res.body = body2;\n    return res;\n  };\n}; // src/setupWorker/setupWorker.ts\n\n\nvar import_is_node_process3 = require(\"is-node-process\");\n\nvar import_strict_event_emitter = require(\"strict-event-emitter\"); // src/setupWorker/start/createStartHandler.ts\n\n\nvar import_until4 = require(\"@open-draft/until\"); // src/setupWorker/start/utils/getWorkerInstance.ts\n\n\nvar import_until = require(\"@open-draft/until\"); // src/setupWorker/start/utils/getWorkerByRegistration.ts\n\n\nvar getWorkerByRegistration = function getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker) {\n  var allStates = [registration.active, registration.installing, registration.waiting];\n  var existingStates = allStates.filter(Boolean);\n  var mockWorker = existingStates.find(function (worker) {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl);\n  });\n  return mockWorker || null;\n}; // src/utils/url/getAbsoluteWorkerUrl.ts\n\n\nfunction getAbsoluteWorkerUrl(relativeUrl) {\n  return new URL(relativeUrl, location.origin).href;\n} // src/utils/internal/devUtils.ts\n\n\nvar import_outvariant = require(\"outvariant\");\n\nvar LIBRARY_PREFIX = \"[MSW]\";\n\nfunction formatMessage(message) {\n  for (var _len2 = arguments.length, positionals = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    positionals[_key2 - 1] = arguments[_key2];\n  }\n\n  var interpolatedMessage = (0, import_outvariant.format).apply(void 0, [message].concat(positionals));\n  return \"\".concat(LIBRARY_PREFIX, \" \").concat(interpolatedMessage);\n}\n\nfunction warn(message) {\n  for (var _len3 = arguments.length, positionals = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    positionals[_key3 - 1] = arguments[_key3];\n  }\n\n  console.warn(formatMessage.apply(void 0, [message].concat(positionals)));\n}\n\nfunction error(message) {\n  for (var _len4 = arguments.length, positionals = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    positionals[_key4 - 1] = arguments[_key4];\n  }\n\n  console.error(formatMessage.apply(void 0, [message].concat(positionals)));\n}\n\nvar devUtils = {\n  formatMessage: formatMessage,\n  warn: warn,\n  error: error\n}; // src/setupWorker/start/utils/getWorkerInstance.ts\n\nvar getWorkerInstance = /*#__PURE__*/function () {\n  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(url) {\n    var options,\n        findWorker,\n        absoluteWorkerUrl,\n        mockRegistrations,\n        _mockRegistrations,\n        existingRegistration,\n        _yield,\n        _yield2,\n        error2,\n        instance,\n        isWorkerMissing,\n        scopeUrl,\n        _args2 = arguments;\n\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n            findWorker = _args2.length > 2 ? _args2[2] : undefined;\n            absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\n            _context2.next = 5;\n            return navigator.serviceWorker.getRegistrations().then(function (registrations) {\n              return registrations.filter(function (registration) {\n                return getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker);\n              });\n            });\n\n          case 5:\n            mockRegistrations = _context2.sent;\n\n            if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n              location.reload();\n            }\n\n            _mockRegistrations = _slicedToArray(mockRegistrations, 1), existingRegistration = _mockRegistrations[0];\n\n            if (!existingRegistration) {\n              _context2.next = 10;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", existingRegistration.update().then(function () {\n              return [getWorkerByRegistration(existingRegistration, absoluteWorkerUrl, findWorker), existingRegistration];\n            }));\n\n          case 10:\n            _context2.next = 12;\n            return (0, import_until.until)( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n              var registration;\n              return _regeneratorRuntime().wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      _context.next = 2;\n                      return navigator.serviceWorker.register(url, options);\n\n                    case 2:\n                      registration = _context.sent;\n                      return _context.abrupt(\"return\", [getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker), registration]);\n\n                    case 4:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee);\n            })));\n\n          case 12:\n            _yield = _context2.sent;\n            _yield2 = _slicedToArray(_yield, 2);\n            error2 = _yield2[0];\n            instance = _yield2[1];\n\n            if (!error2) {\n              _context2.next = 22;\n              break;\n            }\n\n            isWorkerMissing = error2.message.includes(\"(404)\");\n\n            if (!isWorkerMissing) {\n              _context2.next = 21;\n              break;\n            }\n\n            scopeUrl = new URL((options == null ? void 0 : options.scope) || \"/\", location.href);\n            throw new Error(devUtils.formatMessage(\"Failed to register a Service Worker for scope ('\".concat(scopeUrl.href, \"') with script ('\").concat(absoluteWorkerUrl, \"'): Service Worker script does not exist at the given path.\\n\\nDid you forget to run \\\"npx msw init <PUBLIC_DIR>\\\"?\\n\\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init\")));\n\n          case 21:\n            throw new Error(devUtils.formatMessage(\"Failed to register the Service Worker:\\n\\n%s\", error2.message));\n\n          case 22:\n            return _context2.abrupt(\"return\", instance);\n\n          case 23:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function getWorkerInstance(_x) {\n    return _ref3.apply(this, arguments);\n  };\n}(); // src/setupWorker/start/utils/printStartMessage.ts\n\n\nfunction printStartMessage() {\n  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (args.quiet) {\n    return;\n  }\n\n  var message = args.message || \"Mocking enabled.\";\n  console.groupCollapsed(\"%c\".concat(devUtils.formatMessage(message)), \"color:orangered;font-weight:bold;\");\n  console.log(\"%cDocumentation: %chttps://mswjs.io/docs\", \"font-weight:bold\", \"font-weight:normal\");\n  console.log(\"Found an issue? https://github.com/mswjs/msw/issues\");\n\n  if (args.workerUrl) {\n    console.log(\"Worker script URL:\", args.workerUrl);\n  }\n\n  if (args.workerScope) {\n    console.log(\"Worker scope:\", args.workerScope);\n  }\n\n  console.groupEnd();\n} // src/setupWorker/start/utils/enableMocking.ts\n\n\nfunction enableMocking(_x2, _x3) {\n  return _enableMocking.apply(this, arguments);\n} // src/setupWorker/start/utils/createMessageChannel.ts\n\n\nfunction _enableMocking() {\n  _enableMocking = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(context, options) {\n    var _a, _b;\n\n    return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n      while (1) {\n        switch (_context15.prev = _context15.next) {\n          case 0:\n            context.workerChannel.send(\"MOCK_ACTIVATE\");\n            _context15.next = 3;\n            return context.events.once(\"MOCKING_ENABLED\");\n\n          case 3:\n            if (!context.isMockingEnabled) {\n              _context15.next = 6;\n              break;\n            }\n\n            devUtils.warn(\"Found a redundant \\\"worker.start()\\\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \\\"worker.start()\\\" call.\");\n            return _context15.abrupt(\"return\");\n\n          case 6:\n            context.isMockingEnabled = true;\n            printStartMessage({\n              quiet: options.quiet,\n              workerScope: (_a = context.registration) == null ? void 0 : _a.scope,\n              workerUrl: (_b = context.worker) == null ? void 0 : _b.scriptURL\n            });\n\n          case 8:\n          case \"end\":\n            return _context15.stop();\n        }\n      }\n    }, _callee15);\n  }));\n  return _enableMocking.apply(this, arguments);\n}\n\nvar WorkerChannel = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function WorkerChannel(port) {\n    _classCallCheck(this, WorkerChannel);\n\n    this.port = port;\n  }\n\n  _createClass(WorkerChannel, [{\n    key: \"postMessage\",\n    value: function postMessage(event) {\n      for (var _len5 = arguments.length, rest2 = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        rest2[_key5 - 1] = arguments[_key5];\n      }\n\n      var data2 = rest2[0],\n          transfer = rest2[1];\n      this.port.postMessage({\n        type: event,\n        data: data2\n      }, {\n        transfer: transfer\n      });\n    }\n  }]);\n\n  return WorkerChannel;\n}(); // src/utils/NetworkError.ts\n\n\nvar NetworkError = /*#__PURE__*/function (_Error) {\n  \"use strict\";\n\n  _inherits(NetworkError, _Error);\n\n  var _super = _createSuper(NetworkError);\n\n  function NetworkError(message) {\n    var _this;\n\n    _classCallCheck(this, NetworkError);\n\n    _this = _super.call(this, message);\n    _this.name = \"NetworkError\";\n    return _this;\n  }\n\n  return _createClass(NetworkError);\n}( /*#__PURE__*/_wrapNativeSuper(Error)); // src/utils/request/parseWorkerRequest.ts\n\n\nvar import_interceptors2 = require(\"@mswjs/interceptors\");\n\nvar import_headers_polyfill4 = require(\"headers-polyfill\"); // src/utils/request/MockedRequest.ts\n\n\nvar cookieUtils3 = __toESM(require(\"cookie\"));\n\nvar import_cookies = require(\"@mswjs/cookies\");\n\nvar import_interceptors = require(\"@mswjs/interceptors\");\n\nvar import_bufferUtils = require(\"@mswjs/interceptors/lib/utils/bufferUtils\");\n\nvar import_lib = require(\"headers-polyfill/lib\"); // src/utils/request/getRequestCookies.ts\n\n\nvar cookieUtils2 = __toESM(require(\"cookie\"));\n\nfunction getAllCookies() {\n  return cookieUtils2.parse(document.cookie);\n}\n\nfunction getRequestCookies(request) {\n  if (typeof document === \"undefined\" || typeof location === \"undefined\") {\n    return {};\n  }\n\n  switch (request.credentials) {\n    case \"same-origin\":\n      {\n        return location.origin === request.url.origin ? getAllCookies() : {};\n      }\n\n    case \"include\":\n      {\n        return getAllCookies();\n      }\n\n    default:\n      {\n        return {};\n      }\n  }\n} // src/utils/internal/parseMultipartData.ts\n\n\nvar import_headers_polyfill3 = require(\"headers-polyfill\");\n\nfunction parseContentHeaders(headersString) {\n  var _a, _b;\n\n  var headers = (0, import_headers_polyfill3.stringToHeaders)(headersString);\n  var contentType = headers.get(\"content-type\") || \"text/plain\";\n  var disposition = headers.get(\"content-disposition\");\n\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.');\n  }\n\n  var directives = disposition.split(\";\").reduce(function (acc, chunk) {\n    var _chunk$trim$split = chunk.trim().split(\"=\"),\n        _chunk$trim$split2 = _toArray(_chunk$trim$split),\n        name2 = _chunk$trim$split2[0],\n        rest2 = _chunk$trim$split2.slice(1);\n\n    acc[name2] = rest2.join(\"=\");\n    return acc;\n  }, {});\n  var name = (_a = directives.name) == null ? void 0 : _a.slice(1, -1);\n  var filename = (_b = directives.filename) == null ? void 0 : _b.slice(1, -1);\n  return {\n    name: name,\n    filename: filename,\n    contentType: contentType\n  };\n}\n\nfunction parseMultipartData(data2, headers) {\n  var contentType = headers == null ? void 0 : headers.get(\"content-type\");\n\n  if (!contentType) {\n    return void 0;\n  }\n\n  var _contentType$split = contentType.split(/; */),\n      _contentType$split2 = _toArray(_contentType$split),\n      directives = _contentType$split2.slice(1);\n\n  var boundary = directives.filter(function (d) {\n    return d.startsWith(\"boundary=\");\n  }).map(function (s) {\n    return s.replace(/^boundary=/, \"\");\n  })[0];\n\n  if (!boundary) {\n    return void 0;\n  }\n\n  var boundaryRegExp = new RegExp(\"--+\".concat(boundary));\n  var fields = data2.split(boundaryRegExp).filter(function (chunk) {\n    return chunk.startsWith(\"\\r\\n\") && chunk.endsWith(\"\\r\\n\");\n  }).map(function (chunk) {\n    return chunk.trimStart().replace(/\\r\\n$/, \"\");\n  });\n\n  if (!fields.length) {\n    return void 0;\n  }\n\n  var parsedBody = {};\n\n  try {\n    var _iterator4 = _createForOfIteratorHelper(fields),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var field2 = _step4.value;\n\n        var _field2$split = field2.split(\"\\r\\n\\r\\n\"),\n            _field2$split2 = _toArray(_field2$split),\n            contentHeaders = _field2$split2[0],\n            rest2 = _field2$split2.slice(1);\n\n        var contentBody = rest2.join(\"\\r\\n\\r\\n\");\n\n        var _parseContentHeaders = parseContentHeaders(contentHeaders),\n            contentType2 = _parseContentHeaders.contentType,\n            filename = _parseContentHeaders.filename,\n            name = _parseContentHeaders.name;\n\n        var value = filename === void 0 ? contentBody : new File([contentBody], filename, {\n          type: contentType2\n        });\n        var parsedValue = parsedBody[name];\n\n        if (parsedValue === void 0) {\n          parsedBody[name] = value;\n        } else if (Array.isArray(parsedValue)) {\n          parsedBody[name] = [].concat(_toConsumableArray(parsedValue), [value]);\n        } else {\n          parsedBody[name] = [parsedValue, value];\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n\n    return parsedBody;\n  } catch (error2) {\n    return void 0;\n  }\n} // src/utils/request/parseBody.ts\n\n\nfunction parseBody(body2, headers) {\n  var _a;\n\n  if (!body2) {\n    return body2;\n  }\n\n  var contentType = ((_a = headers == null ? void 0 : headers.get(\"content-type\")) == null ? void 0 : _a.toLowerCase()) || \"\";\n  var hasMultipartContent = contentType.startsWith(\"multipart/form-data\");\n\n  if (hasMultipartContent && typeof body2 !== \"object\") {\n    return parseMultipartData(body2.toString(), headers) || body2;\n  }\n\n  var hasJsonContent = contentType.includes(\"json\");\n\n  if (hasJsonContent && typeof body2 !== \"object\") {\n    return jsonParse(body2.toString()) || body2;\n  }\n\n  return body2;\n} // src/utils/internal/isStringEqual.ts\n\n\nfunction isStringEqual(actual, expected) {\n  return actual.toLowerCase() === expected.toLowerCase();\n} // src/utils/request/MockedRequest.ts\n\n\nvar _MockedRequest = /*#__PURE__*/function (_import_interceptors$) {\n  \"use strict\";\n\n  _inherits(_MockedRequest, _import_interceptors$);\n\n  var _super2 = _createSuper(_MockedRequest);\n\n  function _MockedRequest(url) {\n    var _this2;\n\n    var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, _MockedRequest);\n\n    _this2 = _super2.call(this, url, init);\n\n    if (init.id) {\n      _this2.id = init.id;\n    }\n\n    _this2.cache = init.cache || \"default\";\n    _this2.destination = init.destination || \"\";\n    _this2.integrity = init.integrity || \"\";\n    _this2.keepalive = init.keepalive || false;\n    _this2.mode = init.mode || \"cors\";\n    _this2.priority = init.priority || \"auto\";\n    _this2.redirect = init.redirect || \"follow\";\n    _this2.referrer = init.referrer || \"\";\n    _this2.referrerPolicy = init.referrerPolicy || \"no-referrer\";\n    _this2.cookies = init.cookies || _this2.getCookies();\n    return _this2;\n  }\n\n  _createClass(_MockedRequest, [{\n    key: \"body\",\n    get: function get() {\n      var text2 = (0, import_bufferUtils.decodeBuffer)(this[\"_body\"]);\n      var body2 = parseBody(text2, this.headers);\n\n      if (isStringEqual(this.method, \"GET\") && body2 === \"\") {\n        return void 0;\n      }\n\n      return body2;\n    }\n  }, {\n    key: \"passthrough\",\n    value: function passthrough() {\n      return {\n        status: 101,\n        statusText: \"Continue\",\n        headers: new import_lib.Headers(),\n        body: null,\n        passthrough: true,\n        once: false\n      };\n    }\n  }, {\n    key: \"getCookies\",\n    value: function getCookies() {\n      var _a;\n\n      var requestCookiesString = this.headers.get(\"cookie\");\n      var ownCookies = requestCookiesString ? cookieUtils3.parse(requestCookiesString) : {};\n      import_cookies.store.hydrate();\n      var cookiesFromStore = Array.from((_a = import_cookies.store.get(__spreadProps(__spreadValues({}, this), {\n        url: this.url.href\n      }))) == null ? void 0 : _a.entries()).reduce(function (cookies, _ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            name = _ref6[0],\n            value = _ref6[1].value;\n\n        return Object.assign(cookies, _defineProperty({}, name.trim(), value));\n      }, {});\n      var cookiesFromDocument = getRequestCookies(this);\n\n      var forwardedCookies = __spreadValues(__spreadValues({}, cookiesFromDocument), cookiesFromStore);\n\n      for (var _i = 0, _Object$entries = Object.entries(forwardedCookies); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n            name = _Object$entries$_i[0],\n            value = _Object$entries$_i[1];\n\n        this.headers.append(\"cookie\", \"\".concat(name, \"=\").concat(value));\n      }\n\n      return __spreadValues(__spreadValues({}, forwardedCookies), ownCookies);\n    }\n  }]);\n\n  return _MockedRequest;\n}(import_interceptors.IsomorphicRequest); // src/utils/request/parseWorkerRequest.ts\n\n\nfunction parseWorkerRequest(rawRequest) {\n  var url = new URL(rawRequest.url);\n  var headers = new import_headers_polyfill4.Headers(rawRequest.headers);\n  return new _MockedRequest(url, __spreadProps(__spreadValues({}, rawRequest), {\n    body: (0, import_interceptors2.encodeBuffer)(rawRequest.body || \"\"),\n    headers: headers\n  }));\n} // src/utils/handleRequest.ts\n\n\nvar import_until2 = require(\"@open-draft/until\"); // src/utils/getResponse.ts\n\n\nvar getResponse = /*#__PURE__*/function () {\n  var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request, handlers, resolutionContext) {\n    var relevantHandlers, result;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            relevantHandlers = handlers.filter(function (handler) {\n              return handler.test(request, resolutionContext);\n            });\n\n            if (!(relevantHandlers.length === 0)) {\n              _context4.next = 3;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", {\n              handler: void 0,\n              response: void 0\n            });\n\n          case 3:\n            _context4.next = 5;\n            return relevantHandlers.reduce( /*#__PURE__*/function () {\n              var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(executionResult, handler) {\n                var previousResults, result2;\n                return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n                  while (1) {\n                    switch (_context3.prev = _context3.next) {\n                      case 0:\n                        _context3.next = 2;\n                        return executionResult;\n\n                      case 2:\n                        previousResults = _context3.sent;\n\n                        if (!(previousResults == null ? void 0 : previousResults.response)) {\n                          _context3.next = 5;\n                          break;\n                        }\n\n                        return _context3.abrupt(\"return\", executionResult);\n\n                      case 5:\n                        _context3.next = 7;\n                        return handler.run(request, resolutionContext);\n\n                      case 7:\n                        result2 = _context3.sent;\n\n                        if (!(result2 === null || result2.handler.shouldSkip)) {\n                          _context3.next = 10;\n                          break;\n                        }\n\n                        return _context3.abrupt(\"return\", null);\n\n                      case 10:\n                        if (result2.response) {\n                          _context3.next = 12;\n                          break;\n                        }\n\n                        return _context3.abrupt(\"return\", {\n                          request: result2.request,\n                          handler: result2.handler,\n                          response: void 0,\n                          parsedResult: result2.parsedResult\n                        });\n\n                      case 12:\n                        if (result2.response.once) {\n                          handler.markAsSkipped(true);\n                        }\n\n                        return _context3.abrupt(\"return\", result2);\n\n                      case 14:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }\n                }, _callee3);\n              }));\n\n              return function (_x7, _x8) {\n                return _ref8.apply(this, arguments);\n              };\n            }(), Promise.resolve(null));\n\n          case 5:\n            result = _context4.sent;\n\n            if (result) {\n              _context4.next = 8;\n              break;\n            }\n\n            return _context4.abrupt(\"return\", {\n              handler: void 0,\n              response: void 0\n            });\n\n          case 8:\n            return _context4.abrupt(\"return\", {\n              handler: result.handler,\n              publicRequest: result.request,\n              parsedRequest: result.parsedResult,\n              response: result.response\n            });\n\n          case 9:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4);\n  }));\n\n  return function getResponse(_x4, _x5, _x6) {\n    return _ref7.apply(this, arguments);\n  };\n}(); // src/utils/request/onUnhandledRequest.ts\n\n\nvar import_js_levenshtein = __toESM(require(\"js-levenshtein\")); // src/utils/internal/parseGraphQLRequest.ts\n\n\nvar import_graphql = require(\"graphql\"); // src/utils/request/getPublicUrlFromRequest.ts\n\n\nvar getPublicUrlFromRequest = function getPublicUrlFromRequest(request) {\n  return request.referrer.startsWith(request.url.origin) ? request.url.pathname : new URL(request.url.pathname, \"\".concat(request.url.protocol, \"//\").concat(request.url.host)).href;\n}; // src/utils/internal/parseGraphQLRequest.ts\n\n\nfunction parseDocumentNode(node) {\n  var _a;\n\n  var operationDef = node.definitions.find(function (def) {\n    return def.kind === \"OperationDefinition\";\n  });\n  return {\n    operationType: operationDef == null ? void 0 : operationDef.operation,\n    operationName: (_a = operationDef == null ? void 0 : operationDef.name) == null ? void 0 : _a.value\n  };\n}\n\nfunction parseQuery(query) {\n  try {\n    var ast = (0, import_graphql.parse)(query);\n    return parseDocumentNode(ast);\n  } catch (error2) {\n    return error2;\n  }\n}\n\nfunction extractMultipartVariables(variables, map, files) {\n  var operations = {\n    variables: variables\n  };\n\n  for (var _i2 = 0, _Object$entries2 = Object.entries(map); _i2 < _Object$entries2.length; _i2++) {\n    var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i2], 2),\n        key = _Object$entries2$_i[0],\n        pathArray = _Object$entries2$_i[1];\n\n    if (!(key in files)) {\n      throw new Error(\"Given files do not have a key '\".concat(key, \"' .\"));\n    }\n\n    var _iterator5 = _createForOfIteratorHelper(pathArray),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var dotPath = _step5.value;\n\n        var _dotPath$split$revers = dotPath.split(\".\").reverse(),\n            _dotPath$split$revers2 = _toArray(_dotPath$split$revers),\n            lastPath = _dotPath$split$revers2[0],\n            reversedPaths = _dotPath$split$revers2.slice(1);\n\n        var paths = reversedPaths.reverse();\n        var target = operations;\n\n        var _iterator6 = _createForOfIteratorHelper(paths),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var path = _step6.value;\n\n            if (!(path in target)) {\n              throw new Error(\"Property '\".concat(paths, \"' is not in operations.\"));\n            }\n\n            target = target[path];\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n\n        target[lastPath] = files[key];\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n  }\n\n  return operations.variables;\n}\n\nfunction getGraphQLInput(request) {\n  var _a, _b;\n\n  switch (request.method) {\n    case \"GET\":\n      {\n        var query = request.url.searchParams.get(\"query\");\n        var variables = request.url.searchParams.get(\"variables\") || \"\";\n        return {\n          query: query,\n          variables: jsonParse(variables)\n        };\n      }\n\n    case \"POST\":\n      {\n        if ((_a = request.body) == null ? void 0 : _a.query) {\n          var _request$body = request.body,\n              _query = _request$body.query,\n              _variables = _request$body.variables;\n          return {\n            query: _query,\n            variables: _variables\n          };\n        }\n\n        if ((_b = request.body) == null ? void 0 : _b.operations) {\n          var _c = request.body,\n              operations = _c.operations,\n              map = _c.map,\n              files = __objRest(_c, [\"operations\", \"map\"]);\n\n          var parsedOperations = jsonParse(operations) || {};\n\n          if (!parsedOperations.query) {\n            return null;\n          }\n\n          var parsedMap = jsonParse(map || \"\") || {};\n\n          var _variables2 = parsedOperations.variables ? extractMultipartVariables(parsedOperations.variables, parsedMap, files) : {};\n\n          return {\n            query: parsedOperations.query,\n            variables: _variables2\n          };\n        }\n      }\n\n    default:\n      return null;\n  }\n}\n\nfunction parseGraphQLRequest(request) {\n  var input = getGraphQLInput(request);\n\n  if (!input || !input.query) {\n    return void 0;\n  }\n\n  var query = input.query,\n      variables = input.variables;\n  var parsedResult = parseQuery(query);\n\n  if (parsedResult instanceof Error) {\n    var requestPublicUrl = getPublicUrlFromRequest(request);\n    throw new Error(devUtils.formatMessage('Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s', request.method, requestPublicUrl, parsedResult.message));\n  }\n\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables: variables\n  };\n} // src/utils/logging/getStatusCodeColor.ts\n\n\nfunction getStatusCodeColor(status2) {\n  if (status2 < 300) {\n    return \"#69AB32\"\n    /* Success */\n    ;\n  }\n\n  if (status2 < 400) {\n    return \"#F0BB4B\"\n    /* Warning */\n    ;\n  }\n\n  return \"#E95F5D\"\n  /* Danger */\n  ;\n} // src/utils/logging/getTimestamp.ts\n\n\nfunction getTimestamp() {\n  var now = new Date();\n  return [now.getHours(), now.getMinutes(), now.getSeconds()].map(String).map(function (chunk) {\n    return chunk.slice(0, 2);\n  }).map(function (chunk) {\n    return chunk.padStart(2, \"0\");\n  }).join(\":\");\n} // src/utils/logging/prepareRequest.ts\n\n\nfunction prepareRequest(request) {\n  return __spreadProps(__spreadValues({}, request), {\n    body: request.body,\n    headers: request.headers.all()\n  });\n} // src/utils/logging/prepareResponse.ts\n\n\nvar import_headers_polyfill5 = require(\"headers-polyfill\");\n\nfunction prepareResponse(res) {\n  var responseHeaders = (0, import_headers_polyfill5.objectToHeaders)(res.headers);\n  return __spreadProps(__spreadValues({}, res), {\n    body: parseBody(res.body, responseHeaders)\n  });\n} // src/utils/matching/matchRequestUrl.ts\n\n\nvar import_path_to_regexp = require(\"path-to-regexp\");\n\nvar import_getCleanUrl = require(\"@mswjs/interceptors/lib/utils/getCleanUrl\"); // src/utils/url/cleanUrl.ts\n\n\nvar REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g;\n\nfunction getSearchParams(path) {\n  return new URL(\"/\".concat(path), \"http://localhost\").searchParams;\n}\n\nfunction _cleanUrl(path) {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, \"\");\n} // src/utils/url/isAbsoluteUrl.ts\n\n\nfunction isAbsoluteUrl(url) {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n} // src/utils/url/getAbsoluteUrl.ts\n\n\nfunction getAbsoluteUrl(path, baseUrl) {\n  if (isAbsoluteUrl(path)) {\n    return path;\n  }\n\n  if (path.startsWith(\"*\")) {\n    return path;\n  }\n\n  var origin = baseUrl || typeof document !== \"undefined\" && document.baseURI;\n  return origin ? decodeURI(new URL(encodeURI(path), origin).href) : path;\n} // src/utils/matching/normalizePath.ts\n\n\nfunction normalizePath(path, baseUrl) {\n  if (path instanceof RegExp) {\n    return path;\n  }\n\n  var maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl);\n  return _cleanUrl(maybeAbsoluteUrl);\n} // src/utils/matching/matchRequestUrl.ts\n\n\nfunction coercePath(path) {\n  return path.replace(/([:a-zA-Z_-]*)(\\*{1,2})+/g, function (_, parameterName, wildcard) {\n    var expression = \"(.*)\";\n\n    if (!parameterName) {\n      return expression;\n    }\n\n    return parameterName.startsWith(\":\") ? \"\".concat(parameterName).concat(wildcard) : \"\".concat(parameterName).concat(expression);\n  }).replace(/([^\\/])(:)(?=\\d+)/, \"$1\\\\$2\").replace(/^([^\\/]+)(:)(?=\\/\\/)/, \"$1\\\\$2\");\n}\n\nfunction _matchRequestUrl(url, path, baseUrl) {\n  var normalizedPath = normalizePath(path, baseUrl);\n  var cleanPath = typeof normalizedPath === \"string\" ? coercePath(normalizedPath) : normalizedPath;\n  var cleanUrl2 = (0, import_getCleanUrl.getCleanUrl)(url);\n  var result = (0, import_path_to_regexp.match)(cleanPath, {\n    decode: decodeURIComponent\n  })(cleanUrl2);\n  var params = result && result.params || {};\n  return {\n    matches: result !== false,\n    params: params\n  };\n} // src/handlers/RequestHandler.ts\n\n\nvar import_headers_polyfill7 = require(\"headers-polyfill\"); // src/response.ts\n\n\nvar import_headers_polyfill6 = require(\"headers-polyfill\"); // src/utils/internal/compose.ts\n\n\nfunction _compose() {\n  for (var _len6 = arguments.length, fns = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    fns[_key6] = arguments[_key6];\n  }\n\n  return function () {\n    return fns.reduceRight(function (leftFn, rightFn) {\n      return leftFn instanceof Promise ? Promise.resolve(leftFn).then(rightFn) : rightFn(leftFn);\n    }, arguments.length <= 0 ? undefined : arguments[0]);\n  };\n} // src/response.ts\n\n\nvar _defaultResponse = {\n  status: 200,\n  statusText: \"OK\",\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false\n};\nvar defaultResponseTransformers = [];\n\nfunction _createResponseComposition(responseOverrides) {\n  var defaultTransformers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultResponseTransformers;\n  return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n    var initialResponse,\n        _len7,\n        transformers,\n        _key7,\n        resolvedTransformers,\n        resolvedResponse,\n        _args5 = arguments;\n\n    return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            initialResponse = Object.assign({}, _defaultResponse, {\n              headers: new import_headers_polyfill6.Headers({\n                \"x-powered-by\": \"msw\"\n              })\n            }, responseOverrides);\n\n            for (_len7 = _args5.length, transformers = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n              transformers[_key7] = _args5[_key7];\n            }\n\n            resolvedTransformers = [].concat(_toConsumableArray(defaultTransformers), transformers).filter(Boolean);\n            resolvedResponse = resolvedTransformers.length > 0 ? _compose.apply(void 0, _toConsumableArray(resolvedTransformers))(initialResponse) : initialResponse;\n            return _context5.abrupt(\"return\", resolvedResponse);\n\n          case 5:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, _callee5);\n  }));\n}\n\nvar _response = Object.assign(_createResponseComposition(), {\n  once: _createResponseComposition({\n    once: true\n  }),\n  networkError: function networkError(message) {\n    throw new NetworkError(message);\n  }\n}); // src/utils/internal/getCallFrame.ts\n\n\nvar SOURCE_FRAME = /\\/msw\\/src\\/(.+)/;\nvar BUILD_FRAME = /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/;\n\nfunction getCallFrame(error2) {\n  var stack = error2.stack;\n\n  if (!stack) {\n    return;\n  }\n\n  var frames = stack.split(\"\\n\").slice(1);\n  var declarationFrame = frames.find(function (frame) {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame));\n  });\n\n  if (!declarationFrame) {\n    return;\n  }\n\n  var declarationPath = declarationFrame.replace(/\\s*at [^()]*\\(([^)]+)\\)/, \"$1\").replace(/^@/, \"\");\n  return declarationPath;\n} // src/utils/internal/isIterable.ts\n\n\nfunction isIterable(fn) {\n  if (!fn) {\n    return false;\n  }\n\n  return typeof fn[Symbol.iterator] == \"function\";\n} // src/handlers/RequestHandler.ts\n\n\nvar _defaultContext = {\n  status: _status,\n  set: _set,\n  delay: _delay,\n  fetch: _fetch\n};\n\nvar _RequestHandler = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function _RequestHandler(options) {\n    _classCallCheck(this, _RequestHandler);\n\n    this.shouldSkip = false;\n    this.ctx = options.ctx || _defaultContext;\n    this.resolver = options.resolver;\n    var callFrame = getCallFrame(new Error());\n    this.info = __spreadProps(__spreadValues({}, options.info), {\n      callFrame: callFrame\n    });\n  }\n\n  _createClass(_RequestHandler, [{\n    key: \"parse\",\n    value: function parse(_request, _resolutionContext) {\n      return null;\n    }\n  }, {\n    key: \"test\",\n    value: function test(request, resolutionContext) {\n      return this.predicate(request, this.parse(request, resolutionContext), resolutionContext);\n    }\n  }, {\n    key: \"getPublicRequest\",\n    value: function getPublicRequest(request, _parsedResult) {\n      return request;\n    }\n  }, {\n    key: \"markAsSkipped\",\n    value: function markAsSkipped() {\n      var shouldSkip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      this.shouldSkip = shouldSkip;\n    }\n  }, {\n    key: \"run\",\n    value: function () {\n      var _run = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(request, resolutionContext) {\n        var parsedResult, shouldIntercept, publicRequest, executeResolver, mockedResponse;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (!this.shouldSkip) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", null);\n\n              case 2:\n                parsedResult = this.parse(request, resolutionContext);\n                shouldIntercept = this.predicate(request, parsedResult, resolutionContext);\n\n                if (shouldIntercept) {\n                  _context6.next = 6;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", null);\n\n              case 6:\n                publicRequest = this.getPublicRequest(request, parsedResult);\n                executeResolver = this.wrapResolver(this.resolver);\n                _context6.next = 10;\n                return executeResolver(publicRequest, _response, this.ctx);\n\n              case 10:\n                mockedResponse = _context6.sent;\n                return _context6.abrupt(\"return\", this.createExecutionResult(parsedResult, publicRequest, mockedResponse));\n\n              case 12:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function run(_x9, _x10) {\n        return _run.apply(this, arguments);\n      }\n\n      return run;\n    }()\n  }, {\n    key: \"wrapResolver\",\n    value: function wrapResolver(resolver) {\n      var _this3 = this;\n\n      return /*#__PURE__*/function () {\n        var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(req, res, ctx) {\n          var result, _result$Symbol$iterat, value, done, nextResponse;\n\n          return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n            while (1) {\n              switch (_context7.prev = _context7.next) {\n                case 0:\n                  _context7.t0 = _this3.resolverGenerator;\n\n                  if (_context7.t0) {\n                    _context7.next = 5;\n                    break;\n                  }\n\n                  _context7.next = 4;\n                  return resolver(req, res, ctx);\n\n                case 4:\n                  _context7.t0 = _context7.sent;\n\n                case 5:\n                  result = _context7.t0;\n\n                  if (!isIterable(result)) {\n                    _context7.next = 16;\n                    break;\n                  }\n\n                  _result$Symbol$iterat = result[Symbol.iterator]().next(), value = _result$Symbol$iterat.value, done = _result$Symbol$iterat.done;\n                  _context7.next = 10;\n                  return value;\n\n                case 10:\n                  nextResponse = _context7.sent;\n\n                  if (!(!nextResponse && done)) {\n                    _context7.next = 13;\n                    break;\n                  }\n\n                  return _context7.abrupt(\"return\", _this3.resolverGeneratorResult);\n\n                case 13:\n                  if (!_this3.resolverGenerator) {\n                    _this3.resolverGenerator = result;\n                  }\n\n                  _this3.resolverGeneratorResult = nextResponse;\n                  return _context7.abrupt(\"return\", nextResponse);\n\n                case 16:\n                  return _context7.abrupt(\"return\", result);\n\n                case 17:\n                case \"end\":\n                  return _context7.stop();\n              }\n            }\n          }, _callee7);\n        }));\n\n        return function (_x11, _x12, _x13) {\n          return _ref10.apply(this, arguments);\n        };\n      }();\n    }\n  }, {\n    key: \"createExecutionResult\",\n    value: function createExecutionResult(parsedResult, request, response2) {\n      return {\n        handler: this,\n        parsedResult: parsedResult || null,\n        request: request,\n        response: response2 || null\n      };\n    }\n  }]);\n\n  return _RequestHandler;\n}(); // src/handlers/RestHandler.ts\n\n\nvar _RESTMethods = /* @__PURE__ */function (RESTMethods2) {\n  RESTMethods2[\"HEAD\"] = \"HEAD\";\n  RESTMethods2[\"GET\"] = \"GET\";\n  RESTMethods2[\"POST\"] = \"POST\";\n  RESTMethods2[\"PUT\"] = \"PUT\";\n  RESTMethods2[\"PATCH\"] = \"PATCH\";\n  RESTMethods2[\"OPTIONS\"] = \"OPTIONS\";\n  RESTMethods2[\"DELETE\"] = \"DELETE\";\n  return RESTMethods2;\n}(_RESTMethods || {});\n\nvar _restContext = __spreadProps(__spreadValues({}, _defaultContext), {\n  cookie: _cookie,\n  body: _body,\n  text: _text,\n  json: _json,\n  xml: _xml\n});\n\nvar RestRequest = /*#__PURE__*/function (_MockedRequest2) {\n  \"use strict\";\n\n  _inherits(RestRequest, _MockedRequest2);\n\n  var _super3 = _createSuper(RestRequest);\n\n  function RestRequest(request, params) {\n    var _this4;\n\n    _classCallCheck(this, RestRequest);\n\n    _this4 = _super3.call(this, request.url, __spreadProps(__spreadValues({}, request), {\n      body: request[\"_body\"]\n    }));\n    _this4.params = params;\n    _this4.id = request.id;\n    return _this4;\n  }\n\n  return _createClass(RestRequest);\n}(_MockedRequest);\n\nvar _RestHandler = /*#__PURE__*/function (_RequestHandler2) {\n  \"use strict\";\n\n  _inherits(_RestHandler, _RequestHandler2);\n\n  var _super4 = _createSuper(_RestHandler);\n\n  function _RestHandler(method, path, resolver) {\n    var _this5;\n\n    _classCallCheck(this, _RestHandler);\n\n    _this5 = _super4.call(this, {\n      info: {\n        header: \"\".concat(method, \" \").concat(path),\n        path: path,\n        method: method\n      },\n      ctx: _restContext,\n      resolver: resolver\n    });\n\n    _this5.checkRedundantQueryParameters();\n\n    return _this5;\n  }\n\n  _createClass(_RestHandler, [{\n    key: \"checkRedundantQueryParameters\",\n    value: function checkRedundantQueryParameters() {\n      var _this$info = this.info,\n          method = _this$info.method,\n          path = _this$info.path;\n\n      if (path instanceof RegExp) {\n        return;\n      }\n\n      var url = _cleanUrl(path);\n\n      if (url === path) {\n        return;\n      }\n\n      var searchParams = getSearchParams(path);\n      var queryParams = [];\n      searchParams.forEach(function (_, paramName) {\n        queryParams.push(paramName);\n      });\n      devUtils.warn(\"Found a redundant usage of query parameters in the request handler URL for \\\"\".concat(method, \" \").concat(path, \"\\\". Please match against a path instead and access query parameters in the response resolver function using \\\"req.url.searchParams\\\".\"));\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(request, resolutionContext) {\n      return _matchRequestUrl(request.url, this.info.path, resolutionContext == null ? void 0 : resolutionContext.baseUrl);\n    }\n  }, {\n    key: \"getPublicRequest\",\n    value: function getPublicRequest(request, parsedResult) {\n      return new RestRequest(request, parsedResult.params || {});\n    }\n  }, {\n    key: \"predicate\",\n    value: function predicate(request, parsedResult) {\n      var matchesMethod = this.info.method instanceof RegExp ? this.info.method.test(request.method) : isStringEqual(this.info.method, request.method);\n      return matchesMethod && parsedResult.matches;\n    }\n  }, {\n    key: \"log\",\n    value: function log(request, response2) {\n      var publicUrl = getPublicUrlFromRequest(request);\n      var loggedRequest = prepareRequest(request);\n      var loggedResponse = prepareResponse(response2);\n      var statusColor = getStatusCodeColor(response2.status);\n      console.groupCollapsed(devUtils.formatMessage(\"%s %s %s (%c%s%c)\"), getTimestamp(), request.method, publicUrl, \"color:\".concat(statusColor), \"\".concat(response2.status, \" \").concat(response2.statusText), \"color:inherit\");\n      console.log(\"Request\", loggedRequest);\n      console.log(\"Handler:\", {\n        mask: this.info.path,\n        resolver: this.resolver\n      });\n      console.log(\"Response\", loggedResponse);\n      console.groupEnd();\n    }\n  }]);\n\n  return _RestHandler;\n}(_RequestHandler); // src/context/field.ts\n\n\nvar import_outvariant2 = require(\"outvariant\");\n\nvar field = function field(fieldName, fieldValue) {\n  return function (res) {\n    validateFieldName(fieldName);\n    var prevBody = jsonParse(res.body) || {};\n    var nextBody = mergeRight(prevBody, _defineProperty({}, fieldName, fieldValue));\n    return _json(nextBody)(res);\n  };\n};\n\nfunction validateFieldName(fieldName) {\n  (0, import_outvariant2.invariant)(fieldName.trim() !== \"\", devUtils.formatMessage(\"Failed to set a custom field on a GraphQL response: field name cannot be empty.\"));\n  (0, import_outvariant2.invariant)(fieldName !== \"data\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?', fieldName));\n  (0, import_outvariant2.invariant)(fieldName !== \"errors\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?', fieldName));\n  (0, import_outvariant2.invariant)(fieldName !== \"extensions\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?', fieldName));\n} // src/utils/internal/tryCatch.ts\n\n\nfunction tryCatch(fn, onException) {\n  try {\n    var result = fn();\n    return result;\n  } catch (error2) {\n    onException == null ? void 0 : onException(error2);\n  }\n} // src/handlers/GraphQLHandler.ts\n\n\nvar _graphqlContext = __spreadProps(__spreadValues({}, _defaultContext), {\n  data: _data,\n  extensions: _extensions,\n  errors: _errors,\n  cookie: _cookie,\n  field: field\n});\n\nfunction isDocumentNode(value) {\n  if (value == null) {\n    return false;\n  }\n\n  return typeof value === \"object\" && \"kind\" in value && \"definitions\" in value;\n}\n\nvar GraphQLRequest = /*#__PURE__*/function (_MockedRequest3) {\n  \"use strict\";\n\n  _inherits(GraphQLRequest, _MockedRequest3);\n\n  var _super5 = _createSuper(GraphQLRequest);\n\n  function GraphQLRequest(request, variables) {\n    var _this6;\n\n    _classCallCheck(this, GraphQLRequest);\n\n    _this6 = _super5.call(this, request.url, __spreadProps(__spreadValues({}, request), {\n      body: request[\"_body\"]\n    }));\n    _this6.variables = variables;\n    return _this6;\n  }\n\n  return _createClass(GraphQLRequest);\n}(_MockedRequest);\n\nvar _GraphQLHandler = /*#__PURE__*/function (_RequestHandler3) {\n  \"use strict\";\n\n  _inherits(_GraphQLHandler, _RequestHandler3);\n\n  var _super6 = _createSuper(_GraphQLHandler);\n\n  function _GraphQLHandler(operationType, operationName, endpoint, resolver) {\n    var _this7;\n\n    _classCallCheck(this, _GraphQLHandler);\n\n    var resolvedOperationName = operationName;\n\n    if (isDocumentNode(operationName)) {\n      var parsedNode = parseDocumentNode(operationName);\n\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(\"Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \\\"\".concat(operationType, \"\\\", but got \\\"\").concat(parsedNode.operationType, \"\\\").\"));\n      }\n\n      if (!parsedNode.operationName) {\n        throw new Error(\"Failed to create a GraphQL handler: provided a DocumentNode with no operation name.\");\n      }\n\n      resolvedOperationName = parsedNode.operationName;\n    }\n\n    var header = operationType === \"all\" ? \"\".concat(operationType, \" (origin: \").concat(endpoint.toString(), \")\") : \"\".concat(operationType, \" \").concat(resolvedOperationName, \" (origin: \").concat(endpoint.toString(), \")\");\n    _this7 = _super6.call(this, {\n      info: {\n        header: header,\n        operationType: operationType,\n        operationName: resolvedOperationName\n      },\n      ctx: _graphqlContext,\n      resolver: resolver\n    });\n    _this7.endpoint = endpoint;\n    return _this7;\n  }\n\n  _createClass(_GraphQLHandler, [{\n    key: \"parse\",\n    value: function parse(request) {\n      return tryCatch(function () {\n        return parseGraphQLRequest(request);\n      }, function (error2) {\n        return console.error(error2.message);\n      });\n    }\n  }, {\n    key: \"getPublicRequest\",\n    value: function getPublicRequest(request, parsedResult) {\n      return new GraphQLRequest(request, (parsedResult == null ? void 0 : parsedResult.variables) || {});\n    }\n  }, {\n    key: \"predicate\",\n    value: function predicate(request, parsedResult) {\n      if (!parsedResult) {\n        return false;\n      }\n\n      if (!parsedResult.operationName && this.info.operationType !== \"all\") {\n        var publicUrl = getPublicUrlFromRequest(request);\n        devUtils.warn(\"Failed to intercept a GraphQL request at \\\"\".concat(request.method, \" \").concat(publicUrl, \"\\\": anonymous GraphQL operations are not supported.\\n\\nConsider naming this operation or using \\\"graphql.operation\\\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation      \"));\n        return false;\n      }\n\n      var hasMatchingUrl = _matchRequestUrl(request.url, this.endpoint);\n\n      var hasMatchingOperationType = this.info.operationType === \"all\" || parsedResult.operationType === this.info.operationType;\n      var hasMatchingOperationName = this.info.operationName instanceof RegExp ? this.info.operationName.test(parsedResult.operationName || \"\") : parsedResult.operationName === this.info.operationName;\n      return hasMatchingUrl.matches && hasMatchingOperationType && hasMatchingOperationName;\n    }\n  }, {\n    key: \"log\",\n    value: function log(request, response2, handler, parsedRequest) {\n      var loggedRequest = prepareRequest(request);\n      var loggedResponse = prepareResponse(response2);\n      var statusColor = getStatusCodeColor(response2.status);\n      var requestInfo = (parsedRequest == null ? void 0 : parsedRequest.operationName) ? \"\".concat(parsedRequest == null ? void 0 : parsedRequest.operationType, \" \").concat(parsedRequest == null ? void 0 : parsedRequest.operationName) : \"anonymous \".concat(parsedRequest == null ? void 0 : parsedRequest.operationType);\n      console.groupCollapsed(devUtils.formatMessage(\"%s %s (%c%s%c)\"), getTimestamp(), \"\".concat(requestInfo), \"color:\".concat(statusColor), \"\".concat(response2.status, \" \").concat(response2.statusText), \"color:inherit\");\n      console.log(\"Request:\", loggedRequest);\n      console.log(\"Handler:\", this);\n      console.log(\"Response:\", loggedResponse);\n      console.groupEnd();\n    }\n  }]);\n\n  return _GraphQLHandler;\n}(_RequestHandler); // src/utils/request/onUnhandledRequest.ts\n\n\nvar MAX_MATCH_SCORE = 3;\nvar MAX_SUGGESTION_COUNT = 4;\nvar TYPE_MATCH_DELTA = 0.5;\n\nfunction groupHandlersByType(handlers) {\n  return handlers.reduce(function (groups, handler) {\n    if (handler instanceof _RestHandler) {\n      groups.rest.push(handler);\n    }\n\n    if (handler instanceof _GraphQLHandler) {\n      groups.graphql.push(handler);\n    }\n\n    return groups;\n  }, {\n    rest: [],\n    graphql: []\n  });\n}\n\nfunction getRestHandlerScore() {\n  return function (request, handler) {\n    var _handler$info = handler.info,\n        path = _handler$info.path,\n        method = _handler$info.method;\n\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity;\n    }\n\n    var hasSameMethod = isStringEqual(request.method, method);\n    var methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;\n    var requestPublicUrl = getPublicUrlFromRequest(request);\n    var score = (0, import_js_levenshtein.default)(requestPublicUrl, path);\n    return score - methodScoreDelta;\n  };\n}\n\nfunction getGraphQLHandlerScore(parsedQuery) {\n  return function (_, handler) {\n    if (typeof parsedQuery.operationName === \"undefined\") {\n      return Infinity;\n    }\n\n    var _handler$info2 = handler.info,\n        operationType = _handler$info2.operationType,\n        operationName = _handler$info2.operationName;\n\n    if (typeof operationName !== \"string\") {\n      return Infinity;\n    }\n\n    var hasSameOperationType = parsedQuery.operationType === operationType;\n    var operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;\n    var score = (0, import_js_levenshtein.default)(parsedQuery.operationName, operationName);\n    return score - operationTypeScoreDelta;\n  };\n}\n\nfunction getSuggestedHandler(request, handlers, getScore) {\n  var suggestedHandlers = handlers.reduce(function (suggestions, handler) {\n    var score = getScore(request, handler);\n    return suggestions.concat([[score, handler]]);\n  }, []).sort(function (_ref11, _ref12) {\n    var _ref13 = _slicedToArray(_ref11, 1),\n        leftScore = _ref13[0];\n\n    var _ref14 = _slicedToArray(_ref12, 1),\n        rightScore = _ref14[0];\n\n    return leftScore - rightScore;\n  }).filter(function (_ref15) {\n    var _ref16 = _slicedToArray(_ref15, 1),\n        score = _ref16[0];\n\n    return score <= MAX_MATCH_SCORE;\n  }).slice(0, MAX_SUGGESTION_COUNT).map(function (_ref17) {\n    var _ref18 = _slicedToArray(_ref17, 2),\n        handler = _ref18[1];\n\n    return handler;\n  });\n  return suggestedHandlers;\n}\n\nfunction getSuggestedHandlersMessage(handlers) {\n  if (handlers.length > 1) {\n    return \"Did you mean to request one of the following resources instead?\\n\\n\".concat(handlers.map(function (handler) {\n      return \"  \\u2022 \".concat(handler.info.header);\n    }).join(\"\\n\"));\n  }\n\n  return \"Did you mean to request \\\"\".concat(handlers[0].info.header, \"\\\" instead?\");\n}\n\nfunction onUnhandledRequest(request, handlers) {\n  var strategy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"warn\";\n  var parsedGraphQLQuery = tryCatch(function () {\n    return parseGraphQLRequest(request);\n  });\n\n  function generateHandlerSuggestion() {\n    var handlerGroups = groupHandlersByType(handlers);\n    var relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;\n    var suggestedHandlers = getSuggestedHandler(request, relevantHandlers, parsedGraphQLQuery ? getGraphQLHandlerScore(parsedGraphQLQuery) : getRestHandlerScore());\n    return suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : \"\";\n  }\n\n  function generateUnhandledRequestMessage() {\n    var publicUrl = getPublicUrlFromRequest(request);\n    var requestHeader = parsedGraphQLQuery ? \"\".concat(parsedGraphQLQuery.operationType, \" \").concat(parsedGraphQLQuery.operationName, \" (\").concat(request.method, \" \").concat(publicUrl, \")\") : \"\".concat(request.method, \" \").concat(publicUrl);\n    var handlerSuggestion = generateHandlerSuggestion();\n    var messageTemplate = [\"captured a request without a matching request handler:\", \"  \\u2022 \".concat(requestHeader), handlerSuggestion, \"If you still wish to intercept this unhandled request, please create a request handler for it.\\nRead more: https://mswjs.io/docs/getting-started/mocks\"].filter(Boolean);\n    return messageTemplate.join(\"\\n\\n\");\n  }\n\n  function applyStrategy(strategy2) {\n    var message = generateUnhandledRequestMessage();\n\n    switch (strategy2) {\n      case \"error\":\n        {\n          devUtils.error(\"Error: %s\", message);\n          throw new Error(devUtils.formatMessage('Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.'));\n        }\n\n      case \"warn\":\n        {\n          devUtils.warn(\"Warning: %s\", message);\n          break;\n        }\n\n      case \"bypass\":\n        break;\n\n      default:\n        throw new Error(devUtils.formatMessage('Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.', strategy2));\n    }\n  }\n\n  if (typeof strategy === \"function\") {\n    strategy(request, {\n      warning: applyStrategy.bind(null, \"warn\"),\n      error: applyStrategy.bind(null, \"error\")\n    });\n    return;\n  }\n\n  applyStrategy(strategy);\n} // src/utils/request/readResponseCookies.ts\n\n\nvar import_cookies2 = require(\"@mswjs/cookies\");\n\nfunction readResponseCookies(request, response2) {\n  import_cookies2.store.add(__spreadProps(__spreadValues({}, request), {\n    url: request.url.toString()\n  }), response2);\n  import_cookies2.store.persist();\n} // src/utils/handleRequest.ts\n\n\nfunction _handleRequest(_x14, _x15, _x16, _x17, _x18) {\n  return _handleRequest2.apply(this, arguments);\n} // src/setupWorker/start/createRequestListener.ts\n\n\nfunction _handleRequest2() {\n  _handleRequest2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(request, handlers, options, emitter, handleRequestOptions) {\n    var _a, _b, _c, _d, _e, _f, _g, _yield5, _yield6, lookupError, lookupResult, handler, response2, requiredLookupResult, transformedResponse;\n\n    return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n      while (1) {\n        switch (_context16.prev = _context16.next) {\n          case 0:\n            emitter.emit(\"request:start\", request);\n\n            if (!(request.headers.get(\"x-msw-bypass\") === \"true\")) {\n              _context16.next = 5;\n              break;\n            }\n\n            emitter.emit(\"request:end\", request);\n            (_a = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _a.call(handleRequestOptions, request);\n            return _context16.abrupt(\"return\");\n\n          case 5:\n            _context16.next = 7;\n            return (0, import_until2.until)(function () {\n              return getResponse(request, handlers, handleRequestOptions == null ? void 0 : handleRequestOptions.resolutionContext);\n            });\n\n          case 7:\n            _yield5 = _context16.sent;\n            _yield6 = _slicedToArray(_yield5, 2);\n            lookupError = _yield6[0];\n            lookupResult = _yield6[1];\n\n            if (!lookupError) {\n              _context16.next = 14;\n              break;\n            }\n\n            emitter.emit(\"unhandledException\", lookupError, request);\n            throw lookupError;\n\n          case 14:\n            handler = lookupResult.handler, response2 = lookupResult.response;\n\n            if (handler) {\n              _context16.next = 21;\n              break;\n            }\n\n            onUnhandledRequest(request, handlers, options.onUnhandledRequest);\n            emitter.emit(\"request:unhandled\", request);\n            emitter.emit(\"request:end\", request);\n            (_b = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _b.call(handleRequestOptions, request);\n            return _context16.abrupt(\"return\");\n\n          case 21:\n            if (response2) {\n              _context16.next = 26;\n              break;\n            }\n\n            devUtils.warn(\"Expected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\\n\\n  \\u2022 %s\\n    %s\", response2, handler.info.header, handler.info.callFrame);\n            emitter.emit(\"request:end\", request);\n            (_c = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _c.call(handleRequestOptions, request);\n            return _context16.abrupt(\"return\");\n\n          case 26:\n            if (!response2.passthrough) {\n              _context16.next = 30;\n              break;\n            }\n\n            emitter.emit(\"request:end\", request);\n            (_d = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _d.call(handleRequestOptions, request);\n            return _context16.abrupt(\"return\");\n\n          case 30:\n            readResponseCookies(request, response2);\n            emitter.emit(\"request:match\", request);\n            requiredLookupResult = lookupResult;\n            transformedResponse = ((_e = handleRequestOptions == null ? void 0 : handleRequestOptions.transformResponse) == null ? void 0 : _e.call(handleRequestOptions, response2)) || response2;\n            (_f = handleRequestOptions == null ? void 0 : handleRequestOptions.onMockedResponse) == null ? void 0 : _f.call(handleRequestOptions, transformedResponse, requiredLookupResult);\n            (_g = handleRequestOptions == null ? void 0 : handleRequestOptions.onMockedResponseSent) == null ? void 0 : _g.call(handleRequestOptions, transformedResponse, requiredLookupResult);\n            emitter.emit(\"request:end\", request);\n            return _context16.abrupt(\"return\", transformedResponse);\n\n          case 38:\n          case \"end\":\n            return _context16.stop();\n        }\n      }\n    }, _callee16);\n  }));\n  return _handleRequest2.apply(this, arguments);\n}\n\nvar createRequestListener = function createRequestListener(context, options) {\n  return /*#__PURE__*/function () {\n    var _ref19 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(event, message) {\n      var messageChannel, request;\n      return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              messageChannel = new WorkerChannel(event.ports[0]);\n              request = parseWorkerRequest(message.payload);\n              _context9.prev = 2;\n              _context9.next = 5;\n              return _handleRequest(request, context.requestHandlers, options, context.emitter, {\n                transformResponse: transformResponse,\n                onPassthroughResponse: function onPassthroughResponse() {\n                  messageChannel.postMessage(\"NOT_FOUND\");\n                },\n                onMockedResponse: function onMockedResponse(response2) {\n                  return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n                    var responseInstance, responseBodyBuffer, responseBody;\n                    return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n                      while (1) {\n                        switch (_context8.prev = _context8.next) {\n                          case 0:\n                            if (!(response2.body instanceof ReadableStream)) {\n                              _context8.next = 2;\n                              break;\n                            }\n\n                            throw new Error(devUtils.formatMessage('Failed to construct a mocked response with a \"ReadableStream\" body: mocked streams are not supported. Follow https://github.com/mswjs/msw/issues/1336 for more details.'));\n\n                          case 2:\n                            responseInstance = new Response(response2.body, response2);\n                            _context8.next = 5;\n                            return responseInstance.arrayBuffer();\n\n                          case 5:\n                            responseBodyBuffer = _context8.sent;\n                            responseBody = response2.body == null ? null : responseBodyBuffer;\n                            messageChannel.postMessage(\"MOCK_RESPONSE\", __spreadProps(__spreadValues({}, response2), {\n                              body: responseBody\n                            }), [responseBodyBuffer]);\n\n                          case 8:\n                          case \"end\":\n                            return _context8.stop();\n                        }\n                      }\n                    }, _callee8);\n                  }))();\n                },\n                onMockedResponseSent: function onMockedResponseSent(response2, _ref20) {\n                  var handler = _ref20.handler,\n                      publicRequest = _ref20.publicRequest,\n                      parsedRequest = _ref20.parsedRequest;\n\n                  if (options.quiet) {\n                    return;\n                  }\n\n                  handler.log(publicRequest, response2, handler, parsedRequest);\n                }\n              });\n\n            case 5:\n              _context9.next = 13;\n              break;\n\n            case 7:\n              _context9.prev = 7;\n              _context9.t0 = _context9[\"catch\"](2);\n\n              if (!(_context9.t0 instanceof NetworkError)) {\n                _context9.next = 12;\n                break;\n              }\n\n              messageChannel.postMessage(\"NETWORK_ERROR\", {\n                name: _context9.t0.name,\n                message: _context9.t0.message\n              });\n              return _context9.abrupt(\"return\");\n\n            case 12:\n              if (_context9.t0 instanceof Error) {\n                devUtils.error(\"Uncaught exception in the request handler for \\\"%s %s\\\":\\n\\n%s\\n\\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses\", request.method, request.url, _context9.t0);\n                messageChannel.postMessage(\"MOCK_RESPONSE\", {\n                  status: 500,\n                  statusText: \"Request Handler Error\",\n                  headers: {\n                    \"Content-Type\": \"application/json\"\n                  },\n                  body: JSON.stringify({\n                    name: _context9.t0.name,\n                    message: _context9.t0.message,\n                    stack: _context9.t0.stack\n                  })\n                });\n              }\n\n            case 13:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, _callee9, null, [[2, 7]]);\n    }));\n\n    return function (_x19, _x20) {\n      return _ref19.apply(this, arguments);\n    };\n  }();\n};\n\nfunction transformResponse(response2) {\n  return {\n    status: response2.status,\n    statusText: response2.statusText,\n    headers: response2.headers.all(),\n    body: response2.body,\n    delay: response2.delay\n  };\n} // src/utils/internal/requestIntegrityCheck.ts\n\n\nfunction requestIntegrityCheck(_x21, _x22) {\n  return _requestIntegrityCheck.apply(this, arguments);\n} // src/utils/deferNetworkRequestsUntil.ts\n\n\nfunction _requestIntegrityCheck() {\n  _requestIntegrityCheck = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(context, serviceWorker) {\n    var _yield$context$events, actualChecksum;\n\n    return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n      while (1) {\n        switch (_context17.prev = _context17.next) {\n          case 0:\n            context.workerChannel.send(\"INTEGRITY_CHECK_REQUEST\");\n            _context17.next = 3;\n            return context.events.once(\"INTEGRITY_CHECK_RESPONSE\");\n\n          case 3:\n            _yield$context$events = _context17.sent;\n            actualChecksum = _yield$context$events.payload;\n\n            if (!(actualChecksum !== \"b3066ef78c2f9090b4ce87e874965995\")) {\n              _context17.next = 7;\n              break;\n            }\n\n            throw new Error(\"Currently active Service Worker (\".concat(actualChecksum, \") is behind the latest published one (\", \"b3066ef78c2f9090b4ce87e874965995\", \").\"));\n\n          case 7:\n            return _context17.abrupt(\"return\", serviceWorker);\n\n          case 8:\n          case \"end\":\n            return _context17.stop();\n        }\n      }\n    }, _callee17);\n  }));\n  return _requestIntegrityCheck.apply(this, arguments);\n}\n\nvar import_until3 = require(\"@open-draft/until\");\n\nfunction deferNetworkRequestsUntil(predicatePromise) {\n  var originalXhrSend = window.XMLHttpRequest.prototype.send;\n\n  window.XMLHttpRequest.prototype.send = function () {\n    var _this8 = this;\n\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n\n    (0, import_until3.until)(function () {\n      return predicatePromise;\n    }).then(function () {\n      window.XMLHttpRequest.prototype.send = originalXhrSend;\n\n      _this8.send.apply(_this8, args);\n    });\n  };\n\n  var originalFetch = window.fetch;\n  window.fetch = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n    var _window;\n\n    var _args10 = arguments;\n    return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            _context10.next = 2;\n            return (0, import_until3.until)(function () {\n              return predicatePromise;\n            });\n\n          case 2:\n            window.fetch = originalFetch;\n            return _context10.abrupt(\"return\", (_window = window).fetch.apply(_window, _args10));\n\n          case 4:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, _callee10);\n  }));\n} // src/setupWorker/start/createResponseListener.ts\n\n\nfunction createResponseListener(context) {\n  return function (_, message) {\n    var _a;\n\n    var responseJson = message.payload;\n\n    if ((_a = responseJson.type) == null ? void 0 : _a.includes(\"opaque\")) {\n      return;\n    }\n\n    var response2 = new Response(responseJson.body || null, responseJson);\n    var isMockedResponse = response2.headers.get(\"x-powered-by\") === \"msw\";\n\n    if (isMockedResponse) {\n      context.emitter.emit(\"response:mocked\", response2, responseJson.requestId);\n    } else {\n      context.emitter.emit(\"response:bypass\", response2, responseJson.requestId);\n    }\n  };\n} // src/setupWorker/start/utils/validateWorkerScope.ts\n\n\nfunction validateWorkerScope(registration, options) {\n  if (!(options == null ? void 0 : options.quiet) && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(\"Cannot intercept requests on this page because it's outside of the worker's scope (\\\"\".concat(registration.scope, \"\\\"). If you wish to mock API requests on this page, you must resolve this scope issue.\\n\\n- (Recommended) Register the worker at the root level (\\\"/\\\") of your application.\\n- Set the \\\"Service-Worker-Allowed\\\" response header to allow out-of-scope workers.\"));\n  }\n} // src/setupWorker/start/createStartHandler.ts\n\n\nvar createStartHandler = function createStartHandler(context) {\n  return function start(options, customOptions) {\n    var startWorkerInstance = /*#__PURE__*/function () {\n      var _ref22 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        var instance, _instance, worker, registration, missingWorkerMessage, _yield3, _yield4, integrityError;\n\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                context.events.removeAllListeners();\n                context.workerChannel.on(\"REQUEST\", createRequestListener(context, options));\n                context.workerChannel.on(\"RESPONSE\", createResponseListener(context));\n                _context11.next = 5;\n                return getWorkerInstance(options.serviceWorker.url, options.serviceWorker.options, options.findWorker);\n\n              case 5:\n                instance = _context11.sent;\n                _instance = _slicedToArray(instance, 2), worker = _instance[0], registration = _instance[1];\n\n                if (worker) {\n                  _context11.next = 10;\n                  break;\n                }\n\n                missingWorkerMessage = (customOptions == null ? void 0 : customOptions.findWorker) ? devUtils.formatMessage(\"Failed to locate the Service Worker registration using a custom \\\"findWorker\\\" predicate.\\n\\nPlease ensure that the custom predicate properly locates the Service Worker registration at \\\"%s\\\".\\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\\n\", options.serviceWorker.url) : devUtils.formatMessage(\"Failed to locate the Service Worker registration.\\n\\nThis most likely means that the worker script URL \\\"%s\\\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\\n\\nPlease consider using a custom \\\"serviceWorker.url\\\" option to point to the actual worker script location, or a custom \\\"findWorker\\\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start\", options.serviceWorker.url, location.host);\n                throw new Error(missingWorkerMessage);\n\n              case 10:\n                context.worker = worker;\n                context.registration = registration;\n                context.events.addListener(window, \"beforeunload\", function () {\n                  if (worker.state !== \"redundant\") {\n                    context.workerChannel.send(\"CLIENT_CLOSED\");\n                  }\n\n                  window.clearInterval(context.keepAliveInterval);\n                });\n                _context11.next = 15;\n                return (0, import_until4.until)(function () {\n                  return requestIntegrityCheck(context, worker);\n                });\n\n              case 15:\n                _yield3 = _context11.sent;\n                _yield4 = _slicedToArray(_yield3, 1);\n                integrityError = _yield4[0];\n\n                if (integrityError) {\n                  devUtils.error(\"Detected outdated Service Worker: \".concat(integrityError.message, \"\\n\\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\\n\\n$ npx msw init <PUBLIC_DIR>\\n\\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues      \"));\n                }\n\n                context.keepAliveInterval = window.setInterval(function () {\n                  return context.workerChannel.send(\"KEEPALIVE_REQUEST\");\n                }, 5e3);\n                validateWorkerScope(registration, context.startOptions);\n                return _context11.abrupt(\"return\", registration);\n\n              case 22:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11);\n      }));\n\n      return function startWorkerInstance() {\n        return _ref22.apply(this, arguments);\n      };\n    }();\n\n    var workerRegistration = startWorkerInstance().then( /*#__PURE__*/function () {\n      var _ref23 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(registration) {\n        var pendingInstance;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                pendingInstance = registration.installing || registration.waiting;\n\n                if (!pendingInstance) {\n                  _context12.next = 4;\n                  break;\n                }\n\n                _context12.next = 4;\n                return new Promise(function (resolve) {\n                  pendingInstance.addEventListener(\"statechange\", function () {\n                    if (pendingInstance.state === \"activated\") {\n                      return resolve();\n                    }\n                  });\n                });\n\n              case 4:\n                _context12.next = 6;\n                return enableMocking(context, options).catch(function (error2) {\n                  throw new Error(\"Failed to enable mocking: \".concat(error2 == null ? void 0 : error2.message));\n                });\n\n              case 6:\n                return _context12.abrupt(\"return\", registration);\n\n              case 7:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12);\n      }));\n\n      return function (_x23) {\n        return _ref23.apply(this, arguments);\n      };\n    }());\n\n    if (options.waitUntilReady) {\n      deferNetworkRequestsUntil(workerRegistration);\n    }\n\n    return workerRegistration;\n  };\n}; // src/setupWorker/stop/utils/printStopMessage.ts\n\n\nfunction printStopMessage() {\n  var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (args.quiet) {\n    return;\n  }\n\n  console.log(\"%c\".concat(devUtils.formatMessage(\"Mocking disabled.\")), \"color:orangered;font-weight:bold;\");\n} // src/setupWorker/stop/createStop.ts\n\n\nvar createStop = function createStop(context) {\n  return function stop() {\n    var _a;\n\n    if (!context.isMockingEnabled) {\n      devUtils.warn('Found a redundant \"worker.stop()\" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this \"worker.stop()\" call.');\n      return;\n    }\n\n    context.workerChannel.send(\"MOCK_DEACTIVATE\");\n    context.isMockingEnabled = false;\n    window.clearInterval(context.keepAliveInterval);\n    printStopMessage({\n      quiet: (_a = context.startOptions) == null ? void 0 : _a.quiet\n    });\n  };\n}; // src/utils/internal/requestHandlerUtils.ts\n\n\nfunction _use(currentHandlers) {\n  for (var _len9 = arguments.length, handlers = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n    handlers[_key9 - 1] = arguments[_key9];\n  }\n\n  currentHandlers.unshift.apply(currentHandlers, handlers);\n}\n\nfunction _restoreHandlers(handlers) {\n  handlers.forEach(function (handler) {\n    handler.markAsSkipped(false);\n  });\n}\n\nfunction _resetHandlers(initialHandlers) {\n  for (var _len10 = arguments.length, nextHandlers = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {\n    nextHandlers[_key10 - 1] = arguments[_key10];\n  }\n\n  return nextHandlers.length > 0 ? [].concat(nextHandlers) : _toConsumableArray(initialHandlers);\n} // src/setupWorker/start/utils/prepareStartHandler.ts\n\n\nvar DEFAULT_START_OPTIONS = {\n  serviceWorker: {\n    url: \"/mockServiceWorker.js\",\n    options: null\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: \"warn\",\n  findWorker: function findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl;\n  }\n};\n\nfunction resolveStartOptions(initialOptions) {\n  return mergeRight(DEFAULT_START_OPTIONS, initialOptions || {});\n}\n\nfunction prepareStartHandler(handler, context) {\n  return function (initialOptions) {\n    context.startOptions = resolveStartOptions(initialOptions);\n    return handler(context.startOptions, initialOptions || {});\n  };\n} // src/setupWorker/start/createFallbackRequestListener.ts\n\n\nvar import_interceptors3 = require(\"@mswjs/interceptors\");\n\nvar import_fetch3 = require(\"@mswjs/interceptors/lib/interceptors/fetch\");\n\nvar import_XMLHttpRequest = require(\"@mswjs/interceptors/lib/interceptors/XMLHttpRequest\");\n\nfunction createFallbackRequestListener(context, options) {\n  var interceptor = new import_interceptors3.BatchInterceptor({\n    name: \"fallback\",\n    interceptors: [new import_fetch3.FetchInterceptor(), new import_XMLHttpRequest.XMLHttpRequestInterceptor()]\n  });\n  interceptor.on(\"request\", /*#__PURE__*/function () {\n    var _ref24 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(request) {\n      var mockedRequest, response2;\n      return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n        while (1) {\n          switch (_context13.prev = _context13.next) {\n            case 0:\n              _context13.t0 = _MockedRequest;\n              _context13.t1 = request.url;\n              _context13.t2 = __spreadProps;\n              _context13.t3 = __spreadValues({}, request);\n              _context13.next = 6;\n              return request.arrayBuffer();\n\n            case 6:\n              _context13.t4 = _context13.sent;\n              _context13.t5 = {\n                body: _context13.t4\n              };\n              _context13.t6 = (0, _context13.t2)(_context13.t3, _context13.t5);\n              mockedRequest = new _context13.t0(_context13.t1, _context13.t6);\n              _context13.next = 12;\n              return _handleRequest(mockedRequest, context.requestHandlers, options, context.emitter, {\n                transformResponse: function transformResponse(response3) {\n                  return {\n                    status: response3.status,\n                    statusText: response3.statusText,\n                    headers: response3.headers.all(),\n                    body: response3.body,\n                    delay: response3.delay\n                  };\n                },\n                onMockedResponseSent: function onMockedResponseSent(response3, _ref25) {\n                  var handler = _ref25.handler,\n                      publicRequest = _ref25.publicRequest,\n                      parsedRequest = _ref25.parsedRequest;\n\n                  if (!options.quiet) {\n                    handler.log(publicRequest, response3, handler, parsedRequest);\n                  }\n                }\n              });\n\n            case 12:\n              response2 = _context13.sent;\n\n              if (response2) {\n                request.respondWith(response2);\n              }\n\n            case 14:\n            case \"end\":\n              return _context13.stop();\n          }\n        }\n      }, _callee13);\n    }));\n\n    return function (_x24) {\n      return _ref24.apply(this, arguments);\n    };\n  }());\n  interceptor.apply();\n  return interceptor;\n} // src/setupWorker/start/createFallbackStart.ts\n\n\nfunction createFallbackStart(context) {\n  return /*#__PURE__*/function () {\n    var _start = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(options) {\n      return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n        while (1) {\n          switch (_context14.prev = _context14.next) {\n            case 0:\n              context.fallbackInterceptor = createFallbackRequestListener(context, options);\n              printStartMessage({\n                message: \"Mocking enabled (fallback mode).\",\n                quiet: options.quiet\n              });\n              return _context14.abrupt(\"return\", void 0);\n\n            case 3:\n            case \"end\":\n              return _context14.stop();\n          }\n        }\n      }, _callee14);\n    }));\n\n    function start(_x25) {\n      return _start.apply(this, arguments);\n    }\n\n    return start;\n  }();\n} // src/setupWorker/stop/createFallbackStop.ts\n\n\nfunction createFallbackStop(context) {\n  return function stop() {\n    var _a, _b;\n\n    (_a = context.fallbackInterceptor) == null ? void 0 : _a.dispose();\n    printStopMessage({\n      quiet: (_b = context.startOptions) == null ? void 0 : _b.quiet\n    });\n  };\n} // src/utils/internal/pipeEvents.ts\n\n\nfunction pipeEvents(source, destination) {\n  var rawEmit = source.emit;\n\n  if (rawEmit._isPiped) {\n    return;\n  }\n\n  source.emit = function (event) {\n    for (var _len11 = arguments.length, data2 = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n      data2[_key11 - 1] = arguments[_key11];\n    }\n\n    destination.emit.apply(destination, [event].concat(data2));\n    return rawEmit.call.apply(rawEmit, [this, event].concat(data2));\n  };\n\n  source.emit._isPiped = true;\n} // src/setupWorker/setupWorker.ts\n\n\nvar listeners = [];\n\nfunction _setupWorker() {\n  for (var _len12 = arguments.length, requestHandlers = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n    requestHandlers[_key12] = arguments[_key12];\n  }\n\n  requestHandlers.forEach(function (handler) {\n    if (Array.isArray(handler)) throw new Error(devUtils.formatMessage('Failed to call \"setupWorker\" given an Array of request handlers (setupWorker([a, b])), expected to receive each handler individually: setupWorker(a, b).'));\n  });\n\n  if ((0, import_is_node_process3.isNodeProcess)()) {\n    throw new Error(devUtils.formatMessage(\"Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.\"));\n  }\n\n  var emitter = new import_strict_event_emitter.StrictEventEmitter();\n  var publicEmitter = new import_strict_event_emitter.StrictEventEmitter();\n  pipeEvents(emitter, publicEmitter);\n  var context = {\n    isMockingEnabled: false,\n    startOptions: void 0,\n    worker: null,\n    registration: null,\n    requestHandlers: [].concat(requestHandlers),\n    emitter: emitter,\n    workerChannel: {\n      on: function on(eventType, callback) {\n        context.events.addListener(navigator.serviceWorker, \"message\", function (event) {\n          if (event.source !== context.worker) {\n            return;\n          }\n\n          var message = event.data;\n\n          if (!message) {\n            return;\n          }\n\n          if (message.type === eventType) {\n            callback(event, message);\n          }\n        });\n      },\n      send: function send(type) {\n        var _a;\n\n        (_a = context.worker) == null ? void 0 : _a.postMessage(type);\n      }\n    },\n    events: {\n      addListener: function addListener(target, eventType, callback) {\n        target.addEventListener(eventType, callback);\n        listeners.push({\n          eventType: eventType,\n          target: target,\n          callback: callback\n        });\n        return function () {\n          target.removeEventListener(eventType, callback);\n        };\n      },\n      removeAllListeners: function removeAllListeners() {\n        var _iterator7 = _createForOfIteratorHelper(listeners),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var _step7$value = _step7.value,\n                target = _step7$value.target,\n                eventType = _step7$value.eventType,\n                callback = _step7$value.callback;\n            target.removeEventListener(eventType, callback);\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n\n        listeners = [];\n      },\n      once: function once(eventType) {\n        var bindings = [];\n        return new Promise(function (resolve, reject) {\n          var handleIncomingMessage = function handleIncomingMessage(event) {\n            try {\n              var message = event.data;\n\n              if (message.type === eventType) {\n                resolve(message);\n              }\n            } catch (error2) {\n              reject(error2);\n            }\n          };\n\n          bindings.push(context.events.addListener(navigator.serviceWorker, \"message\", handleIncomingMessage), context.events.addListener(navigator.serviceWorker, \"messageerror\", reject));\n        }).finally(function () {\n          bindings.forEach(function (unbind) {\n            return unbind();\n          });\n        });\n      }\n    },\n    useFallbackMode: !(\"serviceWorker\" in navigator) || location.protocol === \"file:\"\n  };\n  var startHandler = context.useFallbackMode ? createFallbackStart(context) : createStartHandler(context);\n  var stopHandler = context.useFallbackMode ? createFallbackStop(context) : createStop(context);\n  return {\n    start: prepareStartHandler(startHandler, context),\n    stop: function stop() {\n      context.events.removeAllListeners();\n      context.emitter.removeAllListeners();\n      publicEmitter.removeAllListeners();\n      stopHandler();\n    },\n    use: function use() {\n      for (var _len13 = arguments.length, handlers = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        handlers[_key13] = arguments[_key13];\n      }\n\n      _use.apply(void 0, [context.requestHandlers].concat(handlers));\n    },\n    restoreHandlers: function restoreHandlers() {\n      _restoreHandlers(context.requestHandlers);\n    },\n    resetHandlers: function resetHandlers() {\n      for (var _len14 = arguments.length, nextHandlers = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        nextHandlers[_key14] = arguments[_key14];\n      }\n\n      context.requestHandlers = _resetHandlers.apply(void 0, [requestHandlers].concat(nextHandlers));\n    },\n    printHandlers: function printHandlers() {\n      context.requestHandlers.forEach(function (handler) {\n        var _handler$info3 = handler.info,\n            header = _handler$info3.header,\n            callFrame = _handler$info3.callFrame;\n        var pragma = handler.info.hasOwnProperty(\"operationType\") ? \"[graphql]\" : \"[rest]\";\n        console.groupCollapsed(\"\".concat(pragma, \" \").concat(header));\n\n        if (callFrame) {\n          console.log(\"Declaration: \".concat(callFrame));\n        }\n\n        console.log(\"Handler:\", handler);\n\n        if (handler instanceof _RestHandler) {\n          console.log(\"Match:\", \"https://mswjs.io/repl?path=\".concat(handler.info.path));\n        }\n\n        console.groupEnd();\n      });\n    },\n    events: {\n      on: function on() {\n        return publicEmitter.on.apply(publicEmitter, arguments);\n      },\n      removeListener: function removeListener() {\n        return publicEmitter.removeListener.apply(publicEmitter, arguments);\n      },\n      removeAllListeners: function removeAllListeners() {\n        return publicEmitter.removeAllListeners.apply(publicEmitter, arguments);\n      }\n    }\n  };\n} // src/rest.ts\n\n\nfunction createRestHandler(method) {\n  return function (path, resolver) {\n    return new _RestHandler(method, path, resolver);\n  };\n}\n\nvar _rest = {\n  all: createRestHandler(/.+/),\n  head: createRestHandler(\"HEAD\"\n  /* HEAD */\n  ),\n  get: createRestHandler(\"GET\"\n  /* GET */\n  ),\n  post: createRestHandler(\"POST\"\n  /* POST */\n  ),\n  put: createRestHandler(\"PUT\"\n  /* PUT */\n  ),\n  delete: createRestHandler(\"DELETE\"\n  /* DELETE */\n  ),\n  patch: createRestHandler(\"PATCH\"\n  /* PATCH */\n  ),\n  options: createRestHandler(\"OPTIONS\"\n  /* OPTIONS */\n  )\n}; // src/graphql.ts\n\nvar import_graphql2 = require(\"graphql\");\n\nfunction createScopedGraphQLHandler(operationType, url) {\n  return function (operationName, resolver) {\n    return new _GraphQLHandler(operationType, operationName, url, resolver);\n  };\n}\n\nfunction createGraphQLOperationHandler(url) {\n  return function (resolver) {\n    return new _GraphQLHandler(\"all\", new RegExp(\".*\"), url, resolver);\n  };\n}\n\nvar standardGraphQLHandlers = {\n  operation: createGraphQLOperationHandler(\"*\"),\n  query: createScopedGraphQLHandler(import_graphql2.OperationTypeNode.QUERY, \"*\"),\n  mutation: createScopedGraphQLHandler(import_graphql2.OperationTypeNode.MUTATION, \"*\")\n};\n\nfunction createGraphQLLink(url) {\n  return {\n    operation: createGraphQLOperationHandler(url),\n    query: createScopedGraphQLHandler(import_graphql2.OperationTypeNode.QUERY, url),\n    mutation: createScopedGraphQLHandler(import_graphql2.OperationTypeNode.MUTATION, url)\n  };\n}\n\nvar _graphql = __spreadProps(__spreadValues({}, standardGraphQLHandlers), {\n  link: createGraphQLLink\n}); // Annotate the CommonJS export names for ESM import in node:\n\n\n0 && (module.exports = {\n  GraphQLHandler: _GraphQLHandler,\n  MockedRequest: _MockedRequest,\n  RESTMethods: _RESTMethods,\n  RequestHandler: _RequestHandler,\n  RestHandler: _RestHandler,\n  cleanUrl: _cleanUrl,\n  compose: _compose,\n  context: context,\n  createResponseComposition: _createResponseComposition,\n  defaultContext: _defaultContext,\n  defaultResponse: _defaultResponse,\n  graphql: _graphql,\n  graphqlContext: _graphqlContext,\n  handleRequest: _handleRequest,\n  matchRequestUrl: _matchRequestUrl,\n  response: _response,\n  rest: _rest,\n  restContext: _restContext,\n  setupWorker: _setupWorker\n});","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AAAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;AAAA;;AAAAC,2C;;ACAA;;AAAApB;EAAAqB;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;EAAAC;IAAA;EAAA;AAAA,G;;;ACAA,mBAAqBC,uCAArB;;AAUO,IAAMH,UAAS,SAATA,OAAS,CACpBI,UADoB,EAEpBC,UAFoB,EAGI;EACxB,OAAO,UAACC,GAAD,EAAS;IACdA,IAAIN,MAAJ,GAAaI,UAAb;IACAE,IAAID,UAAJ,GACEA,cAAcE,qBAASC,OAAOJ,UAAP,CAAT,CADhB;IAGA,OAAOE,GAAP;EACF,CANA;AAOF,CAXO,C;;;ACVP,8BAAgCG,2BAAhC;;AA8BO,gBAUgB;EAAA,kCATlBC,IASkB;IATlBA,IASkB;EAAA;;EACrB,OAAO,UAACJ,GAAD,EAAS;IACd,IAAOK,IAAP,GAAsBD,IAAtB;IAAA,IAAaE,KAAb,GAAsBF,IAAtB;;IAEA,IAAI,OAAOC,IAAP,KAAgB,QAApB,EAA8B;MAC5BL,IAAIO,OAAJ,CAAYC,MAAZ,CAAmBH,IAAnB,EAAyBC,KAAzB;IACF,CAFA,MAEO;MACL,IAAMC,UAAU,6CAAgBF,IAAhB,CAAhB;MACAE,QAAQE,OAAR,CAAgB,UAACC,MAAD,EAAQC,KAAR,EAAiB;QAC/BX,IAAIO,OAAJ,CAAYC,MAAZ,CAAmBG,KAAnB,EAAyBD,MAAzB;MACD,CAFD;IAGF;;IAEA,OAAOV,GAAP;EACF,CAbA;AAcF,C;;;ACvDA,kBAA6BH,0BAA7B;;AAOO,IAAMX,UAAS,SAATA,OAAS,CACpBmB,IADoB,EAEpBC,KAFoB,EAGpBM,OAHoB,EAII;EACxB,OAAO,UAACZ,GAAD,EAAS;IACd,IAAMa,mBAAmBC,WAAY,UAAZ,CAAsBT,IAAtB,EAA4BC,KAA5B,EAAmCM,OAAnC,CAAzB;IACAZ,IAAIO,OAAJ,CAAYC,MAAZ,CAAmB,YAAnB,EAAiCK,gBAAjC;;IAEA,IAAI,OAAOE,QAAP,KAAoB,WAAxB,EAAqC;MACnCA,SAAS7B,MAAT,GAAkB2B,gBAAlB;IACF;;IAEA,OAAOb,GAAP;EACF,CATA;AAUF,CAfO,C;;;ACEA,IAAMf,QAAO,SAAPA,KAAO,CAGlBqB,KAHkB,EAIgB;EAClC,OAAO,UAACN,GAAD,EAAS;IACdA,IAAIf,IAAJ,GAAWqB,KAAX;IACA,OAAON,GAAP;EACF,CAHA;AAIF,CATO,C;;;ACLA,mBACLM,KADK,EAEkB;EACvB,IAAI;IACF,OAAOU,KAAKC,KAAL,CAAWX,KAAX,CAAP;EACF,CAFA,CAEA,OAASY,MAAT,EAAE;IACA,OAAO,MAAP;EACF;AACF,C;;;ACTO,kBAAkBZ,KAAlB,EAAuC;EAC5C,OAAOA,SAAS,IAAT,IAAiB,OAAOA,KAAP,KAAiB,QAAlC,IAA8C,CAACa,MAAMC,OAAN,CAAcd,KAAd,CAAtD;AACF,C;;;ACCO,oBACLe,IADK,EAELC,KAFK,EAGL;EACA,OAAOC,OAAOC,OAAP,CAAeF,KAAf,EAAsBG,MAAtB,CAA6B,UAACC,MAAD,QAA+B;IAAA;IAAA,IAArBC,GAAqB;IAAA,IAAhBC,UAAgB;;IACjE,IAAMC,YAAYH,OAAOC,GAAP,CAAlB;;IAEA,IAAIR,MAAMC,OAAN,CAAcS,SAAd,KAA4BV,MAAMC,OAAN,CAAcQ,UAAd,CAAhC,EAA2D;MACzDF,OAAOC,GAAP,IAAcE,UAAUC,MAAV,CAAiBF,UAAjB,CAAd;MACA,OAAOF,MAAP;IACF;;IAEA,IAAIK,SAASF,SAAT,KAAuBE,SAASH,UAAT,CAA3B,EAAiD;MAC/CF,OAAOC,GAAP,IAAcK,WAAWH,SAAX,EAAsBD,UAAtB,CAAd;MACA,OAAOF,MAAP;IACF;;IAEAA,OAAOC,GAAP,IAAcC,UAAd;IACA,OAAOF,MAAP;EACF,CAfO,EAeJH,OAAOU,MAAP,CAAc,EAAd,EAAkBZ,IAAlB,CAfI,CAAP;AAgBF,C;;;ACdO,IAAM7B,QAAO,SAAPA,KAAO,CAClB0C,KADkB,EAEoB;EACtC,OAAO,UAAClC,GAAD,EAAS;IACdA,IAAIO,OAAJ,CAAYd,GAAZ,CAAgB,cAAhB,EAAgC,kBAAhC;IACAO,IAAIf,IAAJ,GAAW+B,KAAKmB,SAAL,CAAeD,KAAf,CAAX;IAEA,OAAOlC,GAAP;EACF,CALA;AAMF,CATO,C;;;ACDA,IAAMb,QAAuD,SAAvDA,KAAuD,CAClEiD,OADkE,EAE/D;EACH,OAAO,UAACpC,GAAD,EAAS;IACd,IAAMqC,WAAWC,UAAUtC,IAAIf,IAAd,KAAuB,EAAxC;IACA,IAAMsD,WAAWP,WAAWK,QAAX,EAAqB;MAAElD,MAAMiD;IAAR,CAArB,CAAjB;IAEA,OAAO5C,MAAK+C,QAAL,EAAevC,GAAf,CAAP;EACF,CALA;AAMF,CATO,C;;;ACAA,IAAMV,cAA6D,SAA7DA,WAA6D,CACxE8C,OADwE,EAErE;EACH,OAAO,UAACpC,GAAD,EAAS;IACd,IAAMqC,WAAWC,UAAUtC,IAAIf,IAAd,KAAuB,EAAxC;IACA,IAAMsD,WAAWP,WAAWK,QAAX,EAAqB;MAAE/C,YAAY8C;IAAd,CAArB,CAAjB;IACA,OAAO5C,MAAK+C,QAAL,EAAevC,GAAf,CAAP;EACF,CAJA;AAKF,CARO,C;;;ACXP,6BAA8BG,0BAA9B;;AAGO,IAAMqC,8BAA8B,UAApC;AACA,IAAMC,2BAA2B,GAAjC;AACA,IAAMC,2BAA2B,GAAjC;AACA,IAAMC,4BAA4B,CAAlC;;AAEP,IAAMC,8BAA8B,SAA9BA,2BAA8B,GAAM;EACxC,IAAI,2CAAJ,EAAqB;IACnB,OAAOD,yBAAP;EACF;;EAEA,OAAOE,KAAKC,KAAL,CACLD,KAAKE,MAAL,MAAiBL,2BAA2BD,wBAA5C,IACEA,wBAFG,CAAP;AAIF,CATA;;AAqBO,IAAMrD,SAAQ,SAARA,MAAQ,CACnB4D,cADmB,EAEK;EACxB,OAAO,UAAChD,GAAD,EAAS;IACd,IAAIiD,SAAJ;;IAEA,IAAI,OAAOD,cAAP,KAA0B,QAA9B,EAAwC;MACtC,QAAQA,cAAR;QAAQ,KACD,UADC;UACW;YAGfC,YAAYT,2BAAZ;YACA;UACF;;QAAA,KACK,MADL;UACa;YACXS,YAAYL,6BAAZ;YACA;UACF;;QAAA;UACS;YACP,MAAM,IAAIM,KAAJ,4DAC+CF,cAD/C,wHAAN;UAGF;MAfF;IAiBF,CAlBA,MAkBA,IAAW,OAAOA,cAAP,KAA0B,WAArC,EAAkD;MAEhDC,YAAYL,6BAAZ;IACF,CAHA,MAGO;MAGL,IAAII,iBAAiBR,2BAArB,EAAkD;QAChD,MAAM,IAAIU,KAAJ,gEACoDF,cADpD,wEAC8HR,2BAD9H,mOAAN;MAGF;;MAEAS,YAAYD,cAAZ;IACF;;IAEAhD,IAAIZ,KAAJ,GAAY6D,SAAZ;IACA,OAAOjD,GAAP;EACF,CAtCA;AAuCF,CA1CO,C;;;AClBA,IAAMX,UAAS,SAATA,OAAS,CAGpB8D,UAHoB,EAIY;EAChC,OAAO,UAACnD,GAAD,EAAS;IACd,IAAImD,cAAc,IAAlB,EAAwB;MACtB,OAAOnD,GAAP;IACF;;IAEA,IAAMqC,WAAWC,UAAUtC,IAAIf,IAAd,KAAuB,EAAxC;IACA,IAAMsD,WAAWP,WAAWK,QAAX,EAAqB;MAAEhD,QAAQ8D;IAAV,CAArB,CAAjB;IAEA,OAAO3D,MAAK+C,QAAL,EAAevC,GAAf,CAAP;EACF,CATA;AAUF,CAfO,C;;;ACXP,8BAA8BG,0BAA9B;;AACA,+BAAwBA,2BAAxB;;AAGA,IAAMiD,WACJ,+CAAkBjD,QAAQ,YAAR,CAAlB,GAA0CkD,OAAO9D,KADnD;;AAGO,IAAM+D,qBAAqB,SAArBA,kBAAqB,CAACC,WAAD,EAA2C;EAC3E,IAAMhD,UAAU,IAAIiD,gCAAJ,CAAYD,YAAYhD,OAAxB,CAAhB;EACAA,QAAQd,GAAR,CAAY,cAAZ,EAA4B,MAA5B;EAEA,OAAOgE,iCACFF,WADE;IAELhD,SAASA,QAAQmD,GAAR;EAFJ,EAAP;AAIF,CARO;;AAUP,IAAMC,+BAA+B,SAA/BA,4BAA+B,CAACC,KAAD,EAAuC;EAC1E,IAAQ1B,KAAR,GAAyB0B,KAAzB,CAAQ3E,IAAR;EAAA,IAAc4E,MAAd,GAAyBD,KAAzB,CAAcC,MAAd;;EACA,IAAMC,oBAAiCL,iCAClCG,KADkC;IAErC3E,MAAM;EAF+B,EAAvC;;EAKA,IAAI,CAAC,KAAD,EAAQ,MAAR,EAAgB8E,QAAhB,CAAyBF,MAAzB,CAAJ,EAAsC;IACpC,OAAOC,iBAAP;EACF;;EAEA,IACE,OAAO5B,KAAP,KAAgB,QAAhB,IACA,OAAOA,KAAP,KAAgB,QADhB,IAEA,OAAOA,KAAP,KAAgB,SAHlB,EAIE;IACA4B,kBAAkB7E,IAAlB,GAAyB+B,KAAKmB,SAAL,CAAeD,KAAf,CAAzB;EACF,CANA,MAMO;IACL4B,kBAAkB7E,IAAlB,GAAyBiD,KAAzB;EACF;;EAEA,OAAO4B,iBAAP;AACF,CAtBA;;AA8BO,IAAMvE,SAAQ,SAARA,MAAQ,CACnBqE,KADmB,EAGG;EAAA,IADtBL,WACsB,uEADK,EACL;;EACtB,IAAI,OAAOK,KAAP,KAAiB,QAArB,EAA+B;IAC7B,OAAOR,SAASQ,KAAT,EAAgBN,mBAAmBC,WAAnB,CAAhB,CAAP;EACF;;EAEA,IAAMO,oBAAoBH,6BAA6BC,KAA7B,CAA1B;EACA,IAAMI,qBAAqBV,mBAAmBQ,iBAAnB,CAA3B;EAEA,OAAOV,SAASQ,MAAMK,GAAN,CAAUC,IAAnB,EAAyBF,kBAAzB,CAAP;AACF,CAZO,C;;;ACvCA,IAAMrE,QAAO,SAAPA,KAAO,CAClBuC,KADkB,EAEgB;EAClC,OAAO,UAAClC,GAAD,EAAS;IACdA,IAAIO,OAAJ,CAAYd,GAAZ,CAAgB,cAAhB,EAAgC,YAAhC;IACAO,IAAIf,IAAJ,GAAWiD,KAAX;IACA,OAAOlC,GAAP;EACF,CAJA;AAKF,CARO,C;;;ACCA,IAAMJ,OAAM,SAANA,IAAM,CACjBsC,KADiB,EAEiB;EAClC,OAAO,UAAClC,GAAD,EAAS;IACdA,IAAIO,OAAJ,CAAYd,GAAZ,CAAgB,cAAhB,EAAgC,UAAhC;IACAO,IAAIf,IAAJ,GAAWiD,KAAX;IACA,OAAOlC,GAAP;EACF,CAJA;AAKF,CARO,C;;;ACTP,8BAA8BG,0BAA9B;;AACA,kCAAmCA,+BAAnC,C;;;ACDA,oBAAsBA,4BAAtB,C;;;ACAA,mBAAsBA,4BAAtB,C;;;ACMO,IAAMgE,0BAA0B,SAA1BA,uBAA0B,CACrCC,YADqC,EAErCC,iBAFqC,EAGrCC,UAHqC,EAIZ;EACzB,IAAMC,YAAY,CAChBH,aAAaI,MADG,EAEhBJ,aAAaK,UAFG,EAGhBL,aAAaM,OAHG,CAAlB;EAKA,IAAMC,iBAAiBJ,UAAUK,MAAV,CAAiBC,OAAjB,CAAvB;EACA,IAAMC,aAAaH,eAAeI,IAAf,CAAoB,UAACC,MAAD,EAAY;IACjD,OAAOV,WAAWU,OAAOC,SAAlB,EAA6BZ,iBAA7B,CAAP;EACD,CAFkB,CAAnB;EAIA,OAAOS,cAAc,IAArB;AACF,CAhBO,C;;;ACFA,8BAA8BI,WAA9B,EAA2D;EAChE,OAAO,IAAIC,GAAJ,CAAQD,WAAR,EAAqBE,SAASC,MAA9B,EAAsCnB,IAA7C;AACF,C;;;ACNA,wBAAuB/D,qBAAvB;;AAEA,IAAMmF,iBAAiB,OAAvB;;AAKA,uBAAuBC,OAAvB,EAAuE;EAAA,mCAA5BC,WAA4B;IAA5BA,WAA4B;EAAA;;EACrE,IAAMC,sBAAsB,6CAAOF,OAAP,SAAmBC,WAAnB,EAA5B;EACA,iBAAUF,cAAV,cAA4BG,mBAA5B;AACF;;AAKA,cAAcF,OAAd,EAA4D;EAAA,mCAA1BC,WAA0B;IAA1BA,WAA0B;EAAA;;EAC1DE,QAAQC,IAAR,CAAaC,6BAAcL,OAAd,SAA0BC,WAA1B,EAAb;AACF;;AAKA,eAAeD,OAAf,EAA6D;EAAA,mCAA1BC,WAA0B;IAA1BA,WAA0B;EAAA;;EAC3DE,QAAQG,KAAR,CAAcD,6BAAcL,OAAd,SAA0BC,WAA1B,EAAd;AACF;;AAEO,IAAMM,WAAW;EACtBF,4BADsB;EAEtBD,UAFsB;EAGtBE;AAHsB,CAAjB,C;;AHhBA,IAAME;EAAA,uEAAoB,kBAC/B9B,GAD+B;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;;IAAA;MAAA;QAAA;UAAA;YAE/BrD,OAF+B,8DAEA,EAFA;YAG/B0D,UAH+B;YAMzBD,iBANyB,GAML2B,qBAAqB/B,GAArB,CANK;YAAA;YAAA,OAQCgC,UAAUC,aAAV,CAC7BC,gBAD6B,GAE7BC,IAF6B,CAExB,UAACC,aAAD;cAAA,OACJA,cAAczB,MAAd,CAAqB,UAACR,YAAD;gBAAA,OACnBD,wBAAwBC,YAAxB,EAAsCC,iBAAtC,EAAyDC,UAAzD,CADmB;cAAA,CAArB,CADI;YAAA,CAFwB,CARD;;UAAA;YAQzBgC,iBARyB;;YAe/B,IAAI,CAACL,UAAUC,aAAV,CAAwBK,UAAzB,IAAuCD,kBAAkBE,MAAlB,GAA2B,CAAtE,EAAyE;cAOvEpB,SAASqB,MAAT;YACF;;YAvB+B,oCAyBAH,iBAzBA,MAyBxBI,oBAzBwB;;YAAA,KA2B3BA,oBA3B2B;cAAA;cAAA;YAAA;;YAAA,kCA6BtBA,qBAAqBC,MAArB,GAA8BP,IAA9B,CAAmC,YAAM;cAC9C,OAAO,CACLjC,wBACEuC,oBADF,EAEErC,iBAFF,EAGEC,UAHF,CADK,EAMLoC,oBANK,CAAP;YAQD,CATM,CA7BsB;;UAAA;YAAA;YAAA,OA0CC,iGAC9B;cAAA;cAAA;gBAAA;kBAAA;oBAAA;sBAAA;sBAAA,OAC6BT,UAAUC,aAAV,CAAwBU,QAAxB,CAAiC3C,GAAjC,EAAsCrD,OAAtC,CAD7B;;oBAAA;sBACQwD,YADR;sBAAA,iCAES,CAGLD,wBAAwBC,YAAxB,EAAsCC,iBAAtC,EAAyDC,UAAzD,CAHK,EAILF,YAJK,CAFT;;oBAAA;oBAAA;sBAAA;kBAAA;gBAAA;cAAA;YAAA,CAD8B,GA1CD;;UAAA;YAAA;YAAA;YA0CxBlD,MA1CwB;YA0CjB2F,QA1CiB;;YAAA,KAuD3B3F,MAvD2B;cAAA;cAAA;YAAA;;YAwDvB4F,eAxDuB,GAwDL5F,OAAMqE,OAAN,CAAcxB,QAAd,CAAuB,OAAvB,CAxDK;;YAAA,KA4DzB+C,eA5DyB;cAAA;cAAA;YAAA;;YA6DrBC,QA7DqB,GA6DV,IAAI5B,GAAJ,CAAQ,oCAAS6B,KAAT,KAAkB,GAA1B,EAA+B5B,SAASlB,IAAxC,CA7DU;YAAA,MA+DrB,IAAIhB,KAAJ,CACJ4C,SAASF,aAAT,2DAC0CmB,SAAS7C,IADnD,8BAC2EG,iBAD3E,gNADI,CA/DqB;;UAAA;YAAA,MA0EvB,IAAInB,KAAJ,CACJ4C,SAASF,aAAT,CACE,8CADF,EAEE1E,OAAMqE,OAFR,CADI,CA1EuB;;UAAA;YAAA,kCAkFxBsB,QAlFwB;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAApB;;EAAA;IAAA;EAAA;AAAA,GAAN,C;;;AIEA,6BAA6D;EAAA,IAAlCzG,IAAkC,uEAAJ,EAAI;;EAClE,IAAIA,KAAK6G,KAAT,EAAgB;IACd;EACF;;EAEA,IAAM1B,UAAUnF,KAAKmF,OAAL,IAAgB,kBAAhC;EAEAG,QAAQwB,cAAR,aACOpB,SAASF,aAAT,CAAuBL,OAAvB,CADP,GAEE,mCAFF;EAIAG,QAAQyB,GAAR,CACE,0CADF,EAEE,kBAFF,EAGE,oBAHF;EAKAzB,QAAQyB,GAAR,CAAY,qDAAZ;;EAEA,IAAI/G,KAAKgH,SAAT,EAAoB;IAClB1B,QAAQyB,GAAR,CAAY,oBAAZ,EAAkC/G,KAAKgH,SAAvC;EACF;;EAEA,IAAIhH,KAAKiH,WAAT,EAAsB;IACpB3B,QAAQyB,GAAR,CAAY,eAAZ,EAA6B/G,KAAKiH,WAAlC;EACF;;EAEA3B,QAAQ4B,QAAR;AACF,C;;;SChCAC,a;;;;;;8EAAA,mBACEnJ,OADF,EAEEwC,OAFF;IAAA;;IAAA;MAAA;QAAA;UAAA;YAIExC,QAAQoJ,aAAR,CAAsBC,IAAtB,CAA2B,eAA3B;YAJF;YAAA,OAKQrJ,QAAQsJ,MAAR,CAAeC,IAAf,CAAoB,iBAApB,CALR;;UAAA;YAAA,KAUMvJ,QAAQwJ,gBAVd;cAAA;cAAA;YAAA;;YAWI9B,SAASH,IAAT;YAXJ;;UAAA;YAiBEvH,QAAQwJ,gBAAR,GAA2B,IAA3B;YAEAC,kBAAkB;cAChBZ,OAAOrG,QAAQqG,KADC;cAEhBI,aAAa,cAAQjD,YAAR,wBAAsB4C,KAFnB;cAGhBI,WAAW,cAAQpC,MAAR,wBAAgBC;YAHX,CAAlB;;UAnBF;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,C;;;;ACYO;EAAA;;EACL,uBAA6B6C,IAA7B,EAAgD;IAAA;;IAAnB;EAAoB;;EAD5C;IAAA;IAAA,OAGE,qBACLC,KADK,EAGC;MAAA,mCADHC,KACG;QADHA,KACG;MAAA;;MACN,IAAOC,KAAP,GAAyBD,KAAzB;MAAA,IAAaE,QAAb,GAAyBF,KAAzB;MACA,KAAKF,IAAL,CAAUK,WAAV,CAAsB;QAAEC,MAAML,KAAR;QAAe5I;MAAf,CAAtB,EAA6C;QAAE+I;MAAF,CAA7C;IACF;EATK;;EAAA;AAAA,I;;;ACnBA;EAAA;;EAAA;;EAAA;;EACL,sBAAY3C,OAAZ,EAA6B;IAAA;;IAAA;;IAC3B,0BAAMA,OAAN;IACA,MAAKlF,IAAL,GAAY,cAAZ;IAF2B;EAG7B;;EAJK;AAAA,iCAA2B6C,KAA3B,G;;;ACAP,2BAA6B/C,8BAA7B;;AACA,+BAAwBA,2BAAxB,C;;;ACDA,mBAA6BN,0BAA7B;;AACA,qBAAsBM,yBAAtB;;AACA,0BAA+CA,8BAA/C;;AACA,yBAA6BA,oDAA7B;;AACA,iBAAwBA,+BAAxB,C;;;ACJA,mBAA6BN,0BAA7B;;AAGA,yBAAyB;EACvB,OAAOwI,YAAY,MAAZ,CAAkBtH,SAAS7B,MAA3B,CAAP;AACF;;AAKO,2BAA2BoJ,OAA3B,EAAmD;EAIxD,IAAI,OAAOvH,QAAP,KAAoB,WAApB,IAAmC,OAAOqE,QAAP,KAAoB,WAA3D,EAAwE;IACtE,OAAO,EAAP;EACF;;EAEA,QAAQkD,QAAQC,WAAhB;IAAgB,KACT,aADS;MACM;QAGlB,OAAOnD,SAASC,MAAT,KAAoBiD,QAAQrE,GAAR,CAAYoB,MAAhC,GAAyCmD,eAAzC,GAA2D,EAAlE;MACF;;IAAA,KAEK,SAFL;MAEgB;QAEd,OAAOA,eAAP;MACF;;IAAA;MAES;QACP,OAAO,EAAP;MACF;EAdF;AAgBF,C;;;AClCA,+BAAgCrI,2BAAhC;;AAgBA,6BAA6BsI,aAA7B,EAA0E;EAhB1E;;EAiBE,IAAMlI,UAAU,8CAAgBkI,aAAhB,CAAhB;EACA,IAAMC,cAAcnI,QAAQoI,GAAR,CAAY,cAAZ,KAA+B,YAAnD;EACA,IAAMC,cAAcrI,QAAQoI,GAAR,CAAY,qBAAZ,CAApB;;EAEA,IAAI,CAACC,WAAL,EAAkB;IAChB,MAAM,IAAI1F,KAAJ,CAAU,2CAAV,CAAN;EACF;;EAEA,IAAM2F,aAAaD,YAAYE,KAAZ,CAAkB,GAAlB,EAAuBrH,MAAvB,CAA8B,UAACsH,GAAD,EAAMC,KAAN,EAAgB;IAC/D,wBAAwBA,MAAMC,IAAN,GAAaH,KAAb,CAAmB,GAAnB,CAAxB;IAAA;IAAA,IAAOnI,KAAP;IAAA,IAAgBqH,KAAhB;;IACAe,IAAIpI,KAAJ,IAAYqH,MAAKkB,IAAL,CAAU,GAAV,CAAZ;IACA,OAAOH,GAAP;EACF,CAJmB,EAIhB,EAJgB,CAAnB;EAMA,IAAM1I,OAAO,iBAAWA,IAAX,wBAAiB8I,KAAjB,CAAuB,CAAvB,EAA0B,EAA1B,CAAb;EACA,IAAMC,WAAW,iBAAWA,QAAX,wBAAqBD,KAArB,CAA2B,CAA3B,EAA8B,EAA9B,CAAjB;EAEA,OAAO;IACL9I,UADK;IAEL+I,kBAFK;IAGLV;EAHK,CAAP;AAKF;;AAMO,4BACLT,KADK,EAEL1H,OAFK,EAGU;EACf,IAAMmI,cAAcnI,mCAASoI,GAAT,CAAa,cAAb,CAApB;;EAEA,IAAI,CAACD,WAAL,EAAkB;IAChB,OAAO,MAAP;EACF;;EAEA,yBAA0BA,YAAYI,KAAZ,CAAkB,KAAlB,CAA1B;EAAA;EAAA,IAAYD,UAAZ;;EACA,IAAMQ,WAAWR,WACdjE,MADc,CACP,UAAC0E,CAAD;IAAA,OAAOA,EAAEC,UAAF,CAAa,WAAb,CAAP;EAAA,CADO,EAEdC,GAFc,CAEV,UAACC,CAAD;IAAA,OAAOA,EAAEC,OAAF,CAAU,YAAV,EAAwB,EAAxB,CAAP;EAAA,CAFU,EAE0B,CAF1B,CAAjB;;EAIA,IAAI,CAACL,QAAL,EAAe;IACb,OAAO,MAAP;EACF;;EAEA,IAAMM,iBAAiB,IAAIC,MAAJ,cAAiBP,QAAjB,EAAvB;EACA,IAAMQ,SAAS5B,MACZa,KADY,CACNa,cADM,EAEZ/E,MAFY,CAEL,UAACoE,KAAD;IAAA,OAAWA,MAAMO,UAAN,CAAiB,MAAjB,KAA4BP,MAAMc,QAAN,CAAe,MAAf,CAAvC;EAAA,CAFK,EAGZN,GAHY,CAGR,UAACR,KAAD;IAAA,OAAWA,MAAMe,SAAN,GAAkBL,OAAlB,CAA0B,OAA1B,EAAmC,EAAnC,CAAX;EAAA,CAHQ,CAAf;;EAKA,IAAI,CAACG,OAAOrD,MAAZ,EAAoB;IAClB,OAAO,MAAP;EACF;;EAEA,IAAMwD,aAA0C,EAAhD;;EAEA,IAAI;IAAA,4CACkBH,MADlB;IAAA;;IAAA;MACF,uDAA4B;QAAA,IAAjBI,MAAiB;;QAC1B,oBAAkCA,OAAMnB,KAAN,CAAY,UAAZ,CAAlC;QAAA;QAAA,IAAOoB,cAAP;QAAA,IAA0BlC,KAA1B;;QACA,IAAMmC,cAAcnC,MAAKkB,IAAL,CAAU,UAAV,CAApB;;QACA,2BACEkB,oBAAoBF,cAApB,CADF;QAAA,IAAQG,YAAR,wBAAQ3B,WAAR;QAAA,IAAqBU,QAArB,wBAAqBA,QAArB;QAAA,IAA+B/I,IAA/B,wBAA+BA,IAA/B;;QAGA,IAAMC,QACJ8I,aAAa,MAAb,GACIe,WADJ,GAEI,IAAIG,IAAJ,CAAS,CAACH,WAAD,CAAT,EAAwBf,QAAxB,EAAkC;UAAEhB,MAAMiC;QAAR,CAAlC,CAHN;QAKA,IAAME,cAAcP,WAAW3J,IAAX,CAApB;;QAEA,IAAIkK,gBAAgB,MAApB,EAA+B;UAC7BP,WAAW3J,IAAX,IAAmBC,KAAnB;QACF,CAFA,MAEA,IAAWa,MAAMC,OAAN,CAAcmJ,WAAd,CAAX,EAAuC;UACrCP,WAAW3J,IAAX,iCAAuBkK,WAAvB,IAAoCjK,KAApC;QACF,CAFA,MAEO;UACL0J,WAAW3J,IAAX,IAAmB,CAACkK,WAAD,EAAcjK,KAAd,CAAnB;QACF;MACF;IArBE;MAAA;IAAA;MAAA;IAAA;;IAuBF,OAAO0J,UAAP;EACF,CAxBA,CAwBA,OAAS9I,MAAT,EAAE;IACA,OAAO,MAAP;EACF;AACF,C;;;AChGO,mBAAmBgB,KAAnB,EAAiD3B,OAAjD,EAAoE;EAP3E;;EASE,IAAI,CAAC2B,KAAL,EAAW;IACT,OAAOA,KAAP;EACF;;EAEA,IAAMwG,cAAc,0CAASC,GAAT,CAAa,cAAb,yBAA8B6B,WAA9B,OAA+C,EAAnE;EAIA,IAAMC,sBAAsB/B,YAAYa,UAAZ,CAAuB,qBAAvB,CAA5B;;EACA,IAAIkB,uBAAuB,OAAOvI,KAAP,KAAgB,QAA3C,EAAqD;IACnD,OAAOwI,mBAAmBxI,MAAKyI,QAAL,EAAnB,EAAoCpK,OAApC,KAAgD2B,KAAvD;EACF;;EAIA,IAAM0I,iBAAiBlC,YAAY3E,QAAZ,CAAqB,MAArB,CAAvB;;EAEA,IAAI6G,kBAAkB,OAAO1I,KAAP,KAAgB,QAAtC,EAAgD;IAC9C,OAAOI,UAAUJ,MAAKyI,QAAL,EAAV,KAA8BzI,KAArC;EACF;;EAGA,OAAOA,KAAP;AACF,C;;;AC7BO,uBAAuB2I,MAAvB,EAAuCC,QAAvC,EAAkE;EACvE,OAAOD,OAAOL,WAAP,OAAyBM,SAASN,WAAT,EAAhC;AACF,C;;;AJmEO;EAAA;;EAAA;;EAAA;;EAcL,wBAAYvG,GAAZ,EAAoD;IAAA;;IAAA,IAA9B8G,IAA8B,uEAAJ,EAAI;;IAAA;;IAClD,4BAAM9G,GAAN,EAAW8G,IAAX;;IACA,IAAIA,KAAKC,EAAT,EAAa;MACX,OAAKA,EAAL,GAAUD,KAAKC,EAAf;IACF;;IACA,OAAKC,KAAL,GAAaF,KAAKE,KAAL,IAAc,SAA3B;IACA,OAAKC,WAAL,GAAmBH,KAAKG,WAAL,IAAoB,EAAvC;IACA,OAAKC,SAAL,GAAiBJ,KAAKI,SAAL,IAAkB,EAAnC;IACA,OAAKC,SAAL,GAAiBL,KAAKK,SAAL,IAAkB,KAAnC;IACA,OAAKC,IAAL,GAAYN,KAAKM,IAAL,IAAa,MAAzB;IACA,OAAKC,QAAL,GAAgBP,KAAKO,QAAL,IAAiB,MAAjC;IACA,OAAKC,QAAL,GAAgBR,KAAKQ,QAAL,IAAiB,QAAjC;IACA,OAAKC,QAAL,GAAgBT,KAAKS,QAAL,IAAiB,EAAjC;IACA,OAAKC,cAAL,GAAsBV,KAAKU,cAAL,IAAuB,aAA7C;IACA,OAAKC,OAAL,GAAeX,KAAKW,OAAL,IAAgB,OAAKC,UAAL,EAA/B;IAdkD;EAepD;;EA7BK;IAAA;IAAA,KA6BL,eAQ+B;MAC7B,IAAMC,QAAO,qCAAa,KAAK,OAAL,CAAb,CAAb;MAQA,IAAM1J,QAAO2J,UAAUD,KAAV,EAAgB,KAAKrL,OAArB,CAAb;;MAEA,IAAIuL,cAAc,KAAKjI,MAAnB,EAA2B,KAA3B,KAAqC3B,UAAS,EAAlD,EAAsD;QACpD,OAAO,MAAP;MACF;;MAEA,OAAOA,KAAP;IACF;EArDK;IAAA;IAAA,OA2DE,uBAAoC;MACzC,OAAO;QAGLxC,QAAQ,GAHH;QAILK,YAAY,UAJP;QAKLQ,SAAS,IAAIwL,kBAAJ,EALJ;QAML9M,MAAM,IAND;QASL+M,aAAa,IATR;QAULrE,MAAM;MAVD,CAAP;IAYF;EAxEK;IAAA;IAAA,OA0EG,sBAAqC;MAlJ/C;;MAoJI,IAAMsE,uBAAuB,KAAK1L,OAAL,CAAaoI,GAAb,CAAiB,QAAjB,CAA7B;MACA,IAAMuD,aAAaD,uBACfE,YAAY,MAAZ,CAAkBF,oBAAlB,CADe,GAEf,EAFJ;MAIAG,qBAAMC,OAAN;MAEA,IAAMC,mBAAmBnL,MAAMoL,IAAN,CACvB,2BAAM5D,GAAN,CAAUlF,iCAAK,IAAL;QAAWQ,KAAK,KAAKA,GAAL,CAASC;MAAzB,EAAV,yBAA4C1C,OAA5C,EADuB,EAEvBC,MAFuB,CAEhB,UAACiK,OAAD,SAAgC;QAAA;QAAA,IAArBrL,IAAqB;QAAA,IAAbC,KAAa,YAAbA,KAAa;;QACvC,OAAOiB,OAAOU,MAAP,CAAcyJ,OAAd,sBAA0BrL,KAAK4I,IAAL,EAA1B,EAAwC3I,KAAxC,EAAP;MACF,CAJyB,EAItB,EAJsB,CAAzB;MAQA,IAAMkM,sBAAsBC,kBAAkB,IAAlB,CAA5B;;MAEA,IAAMC,mBAAmBC,kCACpBH,mBADoB,GAEpBF,gBAFoB,CAAzB;;MAKA,mCAA4B/K,OAAOC,OAAP,CAAekL,gBAAf,CAA5B,qCAA8D;QAA9D;QAAA,IAAYrM,IAAZ;QAAA,IAAkBC,KAAlB;;QACE,KAAKC,OAAL,CAAaC,MAAb,CAAoB,QAApB,YAAiCH,IAAjC,cAAyCC,KAAzC;MACF;;MAEA,OAAOqM,kCACFD,gBADE,GAEFR,UAFE,CAAP;IAIF;EA1GK;;EAAA;AAAA,EAEGU,qCAFH,E;;;AD/DA,4BACLC,UADK,EAEU;EACf,IAAM5I,MAAM,IAAIkB,GAAJ,CAAQ0H,WAAW5I,GAAnB,CAAZ;EACA,IAAM1D,UAAU,IAAIuM,gCAAJ,CAAYD,WAAWtM,OAAvB,CAAhB;EAEA,OAAO,IAAIzC,cAAJ,CAAkBmG,GAAlB,EAAuBR,iCACzBoJ,UADyB;IAE5B5N,MAAM,uCAAa4N,WAAW5N,IAAX,IAAmB,EAAhC,CAFsB;IAG5BsB;EAH4B,EAAvB,CAAP;AAKF,C;;;AMpBA,oBAAsBJ,4BAAtB,C;;;ACqBO,IAAM4M;EAAA,uEAAc,kBAIzBzE,OAJyB,EAKzB0E,QALyB,EAMzBC,iBANyB;IAAA;IAAA;MAAA;QAAA;UAAA;YAQnBC,gBARmB,GAQAF,SAASpI,MAAT,CAAgB,UAACuI,OAAD,EAAa;cACpD,OAAOA,QAAQC,IAAR,CAAa9E,OAAb,EAAsB2E,iBAAtB,CAAP;YACD,CAFwB,CARA;;YAAA,MAYrBC,iBAAiB1G,MAAjB,KAA4B,CAZP;cAAA;cAAA;YAAA;;YAAA,kCAahB;cACL2G,SAAS,MADJ;cAELvO,UAAU;YAFL,CAbgB;;UAAA;YAAA;YAAA,OAmBJsO,iBAAiBzL,MAAjB;cAAA,uEAEnB,kBAAO4L,eAAP,EAAwBF,OAAxB;gBAAA;gBAAA;kBAAA;oBAAA;sBAAA;wBAAA;wBAAA,OAC8BE,eAD9B;;sBAAA;wBACMC,eADN;;wBAAA,IAGK,EAACA,mDAAiB1O,QAAlB,CAHL;0BAAA;0BAAA;wBAAA;;wBAAA,kCAISyO,eAJT;;sBAAA;wBAAA;wBAAA,OAOqBF,QAAQI,GAAR,CAAYjF,OAAZ,EAAqB2E,iBAArB,CAPrB;;sBAAA;wBAOMO,OAPN;;wBAAA,MASIA,YAAW,IAAX,IAAmBA,QAAOL,OAAP,CAAeM,UATtC;0BAAA;0BAAA;wBAAA;;wBAAA,kCAUS,IAVT;;sBAAA;wBAAA,IAaKD,QAAO5O,QAbZ;0BAAA;0BAAA;wBAAA;;wBAAA,kCAcS;0BACL0J,SAASkF,QAAOlF,OADX;0BAEL6E,SAASK,QAAOL,OAFX;0BAGLvO,UAAU,MAHL;0BAIL8O,cAAcF,QAAOE;wBAJhB,CAdT;;sBAAA;wBAsBA,IAAIF,QAAO5O,QAAP,CAAgB+I,IAApB,EAA0B;0BACxBwF,QAAQQ,aAAR,CAAsB,IAAtB;wBACF;;wBAxBA,kCA0BOH,OA1BP;;sBAAA;sBAAA;wBAAA;oBAAA;kBAAA;gBAAA;cAAA,CAFmB;;cAAA;gBAAA;cAAA;YAAA,KA6BlBI,QAAQC,OAAR,CAAgB,IAAhB,CA7BkB,CAnBI;;UAAA;YAmBnBnM,MAnBmB;;YAAA,IAqDpBA,MArDoB;cAAA;cAAA;YAAA;;YAAA,kCAsDhB;cACLyL,SAAS,MADJ;cAELvO,UAAU;YAFL,CAtDgB;;UAAA;YAAA,kCA4DlB;cACLuO,SAASzL,OAAOyL,OADX;cAELW,eAAepM,OAAO4G,OAFjB;cAGLyF,eAAerM,OAAOgM,YAHjB;cAIL9O,UAAU8C,OAAO9C;YAJZ,CA5DkB;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAAd;;EAAA;IAAA;EAAA;AAAA,GAAN,C;;;ACrBP,4BAAgCiB,kCAAhC,C;;;ACAA,qBAKOM,kBALP,C;;;ACMO,IAAM6N,0BAA0B,SAA1BA,uBAA0B,CAAC1F,OAAD,EAA4B;EACjE,OAAOA,QAAQkD,QAAR,CAAiBjC,UAAjB,CAA4BjB,QAAQrE,GAAR,CAAYoB,MAAxC,IACHiD,QAAQrE,GAAR,CAAYgK,QADT,GAEH,IAAI9I,GAAJ,CACEmD,QAAQrE,GAAR,CAAYgK,QADd,YAEK3F,QAAQrE,GAAR,CAAYiK,QAFjB,eAE8B5F,QAAQrE,GAAR,CAAYkK,IAF1C,GAGEjK,IALN;AAMF,CAPO,C;;;ADwBA,2BAA2BkK,IAA3B,EAAmE;EA9B1E;;EA+BE,IAAMC,eAAeD,KAAKE,WAAL,CAAiBvJ,IAAjB,CAAsB,UAACwJ,GAAD,EAAS;IAClD,OAAOA,IAAIC,IAAJ,KAAa,qBAApB;EACD,CAFoB,CAArB;EAIA,OAAO;IACLC,eAAeJ,6CAAcK,SADxB;IAELC,eAAe,mDAActO,IAAd,wBAAoBC;EAF9B,CAAP;AAIF;;AAEA,oBAAoBsO,KAApB,EAA+D;EAC7D,IAAI;IACF,IAAMC,MAAM,0BAAMD,KAAN,CAAZ;IACA,OAAOE,kBAAkBD,GAAlB,CAAP;EACF,CAHA,CAGA,OAAS3N,MAAT,EAAE;IACA,OAAOA,MAAP;EACF;AACF;;AAUA,mCACE6N,SADF,EAEEvF,GAFF,EAGEwF,KAHF,EAIE;EACA,IAAMC,aAAa;IAAEF;EAAF,CAAnB;;EACA,qCAA+BxN,OAAOC,OAAP,CAAegI,GAAf,CAA/B,wCAAoD;IAApD;IAAA,IAAY7H,GAAZ;IAAA,IAAiBuN,SAAjB;;IACE,IAAI,EAAEvN,OAAOqN,KAAT,CAAJ,EAAqB;MACnB,MAAM,IAAI9L,KAAJ,0CAA4CvB,GAA5C,SAAN;IACF;;IAHkD,4CAK5BuN,SAL4B;IAAA;;IAAA;MAKlD,uDAAiC;QAAA,IAAtBC,OAAsB;;QAC/B,4BAAqCA,QAAQrG,KAAR,CAAc,GAAd,EAAmBsG,OAAnB,EAArC;QAAA;QAAA,IAAOC,QAAP;QAAA,IAAoBC,aAApB;;QACA,IAAMC,QAAQD,cAAcF,OAAd,EAAd;QACA,IAAII,SAA8BP,UAAlC;;QAH+B,4CAKZM,KALY;QAAA;;QAAA;UAK/B,uDAA0B;YAAA,IAAfE,IAAe;;YACxB,IAAI,EAAEA,QAAQD,MAAV,CAAJ,EAAuB;cACrB,MAAM,IAAItM,KAAJ,qBAAuBqM,KAAvB,6BAAN;YACF;;YAEAC,SAASA,OAAOC,IAAP,CAAT;UACF;QAX+B;UAAA;QAAA;UAAA;QAAA;;QAa/BD,OAAOH,QAAP,IAAmBL,MAAMrN,GAAN,CAAnB;MACF;IAnBkD;MAAA;IAAA;MAAA;IAAA;EAoBpD;;EACA,OAAOsN,WAAWF,SAAlB;AACF;;AAEA,yBAAyBzG,OAAzB,EAA2E;EAxF3E;;EAyFE,QAAQA,QAAQzE,MAAhB;IAAgB,KACT,KADS;MACF;QACV,IAAM+K,QAAQtG,QAAQrE,GAAR,CAAYyL,YAAZ,CAAyB/G,GAAzB,CAA6B,OAA7B,CAAd;QACA,IAAMoG,YAAYzG,QAAQrE,GAAR,CAAYyL,YAAZ,CAAyB/G,GAAzB,CAA6B,WAA7B,KAA6C,EAA/D;QAEA,OAAO;UACLiG,YADK;UAELG,WAAWzM,UAAUyM,SAAV;QAFN,CAAP;MAIF;;IAAA,KAEK,MAFL;MAEa;QACX,IAAI,cAAQ9P,IAAR,wBAAc2P,KAAlB,EAAyB;UACvB,oBAA6BtG,QAAQrJ,IAArC;UAAA,IAAQ2P,MAAR,iBAAQA,KAAR;UAAA,IAAeG,UAAf,iBAAeA,SAAf;UAEA,OAAO;YACLH,aADK;YAELG;UAFK,CAAP;QAIF;;QAGA,IAAI,cAAQ9P,IAAR,wBAAcgQ,UAAlB,EAA8B;UAE1B,iBAAQhQ,IAAR;UAAA,IADMgQ,UACN,MADMA,UACN;UAAA,IADkBzF,GAClB,MADkBA,GAClB;UAAA,IAD0BwF,KAC1B,GAD0BW,UAC1BC,EAD0B,GAApB,YAAoB,EAAR,KAAQ,EAC1B;;UACF,IAAMC,mBACJvN,UACE2M,UADF,KAEK,EAHP;;UAKA,IAAI,CAACY,iBAAiBjB,KAAtB,EAA6B;YAC3B,OAAO,IAAP;UACF;;UAEA,IAAMkB,YAAYxN,UAAsCkH,OAAO,EAA7C,KAAoD,EAAtE;;UACA,IAAMuF,cAAYc,iBAAiBd,SAAjB,GACdgB,0BACEF,iBAAiBd,SADnB,EAEEe,SAFF,EAGEd,KAHF,CADc,GAMd,EANJ;;UAQA,OAAO;YACLJ,OAAOiB,iBAAiBjB,KADnB;YAELG;UAFK,CAAP;QAIF;MACF;;IAAA;MAGE,OAAO,IAAP;EAnDJ;AAqDF;;AAMO,6BACLzG,OADK,EAEiB;EACtB,IAAM1E,QAAQoM,gBAAgB1H,OAAhB,CAAd;;EAEA,IAAI,CAAC1E,KAAD,IAAU,CAACA,MAAMgL,KAArB,EAA4B;IAC1B,OAAO,MAAP;EACF;;EAEA,IAAQA,KAAR,GAA6BhL,KAA7B,CAAQgL,KAAR;EAAA,IAAeG,SAAf,GAA6BnL,KAA7B,CAAemL,SAAf;EACA,IAAMrB,eAAeuC,WAAWrB,KAAX,CAArB;;EAEA,IAAIlB,wBAAwBxK,KAA5B,EAAmC;IACjC,IAAMgN,mBAAmBlC,wBAAwB1F,OAAxB,CAAzB;IAEA,MAAM,IAAIpF,KAAJ,CACJ4C,SAASF,aAAT,CACE,0HADF,EAEE0C,QAAQzE,MAFV,EAGEqM,gBAHF,EAIExC,aAAanI,OAJf,CADI,CAAN;EAQF;;EAEA,OAAO;IACLkJ,eAAef,aAAae,aADvB;IAELE,eAAejB,aAAaiB,aAFvB;IAGLI;EAHK,CAAP;AAKF,C;;;AEzKO,4BAA4BoB,OAA5B,EAA6D;EAClE,IAAIA,UAAS,GAAb,EAAkB;IAChB,OAAO;IAAA;IAAP;EACF;;EAEA,IAAIA,UAAS,GAAb,EAAkB;IAChB,OAAO;IAAA;IAAP;EACF;;EAEA,OAAO;EAAA;EAAP;AACF,C;;;AChBO,wBAAgC;EACrC,IAAMC,MAAM,IAAIC,IAAJ,EAAZ;EAEA,OAAO,CAACD,IAAIE,QAAJ,EAAD,EAAiBF,IAAIG,UAAJ,EAAjB,EAAmCH,IAAII,UAAJ,EAAnC,EACJhH,GADI,CACAtJ,MADA,EAEJsJ,GAFI,CAEA,UAACR,KAAD;IAAA,OAAWA,MAAMG,KAAN,CAAY,CAAZ,EAAe,CAAf,CAAX;EAAA,CAFA,EAGJK,GAHI,CAGA,UAACR,KAAD;IAAA,OAAWA,MAAMyH,QAAN,CAAe,CAAf,EAAkB,GAAlB,CAAX;EAAA,CAHA,EAIJvH,IAJI,CAIC,GAJD,CAAP;AAKF,C;;;ACNO,wBAAwBZ,OAAxB,EAAgD;EACrD,OAAO7E,iCACF6E,OADE;IAELrJ,MAAMqJ,QAAQrJ,IAFT;IAGLsB,SAAS+H,QAAQ/H,OAAR,CAAgBmD,GAAhB;EAHJ,EAAP;AAKF,C;;;ACXA,+BAAgCvD,2BAAhC;;AAOO,yBAAyBH,GAAzB,EAAuD;EAC5D,IAAM0Q,kBAAkB,8CAAgB1Q,IAAIO,OAApB,CAAxB;EAEA,OAAOkD,iCACFzD,GADE;IAGLf,MAAM4M,UAAU7L,IAAIf,IAAd,EAAoByR,eAApB;EAHD,EAAP;AAKF,C;;;ACfA,4BAAsBvQ,yBAAtB;;AACA,yBAA4BA,oDAA5B,C;;;ACDA,IAAMwQ,2BAA2B,YAAjC;;AAEO,yBAAyBlB,IAAzB,EAAuC;EAC5C,OAAO,IAAItK,GAAJ,YAAYsK,IAAZ,GAAoB,kBAApB,EAAwCC,YAA/C;AACF;;AAKO,mBAAkBD,IAAlB,EAAwC;EAC7C,OAAOA,KAAK/F,OAAL,CAAaiH,wBAAb,EAAuC,EAAvC,CAAP;AACF,C;;;ACRO,uBAAuB1M,GAAvB,EAA6C;EAClD,OAAO,gCAAgCmJ,IAAhC,CAAqCnJ,GAArC,CAAP;AACF,C;;;ACAO,wBAAwBwL,IAAxB,EAAsCmB,OAAtC,EAAgE;EAErE,IAAIC,cAAcpB,IAAd,CAAJ,EAAyB;IACvB,OAAOA,IAAP;EACF;;EAGA,IAAIA,KAAKlG,UAAL,CAAgB,GAAhB,CAAJ,EAA0B;IACxB,OAAOkG,IAAP;EACF;;EAIA,IAAMpK,SACJuL,WAAY,OAAO7P,QAAP,KAAoB,WAApB,IAAmCA,SAAS+P,OAD1D;EAGA,OAAOzL,SAEH0L,UAAU,IAAI5L,GAAJ,CAAQ6L,UAAUvB,IAAV,CAAR,EAAyBpK,MAAzB,EAAiCnB,IAA3C,CAFG,GAGHuL,IAHJ;AAIF,C;;;ACdO,uBAAuBA,IAAvB,EAAmCmB,OAAnC,EAA2D;EAEhE,IAAInB,gBAAgB7F,MAApB,EAA4B;IAC1B,OAAO6F,IAAP;EACF;;EAEA,IAAMwB,mBAAmBC,eAAezB,IAAf,EAAqBmB,OAArB,CAAzB;EAEA,OAAO1S,UAAS+S,gBAAT,CAAP;AACF,C;;;AJFO,oBAAoBxB,IAApB,EAA0C;EAC/C,OACEA,KAMG/F,OANH,CAOI,2BAPJ,EAQI,UAACyH,CAAD,EAAIC,aAAJ,EAAuCC,QAAvC,EAA4D;IAC1D,IAAMC,aAAa,MAAnB;;IAEA,IAAI,CAACF,aAAL,EAAoB;MAClB,OAAOE,UAAP;IACF;;IAEA,OAAOF,cAAc7H,UAAd,CAAyB,GAAzB,cACA6H,aADA,SACgBC,QADhB,cAEAD,aAFA,SAEgBE,UAFhB,CAAP;EAIJ,CAnBF,EAwBG5H,OAxBH,CAwBW,mBAxBX,EAwBgC,QAxBhC,EA8BGA,OA9BH,CA8BW,sBA9BX,EA8BmC,QA9BnC,CADF;AAiCF;;AAKO,0BAAyBzF,GAAzB,EAAmCwL,IAAnC,EAA+CmB,OAA/C,EAAwE;EAC7E,IAAMW,iBAAiBC,cAAc/B,IAAd,EAAoBmB,OAApB,CAAvB;EACA,IAAMa,YACJ,OAAOF,cAAP,KAA0B,QAA1B,GACIG,WAAWH,cAAX,CADJ,GAEIA,cAHN;EAKA,IAAMI,YAAW,oCAAY1N,GAAZ,CAAjB;EACA,IAAMvC,SAAS,iCAAM+P,SAAN,EAAiB;IAAEG,QAAQC;EAAV,CAAjB,EAAiDF,SAAjD,CAAf;EACA,IAAMG,SAAUpQ,UAAWA,OAAOoQ,MAAlB,IAA4C,EAA5D;EAEA,OAAO;IACLC,SAASrQ,WAAW,KADf;IAELoQ;EAFK,CAAP;AAIF,C;;;AKxEA,+BAAwB3R,2BAAxB,C;;;ACAA,+BAAwBA,2BAAxB,C;;;AC6BO,oBAQc;EAAA,mCAHhB6R,GAGgB;IAHhBA,GAGgB;EAAA;;EACnB,OAAO,YAAa;IAClB,OAAOA,IAAIC,WAAJ,CAAgB,UAACC,MAAD,EAAcC,OAAd,EAA0B;MAC/C,OAAOD,kBAAkBtE,OAAlB,GACHA,QAAQC,OAAR,CAAgBqE,MAAhB,EAAwB9L,IAAxB,CAA6B+L,OAA7B,CADG,GAEHA,QAAQD,MAAR,CAFJ;IAGF,CAJO,mDAAP;EAKF,CANA;AAOF,C;;;ADLO,IAAM3T,mBAAmD;EAC9DmB,QAAQ,GADsD;EAE9DK,YAAY,IAFkD;EAG9Dd,MAAM,IAHwD;EAI9DG,OAAO,CAJuD;EAK9DuI,MAAM,KALwD;EAM9DqE,aAAa;AANiD,CAAzD;AAcA,IAAMoG,8BAA0D,EAAhE;;AAEA,oCACLC,iBADK,EAGa;EAAA,IADlBC,mBACkB,uEADqCF,2BACrC;EAClB,+EAAO;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;IAAA;;IAAA;MAAA;QAAA;UAAA;YACCG,eADD,GACmChR,OAAOU,MAAP,CACtC,EADsC,EAEtC1D,gBAFsC,EAGtC;cACEgC,SAAS,IAAIiS,gCAAJ,CAAY;gBACnB,gBAAgB;cADG,CAAZ;YADX,CAHsC,EAQtCH,iBARsC,CADnC;;YAAA,4BAAUI,YAAV;cAAUA,YAAV;YAAA;;YAYCC,oBAZD,GAYwB,6BACxBJ,mBADwB,GAExBG,YAFwB,EAG3B7N,MAH2B,CAGpBC,OAHoB,CAZxB;YAiBC8N,gBAjBD,GAkBHD,qBAAqBlM,MAArB,GAA8B,CAA9B,GACIrI,0CAAWuU,oBAAX,GAAiCH,eAAjC,CADJ,GAEIA,eApBD;YAAA,kCAsBEI,gBAtBF;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAAP;AAwBF;;AAEO,IAAM/T,YAAW2C,OAAOU,MAAP,CAAc5D,4BAAd,EAA2C;EACjEsJ,MAAMtJ,2BAA0B;IAAEsJ,MAAM;EAAR,CAA1B,CAD2D;EAEjEiL,YAFiE,wBAEpDrN,OAFoD,EAEnC;IAC5B,MAAM,IAAIsN,YAAJ,CAAiBtN,OAAjB,CAAN;EACF;AAJiE,CAA3C,CAAjB,C;;;AErFP,IAAMuN,eAAe,kBAArB;AAEA,IAAMC,cACJ,mEADF;;AAMO,sBAAsB7R,MAAtB,EAAoC;EAEzC,IAAM8R,QAAQ9R,OAAM8R,KAApB;;EAEA,IAAI,CAACA,KAAL,EAAY;IACV;EACF;;EAEA,IAAMC,SAAmBD,MAAMlK,KAAN,CAAY,IAAZ,EAAkBK,KAAlB,CAAwB,CAAxB,CAAzB;EAIA,IAAM+J,mBAAmBD,OAAOlO,IAAP,CAAY,UAACoO,KAAD,EAAW;IAC9C,OAAO,EAAEL,aAAa1F,IAAb,CAAkB+F,KAAlB,KAA4BJ,YAAY3F,IAAZ,CAAiB+F,KAAjB,CAA9B,CAAP;EACD,CAFwB,CAAzB;;EAIA,IAAI,CAACD,gBAAL,EAAuB;IACrB;EACF;;EAGA,IAAME,kBAAkBF,iBACrBxJ,OADqB,CACb,yBADa,EACc,IADd,EAErBA,OAFqB,CAEb,IAFa,EAEP,EAFO,CAAxB;EAGA,OAAO0J,eAAP;AACF,C;;;AC/BO,oBACLC,EADK,EAEsD;EAC3D,IAAI,CAACA,EAAL,EAAS;IACP,OAAO,KAAP;EACF;;EAEA,OAAO,OAAQA,GAA0BC,OAAOC,QAAjC,CAAR,IAAsD,UAA7D;AACF,C;;;AJaO,IAAMjV,kBAAiC;EAC5CoB,eAD4C;EAE5CD,SAF4C;EAG5CL,aAH4C;EAI5CG;AAJ4C,CAAvC;;AAuEA;EAAA;;EAmBL,yBAAYqB,OAAZ,EAAyD;IAAA;;IACvD,KAAK6M,UAAL,GAAkB,KAAlB;IACA,KAAK+F,GAAL,GAAW5S,QAAQ4S,GAAR,IAAelV,eAA1B;IACA,KAAKmV,QAAL,GAAgB7S,QAAQ6S,QAAxB;IAEA,IAAMC,YAAYC,aAAa,IAAIzQ,KAAJ,EAAb,CAAlB;IAEA,KAAK0Q,IAAL,GAAYnQ,iCACP7C,QAAQgT,IADD;MAEVF;IAFU,EAAZ;EAIF;;EA9BK;IAAA;IAAA,OAuDL,eACEG,QADF,EAEEC,kBAFF,EAGgB;MACd,OAAO,IAAP;IACF;EA5DK;IAAA;IAAA,OAiEE,cACLxL,OADK,EAEL2E,iBAFK,EAGI;MACT,OAAO,KAAK8G,SAAL,CACLzL,OADK,EAEL,KAAKrH,KAAL,CAAWqH,OAAX,EAAoB2E,iBAApB,CAFK,EAGLA,iBAHK,CAAP;IAKF;EA1EK;IAAA;IAAA,OAgFK,0BACR3E,OADQ,EAER0L,aAFQ,EAGR;MACA,OAAO1L,OAAP;IACF;EArFK;IAAA;IAAA,OAuFE,yBAAiC;MAAA,IAAnBmF,UAAmB,uEAAN,IAAM;MACtC,KAAKA,UAAL,GAAkBA,UAAlB;IACF;EAzFK;IAAA;IAAA;MAAA,sEAyFL,kBAOEnF,OAPF,EAQE2E,iBARF;QAAA;QAAA;UAAA;YAAA;cAAA;gBAAA,KAUM,KAAKQ,UAVX;kBAAA;kBAAA;gBAAA;;gBAAA,kCAWW,IAXX;;cAAA;gBAcQC,YAdR,GAcuB,KAAKzM,KAAL,CAAWqH,OAAX,EAAoB2E,iBAApB,CAdvB;gBAeQgH,eAfR,GAe0B,KAAKF,SAAL,CACtBzL,OADsB,EAEtBoF,YAFsB,EAGtBT,iBAHsB,CAf1B;;gBAAA,IAqBOgH,eArBP;kBAAA;kBAAA;gBAAA;;gBAAA,kCAsBW,IAtBX;;cAAA;gBAyBQnG,aAzBR,GAyBwB,KAAKoG,gBAAL,CAAsB5L,OAAtB,EAA+BoF,YAA/B,CAzBxB;gBA6BQyG,eA7BR,GA6B0B,KAAKC,YAAL,CAAkB,KAAKX,QAAvB,CA7B1B;gBAAA;gBAAA,OA8B+BU,gBAC3BrG,aAD2B,EAE3BlP,SAF2B,EAG3B,KAAK4U,GAHsB,CA9B/B;;cAAA;gBA8BQa,cA9BR;gBAAA,kCAoCS,KAAKC,qBAAL,CACL5G,YADK,EAELI,aAFK,EAGLuG,cAHK,CApCT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAzFK;;MAAA;QAAA;MAAA;;MAAA;IAAA;EAAA;IAAA;IAAA,OAoIG,sBACNZ,QADM,EAEuD;MAAA;;MAC7D;QAAA,wEAAO,kBAAOc,GAAP,EAAYvU,GAAZ,EAAiBwT,GAAjB;UAAA;;UAAA;YAAA;cAAA;gBAAA;kBAAA,eACU,OAAKgB,iBADf;;kBAAA;oBAAA;oBAAA;kBAAA;;kBAAA;kBAAA,OAC2Cf,SAASc,GAAT,EAAcvU,GAAd,EAAmBwT,GAAnB,CAD3C;;gBAAA;kBAAA;;gBAAA;kBACC9R,MADD;;kBAAA,KAGD+S,WAAiD/S,MAAjD,CAHC;oBAAA;oBAAA;kBAAA;;kBAAA,wBAIqBA,OAAO4R,OAAOC,QAAd,IAA0BmB,IAA1B,EAJrB,EAIKpU,KAJL,yBAIKA,KAJL,EAIYqU,IAJZ,yBAIYA,IAJZ;kBAAA;kBAAA,OAKwBrU,KALxB;;gBAAA;kBAKGsU,YALH;;kBAAA,MASC,CAACA,YAAD,IAAiBD,IATlB;oBAAA;oBAAA;kBAAA;;kBAAA,kCAUM,OAAKE,uBAVX;;gBAAA;kBAaH,IAAI,CAAC,OAAKL,iBAAV,EAA6B;oBAC3B,OAAKA,iBAAL,GAAyB9S,MAAzB;kBACF;;kBAEA,OAAKmT,uBAAL,GAA+BD,YAA/B;kBAjBG,kCAkBIA,YAlBJ;;gBAAA;kBAAA,kCAqBElT,MArBF;;gBAAA;gBAAA;kBAAA;cAAA;YAAA;UAAA;QAAA,CAAP;;QAAA;UAAA;QAAA;MAAA;IAuBF;EA9JK;IAAA;IAAA,OAgKG,+BACNgM,YADM,EAENpF,OAFM,EAGNwM,SAHM,EAIwC;MAC9C,OAAO;QACL3H,SAAS,IADJ;QAELO,cAAcA,gBAAgB,IAFzB;QAGLpF,gBAHK;QAIL1J,UAAUkW,aAAY;MAJjB,CAAP;IAMF;EA3KK;;EAAA;AAAA,I;;;AK7DA,IAAK/W,eAAL,yBAAKgX,YAAL;EACLA,uBAAO,MAAP;EACAA,sBAAM,KAAN;EACAA,uBAAO,MAAP;EACAA,sBAAM,KAAN;EACAA,wBAAQ,OAAR;EACAA,0BAAU,SAAV;EACAA,yBAAS,QAAT;EAPU;AAAA,CAAL,CAAKhX,kBAAL;;AAoBA,IAAMe,eAA2B2E,iCACnCnF,eADmC;EAEtCY,eAFsC;EAGtCD,WAHsC;EAItCU,WAJsC;EAKtCH,WALsC;EAMtCI;AANsC,EAAjC;;AAeA;EAAA;;EAAA;;EAAA;;EAIL,qBACE0I,OADF,EAEkBwJ,MAFlB,EAGE;IAAA;;IAAA;;IACA,4BAAMxJ,QAAQrE,GAAd,EAAmBR,iCACd6E,OADc;MAQjBrJ,MAAMqJ,QAAQ,OAAR;IARW,EAAnB;IAFgB;IAYhB,OAAK0C,EAAL,GAAU1C,QAAQ0C,EAAlB;IAXA;EAYF;;EAnBK;AAAA,EAGGlN,cAHH;;AA0BA;EAAA;;EAAA;;EAAA;;EAaL,sBACE+F,MADF,EAEE4L,IAFF,EAGEgE,QAHF,EAIE;IAAA;;IAAA;;IACA,4BAAM;MACJG,MAAM;QACJoB,kBAAWnR,MAAX,cAAqB4L,IAArB,CADI;QAEJA,UAFI;QAGJ5L;MAHI,CADF;MAMJ2P,KAAK1U,YAND;MAOJ2U;IAPI,CAAN;;IAUA,OAAKwB,6BAAL;;IAXA;EAYF;;EA7BK;IAAA;IAAA,OA+BG,yCAAgC;MACtC,iBAAyB,KAAKrB,IAA9B;MAAA,IAAQ/P,MAAR,cAAQA,MAAR;MAAA,IAAgB4L,IAAhB,cAAgBA,IAAhB;;MAEA,IAAIA,gBAAgB7F,MAApB,EAA4B;QAC1B;MACF;;MAEA,IAAM3F,MAAM/F,UAASuR,IAAT,CAAZ;;MAGA,IAAIxL,QAAQwL,IAAZ,EAAkB;QAChB;MACF;;MAEA,IAAMC,eAAewF,gBAAgBzF,IAAhB,CAArB;MACA,IAAM0F,cAAwB,EAA9B;MAEAzF,aAAajP,OAAb,CAAqB,UAAC0Q,CAAD,EAAIiE,SAAJ,EAAkB;QACrCD,YAAYE,IAAZ,CAAiBD,SAAjB;MACD,CAFD;MAIAtP,SAASH,IAAT,wFACiF9B,MADjF,cAC2F4L,IAD3F;IAGF;EAvDK;IAAA;IAAA,OAyDL,eAAMnH,OAAN,EAA4B2E,iBAA5B,EAA2E;MACzE,OAAOtO,iBACL2J,QAAQrE,GADH,EAEL,KAAK2P,IAAL,CAAUnE,IAFL,EAGLxC,uDAAmB2D,OAHd,CAAP;IAKF;EA/DK;IAAA;IAAA,OAiEK,0BACRtI,OADQ,EAERoF,YAFQ,EAGsB;MAC9B,OAAO,IAAI4H,WAAJ,CAAgBhN,OAAhB,EAAyBoF,aAAaoE,MAAb,IAAuB,EAAhD,CAAP;IACF;EAtEK;IAAA;IAAA,OAwEL,mBAAUxJ,OAAV,EAAgCoF,YAAhC,EAAiE;MAC/D,IAAM6H,gBACJ,KAAK3B,IAAL,CAAU/P,MAAV,YAA4B+F,MAA5B,GACI,KAAKgK,IAAL,CAAU/P,MAAV,CAAiBuJ,IAAjB,CAAsB9E,QAAQzE,MAA9B,CADJ,GAEIiI,cAAc,KAAK8H,IAAL,CAAU/P,MAAxB,EAAgCyE,QAAQzE,MAAxC,CAHN;MAKA,OAAO0R,iBAAiB7H,aAAaqE,OAArC;IACF;EA/EK;IAAA;IAAA,OAiFL,aAAIzJ,OAAJ,EAA0BwM,SAA1B,EAAwD;MACtD,IAAMU,YAAYxH,wBAAwB1F,OAAxB,CAAlB;MACA,IAAMmN,gBAAgBC,eAAepN,OAAf,CAAtB;MACA,IAAMqN,iBAAiBC,gBAAgBd,SAAhB,CAAvB;MACA,IAAMe,cAAcC,mBAAmBhB,UAASpV,MAA5B,CAApB;MAEAgG,QAAQwB,cAAR,CACEpB,SAASF,aAAT,CAAuB,mBAAvB,CADF,EAEEmQ,cAFF,EAGEzN,QAAQzE,MAHV,EAIE2R,SAJF,kBAKWK,WALX,aAMKf,UAASpV,MANd,cAMwBoV,UAAS/U,UANjC,GAOE,eAPF;MASA2F,QAAQyB,GAAR,CAAY,SAAZ,EAAuBsO,aAAvB;MACA/P,QAAQyB,GAAR,CAAY,UAAZ,EAAwB;QACtB6O,MAAM,KAAKpC,IAAL,CAAUnE,IADM;QAEtBgE,UAAU,KAAKA;MAFO,CAAxB;MAIA/N,QAAQyB,GAAR,CAAY,UAAZ,EAAwBwO,cAAxB;MACAjQ,QAAQ4B,QAAR;IACF;EAvGK;;EAAA;AAAA,EAEGtJ,eAFH,E;;;AC/FP,yBAA0BmC,qBAA1B;;AAcO,IAAM8V,QAAQ,SAARA,KAAQ,CACnBC,SADmB,EAEnBC,UAFmB,EAGa;EAChC,OAAO,UAACnW,GAAD,EAAS;IACdoW,kBAAkBF,SAAlB;IAEA,IAAM7T,WAAWC,UAAUtC,IAAIf,IAAd,KAAuB,EAAxC;IACA,IAAMsD,WAAWP,WAAWK,QAAX,sBAAwB6T,SAAxB,EAAoCC,UAApC,EAAjB;IAEA,OAAO3W,MAAK+C,QAAL,EAAevC,GAAf,CAAP;EACF,CAPA;AAQF,CAZO;;AAcP,2BAA2BkW,SAA3B,EAA8C;EAC5C,kCACEA,UAAUjN,IAAV,OAAqB,EADvB,EAEEnD,SAASF,aAAT,CACE,iFADF,CAFF;EAOA,kCACEsQ,cAAc,MADhB,EAEEpQ,SAASF,aAAT,CACE,kIADF,EAEEsQ,SAFF,CAFF;EAQA,kCACEA,cAAc,QADhB,EAEEpQ,SAASF,aAAT,CACE,oIADF,EAEEsQ,SAFF,CAFF;EAQA,kCACEA,cAAc,YADhB,EAEEpQ,SAASF,aAAT,CACE,wIADF,EAEEsQ,SAFF,CAFF;AAOF,C;;;AC3DO,kBACL7C,EADK,EAELgD,WAFK,EAGuB;EAC5B,IAAI;IACF,IAAM3U,SAAS2R,IAAf;IACA,OAAO3R,MAAP;EACF,CAHA,CAGA,OAASR,MAAT,EAAE;IACAmV,2CAAcnV,MAAd;EACF;AACF,C;;;ACoCO,IAAMzC,kBAAsCgF,iCAC9CnF,eAD8C;EAEjDa,WAFiD;EAGjDG,uBAHiD;EAIjDD,eAJiD;EAKjDH,eALiD;EAMjD+W;AANiD,EAA5C;;AA2BA,wBACL3V,KADK,EAEkB;EACvB,IAAIA,SAAS,IAAb,EAAmB;IACjB,OAAO,KAAP;EACF;;EAEA,OAAO,OAAOA,KAAP,KAAiB,QAAjB,IAA6B,UAAUA,KAAvC,IAAgD,iBAAiBA,KAAxE;AACF;;AAEO;EAAA;;EAAA;;EAAA;;EAGL,wBAAYgI,OAAZ,EAAoDyG,SAApD,EAA0E;IAAA;;IAAA;;IACxE,4BAAMzG,QAAQrE,GAAd,EAAmBR,iCACd6E,OADc;MAKjBrJ,MAAMqJ,QAAQ,OAAR;IALW,EAAnB;IADkD;IAAsB;EAQ1E;;EAXK;AAAA,EAEGxK,cAFH;;AAcA;EAAA;;EAAA;;EAAA;;EAUL,yBACE2Q,aADF,EAEEE,aAFF,EAGE2H,QAHF,EAIE7C,QAJF,EAKE;IAAA;;IAAA;;IACA,IAAI8C,wBAAwB5H,aAA5B;;IAEA,IAAI6H,eAAe7H,aAAf,CAAJ,EAAmC;MACjC,IAAM8H,aAAa3H,kBAAkBH,aAAlB,CAAnB;;MAEA,IAAI8H,WAAWhI,aAAX,KAA6BA,aAAjC,EAAgD;QAC9C,MAAM,IAAIvL,KAAJ,oHACuGuL,aADvG,2BACmIgI,WAAWhI,aAD9I,UAAN;MAGF;;MAEA,IAAI,CAACgI,WAAW9H,aAAhB,EAA+B;QAC7B,MAAM,IAAIzL,KAAJ,uFAAN;MAGF;;MAEAqT,wBAAwBE,WAAW9H,aAAnC;IACF;;IAEA,IAAMqG,SACJvG,kBAAkB,KAAlB,aACOA,aADP,uBACiC6H,SAAS3L,QAAT,EADjC,mBAEO8D,aAFP,cAEwB8H,qBAFxB,uBAE0DD,SAAS3L,QAAT,EAF1D,MADF;IAKA,4BAAM;MACJiJ,MAAM;QACJoB,cADI;QAEJvG,4BAFI;QAGJE,eAAe4H;MAHX,CADF;MAMJ/C,KAAK/U,eAND;MAOJgV;IAPI,CAAN;IAUA,OAAK6C,QAAL,GAAgBA,QAAhB;IApCA;EAqCF;;EApDK;IAAA;IAAA,OAsDL,eAAMhO,OAAN,EAA8B;MAC5B,OAAOoO,SACL;QAAA,OAAMC,oBAAoBrO,OAApB,CAAN;MAAA,CADK,EAEL,UAACpH,MAAD;QAAA,OAAWwE,QAAQG,KAAR,CAAc3E,OAAMqE,OAApB,CAAX;MAAA,CAFK,CAAP;IAIF;EA3DK;IAAA;IAAA,OA6DK,0BACR+C,OADQ,EAERoF,YAFQ,EAGa;MACrB,OAAO,IAAIkJ,cAAJ,CAAmBtO,OAAnB,EAA4B,8CAAcyG,SAAd,KAA2B,EAAvD,CAAP;IACF;EAlEK;IAAA;IAAA,OAoEL,mBAAUzG,OAAV,EAAkCoF,YAAlC,EAAsE;MACpE,IAAI,CAACA,YAAL,EAAmB;QACjB,OAAO,KAAP;MACF;;MAEA,IAAI,CAACA,aAAaiB,aAAd,IAA+B,KAAKiF,IAAL,CAAUnF,aAAV,KAA4B,KAA/D,EAAsE;QACpE,IAAM+G,YAAYxH,wBAAwB1F,OAAxB,CAAlB;QACAxC,SAASH,IAAT,sDACsC2C,QAAQzE,MAD9C,cACwD2R,SADxD;QAKA,OAAO,KAAP;MACF;;MAEA,IAAMqB,iBAAiBlY,iBAAgB2J,QAAQrE,GAAxB,EAA6B,KAAKqS,QAAlC,CAAvB;;MACA,IAAMQ,2BACJ,KAAKlD,IAAL,CAAUnF,aAAV,KAA4B,KAA5B,IACAf,aAAae,aAAb,KAA+B,KAAKmF,IAAL,CAAUnF,aAF3C;MAIA,IAAMsI,2BACJ,KAAKnD,IAAL,CAAUjF,aAAV,YAAmC/E,MAAnC,GACI,KAAKgK,IAAL,CAAUjF,aAAV,CAAwBvB,IAAxB,CAA6BM,aAAaiB,aAAb,IAA8B,EAA3D,CADJ,GAEIjB,aAAaiB,aAAb,KAA+B,KAAKiF,IAAL,CAAUjF,aAH/C;MAKA,OACEkI,eAAe9E,OAAf,IACA+E,wBADA,IAEAC,wBAHF;IAKF;EAlGK;IAAA;IAAA,OAoGL,aACEzO,OADF,EAEEwM,SAFF,EAGE3H,OAHF,EAIEY,aAJF,EAKE;MACA,IAAM0H,gBAAgBC,eAAepN,OAAf,CAAtB;MACA,IAAMqN,iBAAiBC,gBAAgBd,SAAhB,CAAvB;MACA,IAAMe,cAAcC,mBAAmBhB,UAASpV,MAA5B,CAApB;MACA,IAAMsX,cAAc,gDAAerI,aAAf,cACbZ,+CAAeU,aADF,cACmBV,+CAAeY,aADlC,wBAEHZ,+CAAeU,aAFZ,CAApB;MAIA/I,QAAQwB,cAAR,CACEpB,SAASF,aAAT,CAAuB,gBAAvB,CADF,EAEEmQ,cAFF,YAGKiB,WAHL,mBAIWnB,WAJX,aAKKf,UAASpV,MALd,cAKwBoV,UAAS/U,UALjC,GAME,eANF;MAQA2F,QAAQyB,GAAR,CAAY,UAAZ,EAAwBsO,aAAxB;MACA/P,QAAQyB,GAAR,CAAY,UAAZ,EAAwB,IAAxB;MACAzB,QAAQyB,GAAR,CAAY,WAAZ,EAAyBwO,cAAzB;MACAjQ,QAAQ4B,QAAR;IACF;EA7HK;;EAAA;AAAA,EAEGtJ,eAFH,E;;;ApBnFP,IAAMiZ,kBAAkB,CAAxB;AACA,IAAMC,uBAAuB,CAA7B;AACA,IAAMC,mBAAmB,GAAzB;;AAuBA,6BAA6BnK,QAA7B,EAA+E;EAC7E,OAAOA,SAASvL,MAAT,CACL,UAAC2V,MAAD,EAASjK,OAAT,EAAqB;IACnB,IAAIA,mBAAmBlP,YAAvB,EAAoC;MAClCmZ,OAAOvY,IAAP,CAAYwW,IAAZ,CAAiBlI,OAAjB;IACF;;IAEA,IAAIA,mBAAmBtP,eAAvB,EAAuC;MACrCuZ,OAAO5Y,OAAP,CAAe6W,IAAf,CAAoBlI,OAApB;IACF;;IAEA,OAAOiK,MAAP;EACF,CAXK,EAYL;IACEvY,MAAM,EADR;IAEEL,SAAS;EAFX,CAZK,CAAP;AAiBF;;AASA,+BAA2D;EACzD,OAAO,UAAC8J,OAAD,EAAU6E,OAAV,EAAsB;IAC3B,oBAAyBA,QAAQyG,IAAjC;IAAA,IAAQnE,IAAR,iBAAQA,IAAR;IAAA,IAAc5L,MAAd,iBAAcA,MAAd;;IAEA,IAAI4L,gBAAgB7F,MAAhB,IAA0B/F,kBAAkB+F,MAAhD,EAAwD;MACtD,OAAOyN,QAAP;IACF;;IAEA,IAAMC,gBAAgBxL,cAAcxD,QAAQzE,MAAtB,EAA8BA,MAA9B,CAAtB;IAGA,IAAM0T,mBAAmBD,gBAAgBH,gBAAhB,GAAmC,CAA5D;IACA,IAAMjH,mBAAmBlC,wBAAwB1F,OAAxB,CAAzB;IACA,IAAMkP,QAAQ,mCAAoBtH,gBAApB,EAAsCT,IAAtC,CAAd;IAEA,OAAO+H,QAAQD,gBAAf;EACF,CAfA;AAgBF;;AAEA,gCACEE,WADF,EAEiC;EAC/B,OAAO,UAACtG,CAAD,EAAIhE,OAAJ,EAAgB;IACrB,IAAI,OAAOsK,YAAY9I,aAAnB,KAAqC,WAAzC,EAAsD;MACpD,OAAO0I,QAAP;IACF;;IAEA,qBAAyClK,QAAQyG,IAAjD;IAAA,IAAQnF,aAAR,kBAAQA,aAAR;IAAA,IAAuBE,aAAvB,kBAAuBA,aAAvB;;IAEA,IAAI,OAAOA,aAAP,KAAyB,QAA7B,EAAuC;MACrC,OAAO0I,QAAP;IACF;;IAEA,IAAMK,uBAAuBD,YAAYhJ,aAAZ,KAA8BA,aAA3D;IAEA,IAAMkJ,0BAA0BD,uBAAuBP,gBAAvB,GAA0C,CAA1E;IACA,IAAMK,QAAQ,mCAAoBC,YAAY9I,aAAhC,EAA+CA,aAA/C,CAAd;IAEA,OAAO6I,QAAQG,uBAAf;EACF,CAjBA;AAkBF;;AAEA,6BACErP,OADF,EAEE0E,QAFF,EAGE4K,QAHF,EAIoB;EAClB,IAAMC,oBAAqB7K,SACxBvL,MADwB,CACW,UAACqW,WAAD,EAAc3K,OAAd,EAA0B;IAC5D,IAAMqK,QAAQI,SAAStP,OAAT,EAAkB6E,OAAlB,CAAd;IACA,OAAO2K,YAAYhW,MAAZ,CAAmB,CAAC,CAAC0V,KAAD,EAAQrK,OAAR,CAAD,CAAnB,CAAP;EACF,CAJyB,EAItB,EAJsB,EAKxB4K,IALwB,CAKnB;IAAA;IAAA,IAAEC,SAAF;;IAAA;IAAA,IAAeC,UAAf;;IAAA,OAA+BD,YAAYC,UAA3C;EAAA,CALmB,EAMxBrT,MANwB,CAMjB;IAAA;IAAA,IAAE4S,KAAF;;IAAA,OAAaA,SAASP,eAAtB;EAAA,CANiB,EAOxB9N,KAPwB,CAOlB,CAPkB,EAOf+N,oBAPe,EAQxB1N,GARwB,CAQpB;IAAA;IAAA,IAAI2D,OAAJ;;IAAA,OAAiBA,OAAjB;EAAA,CARoB,CAA3B;EAUA,OAAO0K,iBAAP;AACF;;AAEA,qCAAqC7K,QAArC,EAAiE;EAC/D,IAAIA,SAASxG,MAAT,GAAkB,CAAtB,EAAyB;IACvB,oFAGFwG,SAASxD,GAAT,CAAa,UAAC2D,OAAD;MAAA,0BAAoBA,QAAQyG,IAAR,CAAaoB,MAAjC;IAAA,CAAb,EAAwD9L,IAAxD,CAA6D,IAA7D,CAHE;EAIF;;EAEA,2CAAmC8D,SAAS,CAAT,EAAY4G,IAAZ,CAAiBoB,MAApD;AACF;;AAEO,4BACL1M,OADK,EAEL0E,QAFK,EAIC;EAAA,IADNkL,QACM,uEAD+B,MAC/B;EACN,IAAMC,qBAAqBzB,SAAS;IAAA,OAAMC,oBAAoBrO,OAApB,CAAN;EAAA,CAAT,CAA3B;;EAEA,qCAA6C;IAM3C,IAAM8P,gBAAgBC,oBAAoBrL,QAApB,CAAtB;IACA,IAAME,mBAAmBiL,qBACrBC,cAAc5Z,OADO,GAErB4Z,cAAcvZ,IAFlB;IAIA,IAAMgZ,oBAAoBS,oBACxBhQ,OADwB,EAExB4E,gBAFwB,EAGxBiL,qBACII,uBAAuBJ,kBAAvB,CADJ,GAEIK,qBALoB,CAA1B;IAQA,OAAOX,kBAAkBrR,MAAlB,GAA2B,CAA3B,GACHiS,4BAA4BZ,iBAA5B,CADG,GAEH,EAFJ;EAGF;;EAEA,2CAAmD;IACjD,IAAMrC,YAAYxH,wBAAwB1F,OAAxB,CAAlB;IACA,IAAMoQ,gBAAgBP,+BACfA,mBAAmB1J,aADJ,cACqB0J,mBAAmBxJ,aADxC,eAC0DrG,QAAQzE,MADlE,cAC4E2R,SAD5E,mBAEflN,QAAQzE,MAFO,cAEG2R,SAFH,CAAtB;IAGA,IAAMmD,oBAAoBC,2BAA1B;IAEA,IAAMC,kBAAkB,8EAEVH,aAFU,GAGtBC,iBAHsB,4JAQtB/T,MARsB,CAQfC,OARe,CAAxB;IASA,OAAOgU,gBAAgB3P,IAAhB,CAAqB,MAArB,CAAP;EACF;;EAEA,uBAAuB4P,SAAvB,EAA2D;IAIzD,IAAMvT,UAAUwT,iCAAhB;;IAEA,QAAQD,SAAR;MAAQ,KACD,OADC;QACQ;UAEZhT,SAASD,KAAT,CAAe,WAAf,EAA4BN,OAA5B;UAGA,MAAM,IAAIrC,KAAJ,CACJ4C,SAASF,aAAT,CACE,8FADF,CADI,CAAN;QAKF;;MAAA,KAEK,MAFL;QAEa;UACXE,SAASH,IAAT,CAAc,aAAd,EAA6BJ,OAA7B;UACA;QACF;;MAAA,KAEK,QAFL;QAGE;;MAAA;QAGA,MAAM,IAAIrC,KAAJ,CACJ4C,SAASF,aAAT,CACE,2NADF,EAEEkT,SAFF,CADI,CAAN;IAtBJ;EA6BF;;EAEA,IAAI,OAAOZ,QAAP,KAAoB,UAAxB,EAAoC;IAClCA,SAAS5P,OAAT,EAAkB;MAChB0Q,SAASC,cAAcC,IAAd,CAAmB,IAAnB,EAAyB,MAAzB,CADO;MAEhBrT,OAAOoT,cAAcC,IAAd,CAAmB,IAAnB,EAAyB,OAAzB;IAFS,CAAlB;IAIA;EACF;;EAEAD,cAAcf,QAAd;AACF,C;;;AqBzOA,sBAAsB/X,yBAAtB;;AAIO,6BACLmI,OADK,EAELwM,SAFK,EAGL;EACAqE,sBAAMC,GAAN,CAAU3V,iCAAK6E,OAAL;IAAcrE,KAAKqE,QAAQrE,GAAR,CAAY0G,QAAZ;EAAnB,EAAV,EAAuDmK,SAAvD;EACAqE,sBAAME,OAAN;AACF,C;;;SvBwCA3a,c;;;;;;+EAAA,mBAGE4J,OAHF,EAIE0E,QAJF,EAKEpM,OALF,EAME0Y,OANF,EAOEC,oBAPF;IAAA;;IAAA;MAAA;QAAA;UAAA;YASED,QAAQE,IAAR,CAAa,eAAb,EAA8BlR,OAA9B;;YATF,MAYMA,QAAQ/H,OAAR,CAAgBoI,GAAhB,CAAoB,cAApB,MAAwC,MAZ9C;cAAA;cAAA;YAAA;;YAaI2Q,QAAQE,IAAR,CAAa,aAAb,EAA4BlR,OAA5B;YACA,mEAAsBmR,qBAAtB,mDAA8CnR,OAA9C;YAdJ;;UAAA;YAAA;YAAA,OAmB4C,yBAAM,YAAM;cACpD,OAAOyE,YACLzE,OADK,EAEL0E,QAFK,EAGLuM,6DAAsBtM,iBAHjB,CAAP;YAKD,CANyC,CAnB5C;;UAAA;YAAA;YAAA;YAmBSyM,WAnBT;YAmBsBC,YAnBtB;;YAAA,KA2BMD,WA3BN;cAAA;cAAA;YAAA;;YA6BIJ,QAAQE,IAAR,CAAa,oBAAb,EAAmCE,WAAnC,EAAgDpR,OAAhD;YA7BJ,MA8BUoR,WA9BV;;UAAA;YAiCUvM,OAjCV,GAiCgCwM,YAjChC,CAiCUxM,OAjCV,EAiCmB2H,SAjCnB,GAiCgC6E,YAjChC,CAiCmB/a,QAjCnB;;YAAA,IAqCOuO,OArCP;cAAA;cAAA;YAAA;;YAsCIyM,mBAAmBtR,OAAnB,EAA4B0E,QAA5B,EAAsCpM,QAAQgZ,kBAA9C;YACAN,QAAQE,IAAR,CAAa,mBAAb,EAAkClR,OAAlC;YACAgR,QAAQE,IAAR,CAAa,aAAb,EAA4BlR,OAA5B;YACA,mEAAsBmR,qBAAtB,mDAA8CnR,OAA9C;YAzCJ;;UAAA;YAAA,IA+COwM,SA/CP;cAAA;cAAA;YAAA;;YAgDIhP,SAASH,IAAT,yJAOEmP,SAPF,EAQE3H,QAAQyG,IAAR,CAAaoB,MARf,EASE7H,QAAQyG,IAAR,CAAaF,SATf;YAYA4F,QAAQE,IAAR,CAAa,aAAb,EAA4BlR,OAA5B;YACA,mEAAsBmR,qBAAtB,mDAA8CnR,OAA9C;YA7DJ;;UAAA;YAAA,KAmEMwM,UAAS9I,WAnEf;cAAA;cAAA;YAAA;;YAoEIsN,QAAQE,IAAR,CAAa,aAAb,EAA4BlR,OAA5B;YACA,mEAAsBmR,qBAAtB,mDAA8CnR,OAA9C;YArEJ;;UAAA;YA0EEuR,oBAAoBvR,OAApB,EAA6BwM,SAA7B;YAEAwE,QAAQE,IAAR,CAAa,eAAb,EAA8BlR,OAA9B;YAEMwR,oBA9ER,GA+EIH,YA/EJ;YAiFQI,mBAjFR,GAkFI,oEAAsBC,iBAAtB,mDAA0ClF,SAA1C,MACCA,SAnFL;YAqFE,mEAAsBmF,gBAAtB,mDACEF,mBADF,EAEED,oBAFF;YAKA,mEAAsBI,oBAAtB,mDACEH,mBADF,EAEED,oBAFF;YAIAR,QAAQE,IAAR,CAAa,aAAb,EAA4BlR,OAA5B;YA9FF,mCAgGSyR,mBAhGT;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,C;;;;AwBhCO,IAAMI,wBAAwB,SAAxBA,qBAAwB,CACnC/b,OADmC,EAEnCwC,OAFmC,EAGhC;EACH;IAAA,wEAAO,kBACLmH,KADK,EAELxC,OAFK;MAAA;MAAA;QAAA;UAAA;YAAA;cAOC6U,cAPD,GAOkB,IAAIC,aAAJ,CAAkBtS,MAAMuS,KAAN,CAAY,CAAZ,CAAlB,CAPlB;cAQChS,OARD,GAQWiS,mBAAmBhV,QAAQnD,OAA3B,CARX;cAAA;cAAA;cAAA,OAWG1D,eACJ4J,OADI,EAEJlK,QAAQoc,eAFJ,EAGJ5Z,OAHI,EAIJxC,QAAQkb,OAJJ,EAKJ;gBACEU,oCADF;gBAEEP,qBAFF,mCAE0B;kBACtBW,eAAejS,WAAf,CAA2B,WAA3B;gBACF,CAJF;gBAKQ8R,gBALR,4BAKyBnF,SALzB,EAKmC;kBAAA;oBAAA;oBAAA;sBAAA;wBAAA;0BAAA;4BAAA,MAC3BA,UAAS7V,IAAT,YAAyBwb,cADE;8BAAA;8BAAA;4BAAA;;4BAAA,MAEvB,IAAIvX,KAAJ,CACJ4C,SAASF,aAAT,CACE,yKADF,CADI,CAFuB;;0BAAA;4BASzB8U,gBATyB,GASN,IAAIC,QAAJ,CAAa7F,UAAS7V,IAAtB,EAA4B6V,SAA5B,CATM;4BAAA;4BAAA,OAUE4F,iBAAiBE,WAAjB,EAVF;;0BAAA;4BAUzBC,kBAVyB;4BAgBzBC,YAhByB,GAiB7BhG,UAAS7V,IAAT,IAAiB,IAAjB,GAAwB,IAAxB,GAA+B4b,kBAjBF;4BAmB/BT,eAAejS,WAAf,CACE,eADF,EAEE1E,iCACKqR,SADL;8BAEE7V,MAAM6b;4BAFR,EAFF,EAME,CAACD,kBAAD,CANF;;0BAnB+B;0BAAA;4BAAA;wBAAA;sBAAA;oBAAA;kBAAA;gBA2BjC,CAhCF;gBAiCEX,oBAjCF,gCAkCIpF,SAlCJ,UAoCI;kBAAA,IADE3H,OACF,UADEA,OACF;kBAAA,IADWW,aACX,UADWA,aACX;kBAAA,IAD0BC,aAC1B,UAD0BA,aAC1B;;kBACA,IAAInN,QAAQqG,KAAZ,EAAmB;oBACjB;kBACF;;kBAEAkG,QAAQhG,GAAR,CACE2G,aADF,EAEEgH,SAFF,EAGE3H,OAHF,EAIEY,aAJF;gBAMF;cA/CF,CALI,CAXH;;YAAA;cAAA;cAAA;;YAAA;cAAA;cAAA;;cAAA,MAmEC,wBAAiB8E,YAnElB;gBAAA;gBAAA;cAAA;;cAsEDuH,eAAejS,WAAf,CAA2B,eAA3B,EAA4C;gBAC1C9H,MAAM,aAAMA,IAD8B;gBAE1CkF,SAAS,aAAMA;cAF2B,CAA5C;cAtEC;;YAAA;cA8EH,IAAI,wBAAiBrC,KAArB,EAA4B;gBAC1B4C,SAASD,KAAT,0VAMEyC,QAAQzE,MANV,EAOEyE,QAAQrE,GAPV;gBAaAmW,eAAejS,WAAf,CAA2B,eAA3B,EAA4C;kBAC1CzI,QAAQ,GADkC;kBAE1CK,YAAY,uBAF8B;kBAG1CQ,SAAS;oBACP,gBAAgB;kBADT,CAHiC;kBAM1CtB,MAAM+B,KAAKmB,SAAL,CAAe;oBACnB9B,MAAM,aAAMA,IADO;oBAEnBkF,SAAS,aAAMA,OAFI;oBAGnByN,OAAO,aAAMA;kBAHM,CAAf;gBANoC,CAA5C;cAYF;;YAxGG;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAAP;;IAAA;MAAA;IAAA;EAAA;AA2GF,CA/GO;;AAiHP,2BACE8B,SADF,EAE8B;EAC5B,OAAO;IACLpV,QAAQoV,UAASpV,MADZ;IAELK,YAAY+U,UAAS/U,UAFhB;IAGLQ,SAASuU,UAASvU,OAAT,CAAiBmD,GAAjB,EAHJ;IAILzE,MAAM6V,UAAS7V,IAJV;IAKLG,OAAO0V,UAAS1V;EALX,CAAP;AAOF,C;;;SC3IA2b,qB;;;;;;sFAAA,mBACE3c,OADF,EAEE8H,aAFF;IAAA;;IAAA;MAAA;QAAA;UAAA;YAKE9H,QAAQoJ,aAAR,CAAsBC,IAAtB,CAA2B,yBAA3B;YALF;YAAA,OAO4CrJ,QAAQsJ,MAAR,CAAeC,IAAf,CACxC,0BADwC,CAP5C;;UAAA;YAAA;YAOmBqT,cAPnB,yBAOU5Y,OAPV;;YAAA,MAaM4Y,mBAAmB,kCAbzB;cAAA;cAAA;YAAA;;YAAA,MAcU,IAAI9X,KAAJ,4CACgC8X,cADhC,4CACuF,kCADvF,QAdV;;UAAA;YAAA,mCAmBS9U,aAnBT;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,C;;;;ACFA,oBAAsB/F,4BAAtB;;AAOO,mCAAmC8a,gBAAnC,EAAmE;EAExE,IAAMC,kBAAkB7X,OAAO8X,cAAP,CAAsBC,SAAtB,CAAgC3T,IAAxD;;EACApE,OAAO8X,cAAP,CAAsBC,SAAtB,CAAgC3T,IAAhC,GAAuC,YAErC;IAAA;;IAAA,mCADGrH,IACH;MADGA,IACH;IAAA;;IAGA,yBAAM;MAAA,OAAM6a,gBAAN;IAAA,CAAN,EAA8B7U,IAA9B,CAAmC,YAAM;MACvC/C,OAAO8X,cAAP,CAAsBC,SAAtB,CAAgC3T,IAAhC,GAAuCyT,eAAvC;;MACA,OAAKzT,IAAL,eAAarH,IAAb;IACD,CAHD;EAIF,CATA;;EAYA,IAAMib,gBAAgBhY,OAAO9D,KAA7B;EACA8D,OAAO9D,KAAP,2EAAe;IAAA;;IAAA;IAAA;MAAA;QAAA;UAAA;YAAA;YAAA,OACP,yBAAM;cAAA,OAAM0b,gBAAN;YAAA,CAAN,CADO;;UAAA;YAEb5X,OAAO9D,KAAP,GAAe8b,aAAf;YAFa,mCAGN,mBAAO9b,KAAP,wBAHM;;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA;EAAA,CAAf;AAKF,C;;;ACtBO,gCAAgCnB,OAAhC,EAAqE;EAC1E,OAAO,UACL+S,CADK,EAEL5L,OAFK,EAMF;IAbP;;IAcI,IAAiB+V,YAAjB,GAAkC/V,OAAlC,CAAQnD,OAAR;;IASA,IAAI,mBAAagG,IAAb,wBAAmBrE,QAAnB,CAA4B,QAA5B,CAAJ,EAA2C;MACzC;IACF;;IAEA,IAAM+Q,YAAW,IAAI6F,QAAJ,CAAaW,aAAarc,IAAb,IAAqB,IAAlC,EAAwCqc,YAAxC,CAAjB;IACA,IAAMC,mBAAmBzG,UAASvU,OAAT,CAAiBoI,GAAjB,CAAqB,cAArB,MAAyC,KAAlE;;IAEA,IAAI4S,gBAAJ,EAAsB;MACpBnd,QAAQkb,OAAR,CAAgBE,IAAhB,CAAqB,iBAArB,EAAwC1E,SAAxC,EAAkDwG,aAAaE,SAA/D;IACF,CAFA,MAEO;MACLpd,QAAQkb,OAAR,CAAgBE,IAAhB,CAAqB,iBAArB,EAAwC1E,SAAxC,EAAkDwG,aAAaE,SAA/D;IACF;EACF,CA5BA;AA6BF,C;;;ACjCO,6BACLpX,YADK,EAELxD,OAFK,EAGC;EACN,IAAI,EAACA,mCAASqG,KAAV,KAAmB,CAAC7B,SAASlB,IAAT,CAAcqF,UAAd,CAAyBnF,aAAa4C,KAAtC,CAAxB,EAAsE;IACpElB,SAASH,IAAT,gGAEkFvB,aAAa4C,KAF/F;EAQF;AACF,C;;;A3CNO,IAAMyU,qBAAqB,SAArBA,kBAAqB,CAChCrd,OADgC,EAEf;EACjB,OAAO,eAAewC,OAAf,EAAwB8a,aAAxB,EAAuC;IAC5C,IAAMC;MAAA,wEAAsB;QAAA;;QAAA;UAAA;YAAA;cAAA;gBAI1Bvd,QAAQsJ,MAAR,CAAekU,kBAAf;gBAGAxd,QAAQoJ,aAAR,CAAsBqU,EAAtB,CACE,SADF,EAEE1B,sBAAsB/b,OAAtB,EAA+BwC,OAA/B,CAFF;gBAMAxC,QAAQoJ,aAAR,CAAsBqU,EAAtB,CAAyB,UAAzB,EAAqCC,uBAAuB1d,OAAvB,CAArC;gBAb0B;gBAAA,OAeH2H,kBACrBnF,QAAQsF,aAAR,CAAsBjC,GADD,EAErBrD,QAAQsF,aAAR,CAAsBtF,OAFD,EAGrBA,QAAQ0D,UAHa,CAfG;;cAAA;gBAepBuC,QAfoB;gBAAA,2BAqBKA,QArBL,MAqBnB7B,MArBmB,iBAqBXZ,YArBW;;gBAAA,IAuBrBY,MAvBqB;kBAAA;kBAAA;gBAAA;;gBAwBlB+W,oBAxBkB,GAwBK,gDAAezX,UAAf,IACzBwB,SAASF,aAAT,8QAMEhF,QAAQsF,aAAR,CAAsBjC,GANxB,CADyB,GASzB6B,SAASF,aAAT,8fAMEhF,QAAQsF,aAAR,CAAsBjC,GANxB,EAOEmB,SAAS+I,IAPX,CAjCoB;gBAAA,MA2ClB,IAAIjL,KAAJ,CAAU6Y,oBAAV,CA3CkB;;cAAA;gBA8C1B3d,QAAQ4G,MAAR,GAAiBA,MAAjB;gBACA5G,QAAQgG,YAAR,GAAuBA,YAAvB;gBAEAhG,QAAQsJ,MAAR,CAAesU,WAAf,CAA2B3Y,MAA3B,EAAmC,cAAnC,EAAmD,YAAM;kBACvD,IAAI2B,OAAOiX,KAAP,KAAiB,WAArB,EAAkC;oBAKhC7d,QAAQoJ,aAAR,CAAsBC,IAAtB,CAA2B,eAA3B;kBACF;;kBAGApE,OAAO6Y,aAAP,CAAqB9d,QAAQ+d,iBAA7B;gBACD,CAXD;gBAjD0B;gBAAA,OA+DK,yBAAM;kBAAA,OACnCpB,sBAAsB3c,OAAtB,EAA+B4G,MAA/B,CADmC;gBAAA,CAAN,CA/DL;;cAAA;gBAAA;gBAAA;gBA+DnBoX,cA/DmB;;gBAmE1B,IAAIA,cAAJ,EAAoB;kBAClBtW,SAASD,KAAT,6CAC4BuW,eAAe7W,OAD3C;gBAUF;;gBAEAnH,QAAQ+d,iBAAR,GAA4B9Y,OAAOgZ,WAAP,CAC1B;kBAAA,OAAMje,QAAQoJ,aAAR,CAAsBC,IAAtB,CAA2B,mBAA3B,CAAN;gBAAA,CAD0B,EAE1B,GAF0B,CAA5B;gBAOA6U,oBAAoBlY,YAApB,EAAkChG,QAAQme,YAA1C;gBAvF0B,mCAyFnBnY,YAzFmB;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CAAtB;;MAAA;QAAA;MAAA;IAAA,GAAN;;IA4FA,IAAMoY,qBAAqBb,sBAAsBvV,IAAtB;MAAA,wEACzB,mBAAOhC,YAAP;QAAA;QAAA;UAAA;YAAA;cAAA;gBACQqY,eADR,GAC0BrY,aAAaK,UAAb,IAA2BL,aAAaM,OADlE;;gBAAA,KAMM+X,eANN;kBAAA;kBAAA;gBAAA;;gBAAA;gBAAA,OAOU,IAAI7O,OAAJ,CAAkB,UAACC,OAAD,EAAa;kBACnC4O,gBAAgBC,gBAAhB,CAAiC,aAAjC,EAAgD,YAAM;oBACpD,IAAID,gBAAgBR,KAAhB,KAA0B,WAA9B,EAA2C;sBACzC,OAAOpO,SAAP;oBACF;kBACD,CAJD;gBAKD,CANK,CAPV;;cAAA;gBAAA;gBAAA,OAiBQtG,cAAcnJ,OAAd,EAAuBwC,OAAvB,EAAgC+b,KAAhC,CAAsC,UAACzb,MAAD,EAAW;kBACrD,MAAM,IAAIgC,KAAJ,qCAAuChC,iCAAOqE,OAA9C,EAAN;gBACD,CAFK,CAjBR;;cAAA;gBAAA,mCAqBSnB,YArBT;;cAAA;cAAA;gBAAA;YAAA;UAAA;QAAA;MAAA,CADyB;;MAAA;QAAA;MAAA;IAAA,IAA3B;;IA6BA,IAAIxD,QAAQgc,cAAZ,EAA4B;MAC1BC,0BAA0BL,kBAA1B;IACF;;IAEA,OAAOA,kBAAP;EACF,CA/HA;AAgIF,CAnIO,C;;;A4CTA,4BAAgE;EAAA,IAAtCpc,IAAsC,uEAAV,EAAU;;EACrE,IAAIA,KAAK6G,KAAT,EAAgB;IACd;EACF;;EAEAvB,QAAQyB,GAAR,aACOrB,SAASF,aAAT,CAAuB,mBAAvB,CADP,GAEE,mCAFF;AAIF,C;;;ACPO,IAAMkX,aAAa,SAAbA,UAAa,CACxB1e,OADwB,EAER;EAChB,OAAO,gBAAgB;IAPzB;;IAUI,IAAI,CAACA,QAAQwJ,gBAAb,EAA+B;MAC7B9B,SAASH,IAAT,CACE,iKADF;MAGA;IACF;;IAOAvH,QAAQoJ,aAAR,CAAsBC,IAAtB,CAA2B,iBAA3B;IACArJ,QAAQwJ,gBAAR,GAA2B,KAA3B;IACAvE,OAAO6Y,aAAP,CAAqB9d,QAAQ+d,iBAA7B;IAEAY,iBAAiB;MAAE9V,OAAO,cAAQsV,YAAR,wBAAsBtV;IAA/B,CAAjB;EACF,CApBA;AAqBF,CAxBO,C;;;ACFA,cACL+V,eADK,EAGC;EAAA,mCADHhQ,QACG;IADHA,QACG;EAAA;;EACNgQ,gBAAgBC,OAAhB,wBAA2BjQ,QAA3B;AACF;;AAEO,0BAAyBA,QAAzB,EAA2D;EAChEA,SAASvM,OAAT,CAAiB,UAAC0M,OAAD,EAAa;IAC5BA,QAAQQ,aAAR,CAAsB,KAAtB;EACD,CAFD;AAGF;;AAEO,wBACLuP,eADK,EAGL;EAAA,oCADGC,YACH;IADGA,YACH;EAAA;;EACA,OAAOA,aAAa3W,MAAb,GAAsB,CAAtB,aAA8B2W,YAA9B,uBAAkDD,eAAlD,CAAP;AACF,C;;;ACXO,IAAME,wBAAoD;EAC/DlX,eAAe;IACbjC,KAAK,uBADQ;IAEbrD,SAAS;EAFI,CADgD;EAK/DqG,OAAO,KALwD;EAM/D2V,gBAAgB,IAN+C;EAO/DhD,oBAAoB,MAP2C;EAQ/DtV,UAR+D,sBAQpDW,SARoD,EAQzCoY,oBARyC,EAQnB;IAC1C,OAAOpY,cAAcoY,oBAArB;EACF;AAV+D,CAA1D;;AAiBA,6BACLC,cADK,EAEuB;EAC5B,OAAOtb,WACLob,qBADK,EAELE,kBAAkB,EAFb,CAAP;AAIF;;AAEO,6BACLnQ,OADK,EAEL/O,OAFK,EAGoB;EACzB,OAAO,UAACkf,cAAD,EAAoB;IACzBlf,QAAQme,YAAR,GAAuBgB,oBAAoBD,cAApB,CAAvB;IACA,OAAOnQ,QAAQ/O,QAAQme,YAAhB,EAA8Be,kBAAkB,EAAhD,CAAP;EACF,CAHA;AAIF,C;;;AC3CA,2BAIOnd,8BAJP;;AAKA,oBAAiCA,qDAAjC;;AACA,4BAA0CA,8DAA1C;;AAWO,uCACL/B,OADK,EAELwC,OAFK,EAG6B;EAClC,IAAM4c,cAAc,IAAIC,qCAAJ,CAAqB;IACvCpd,MAAM,UADiC;IAEvCqd,cAAc,CAAC,IAAIC,8BAAJ,EAAD,EAAyB,IAAIC,+CAAJ,EAAzB;EAFyB,CAArB,CAApB;EAKAJ,YAAY3B,EAAZ,CAAe,SAAf;IAAA,wEAA0B,mBAAOvT,OAAP;MAAA;MAAA;QAAA;UAAA;YAAA;cAAA,gBACExK,cADF;cAAA,gBACgBwK,QAAQrE,GADxB;cAAA,gBAC6BR,aAD7B;cAAA,gBAC6BkJ,mBAChDrE,OADgD,CAD7B;cAAA;cAAA,OAGVA,QAAQsS,WAAR,EAHU;;YAAA;cAAA;cAAA;gBAGtB3b,IAHsB;cAAA;cAAA;cAClB4e,aADkB;cAAA;cAAA,OAMDnf,eACrBmf,aADqB,EAErBzf,QAAQoc,eAFa,EAGrB5Z,OAHqB,EAIrBxC,QAAQkb,OAJa,EAKrB;gBACEU,iBADF,6BACoB8D,SADpB,EAC8B;kBAC1B,OAAO;oBACLpe,QAAQoe,UAASpe,MADZ;oBAELK,YAAY+d,UAAS/d,UAFhB;oBAGLQ,SAASud,UAASvd,OAAT,CAAiBmD,GAAjB,EAHJ;oBAILzE,MAAM6e,UAAS7e,IAJV;oBAKLG,OAAO0e,UAAS1e;kBALX,CAAP;gBAOF,CATF;gBAUE8a,oBAVF,gCAWI4D,SAXJ,UAaI;kBAAA,IADE3Q,OACF,UADEA,OACF;kBAAA,IADWW,aACX,UADWA,aACX;kBAAA,IAD0BC,aAC1B,UAD0BA,aAC1B;;kBACA,IAAI,CAACnN,QAAQqG,KAAb,EAAoB;oBAClBkG,QAAQhG,GAAR,CACE2G,aADF,EAEEgQ,SAFF,EAGE3Q,OAHF,EAIEY,aAJF;kBAMF;gBACF;cAtBF,CALqB,CANC;;YAAA;cAMlB+G,SANkB;;cAqCxB,IAAIA,SAAJ,EAAc;gBACZxM,QAAQyV,WAAR,CAAoBjJ,SAApB;cACF;;YAvCwB;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAA1B;;IAAA;MAAA;IAAA;EAAA;EA0CA0I,YAAYQ,KAAZ;EAEA,OAAOR,WAAP;AACF,C;;;ACnEO,6BACLpf,OADK,EAES;EACd;IAAA,wEAAO,mBAAqBwC,OAArB;MAAA;QAAA;UAAA;YAAA;cACLxC,QAAQ6f,mBAAR,GAA8BC,8BAC5B9f,OAD4B,EAE5BwC,OAF4B,CAA9B;cAKAiH,kBAAkB;gBAChBtC,SAAS,kCADO;gBAEhB0B,OAAOrG,QAAQqG;cAFC,CAAlB;cANK,mCAWE,MAXF;;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA;IAAA,CAAP;;IAAA,SAAOkX,KAAP;MAAA;IAAA;;IAAA,OAAOA,KAAP;EAAA;AAaF,C;;;ACjBO,4BACL/f,OADK,EAEQ;EACb,OAAO,gBAAgB;IANzB;;IAOI,cAAQ6f,mBAAR,wBAA6BG,OAA7B;IACArB,iBAAiB;MAAE9V,OAAO,cAAQsV,YAAR,wBAAsBtV;IAA/B,CAAjB;EACF,CAHA;AAIF,C;;;ACLO,oBACLoX,MADK,EAELnT,WAFK,EAGC;EACN,IAAMoT,UAAUD,OAAO7E,IAAvB;;EAGA,IAAI8E,QAAQC,QAAZ,EAAsB;IACpB;EACF;;EAEAF,OAAO7E,IAAP,GAAc,UAAUzR,KAAV,EAA0B;IAAA,oCAANE,KAAM;MAANA,KAAM;IAAA;;IACtCiD,YAAYsO,IAAZ,qBAAiBzR,KAAjB,SAA2BE,KAA3B;IACA,OAAOqW,QAAQE,IAAR,iBAAa,IAAb,EAAmBzW,KAAnB,SAA6BE,KAA7B,EAAP;EACF,CAHA;;EAMAoW,OAAO7E,IAAP,CAAY+E,QAAZ,GAAuB,IAAvB;AACF,C;;;ApDKA,IAAIE,YAAwB,EAA5B;;AAQO,wBAEW;EAAA,oCADbjE,eACa;IADbA,eACa;EAAA;;EAChBA,gBAAgB/Z,OAAhB,CAAwB,UAAC0M,OAAD,EAAa;IACnC,IAAIhM,MAAMC,OAAN,CAAc+L,OAAd,CAAJ,EACE,MAAM,IAAIjK,KAAJ,CACJ4C,SAASF,aAAT,CACE,0JADF,CADI,CAAN;EAKH,CAPD;;EAUA,IAAI,4CAAJ,EAAqB;IACnB,MAAM,IAAI1C,KAAJ,CACJ4C,SAASF,aAAT,CACE,6HADF,CADI,CAAN;EAKF;;EAEA,IAAM0T,UAAU,IAAIoF,8CAAJ,EAAhB;EACA,IAAMC,gBAAgB,IAAID,8CAAJ,EAAtB;EACAE,WAAWtF,OAAX,EAAoBqF,aAApB;EAEA,IAAMvgB,UAAsC;IAG1CwJ,kBAAkB,KAHwB;IAI1C2U,cAAc,MAJ4B;IAK1CvX,QAAQ,IALkC;IAM1CZ,cAAc,IAN4B;IAO1CoW,2BAAqBA,eAArB,CAP0C;IAQ1ClB,gBAR0C;IAS1C9R,eAAe;MACbqU,EADa,cACVgD,SADU,EACCC,QADD,EACW;QACtB1gB,QAAQsJ,MAAR,CAAesU,WAAf,CACE/V,UAAUC,aADZ,EAEE,SAFF,EAGE,UAAC6B,KAAD,EAAyB;UAEvB,IAAIA,MAAMsW,MAAN,KAAiBjgB,QAAQ4G,MAA7B,EAAqC;YACnC;UACF;;UAEA,IAAMO,UAAUwC,MAAM5I,IAAtB;;UAKA,IAAI,CAACoG,OAAL,EAAc;YACZ;UACF;;UAEA,IAAIA,QAAQ6C,IAAR,KAAiByW,SAArB,EAAgC;YAC9BC,SAAS/W,KAAT,EAAgBxC,OAAhB;UACF;QAEJ,CAtBA;MAuBF,CAzBa;MA0BbkC,IA1Ba,gBA0BRW,IA1BQ,EA0BF;QAhGjB;;QAiGQ,cAAQpD,MAAR,wBAAgBmD,WAAhB,CAA4BC,IAA5B;MACF;IA5Ba,CAT2B;IAuC1CV,QAAQ;MACNsU,WADM,uBAEJxM,MAFI,EAGJqP,SAHI,EAIJC,QAJI,EAKJ;QACAtP,OAAOkN,gBAAP,CAAwBmC,SAAxB,EAAmCC,QAAnC;QACAL,UAAUpJ,IAAV,CAAe;UAAEwJ,oBAAF;UAAarP,cAAb;UAAqBsP;QAArB,CAAf;QAEA,OAAO,YAAM;UACXtP,OAAOuP,mBAAP,CAA2BF,SAA3B,EAAsCC,QAAtC;QACF,CAFA;MAGF,CAZM;MAaNlD,kBAbM,gCAae;QAAA,4CAC2B6C,SAD3B;QAAA;;QAAA;UACnB,uDAAyD;YAAA;YAAA,IAA5CjP,MAA4C,gBAA5CA,MAA4C;YAAA,IAApCqP,SAAoC,gBAApCA,SAAoC;YAAA,IAAzBC,QAAyB,gBAAzBA,QAAyB;YACvDtP,OAAOuP,mBAAP,CAA2BF,SAA3B,EAAsCC,QAAtC;UACF;QAHmB;UAAA;QAAA;UAAA;QAAA;;QAInBL,YAAY,EAAZ;MACF,CAlBM;MAmBN9W,IAnBM,gBAmBDkX,SAnBC,EAmBU;QACd,IAAMG,WAA8B,EAApC;QAEA,OAAO,IAAIpR,OAAJ,CAKL,UAACC,OAAD,EAAUoR,MAAV,EAAqB;UACrB,IAAMC,wBAAwB,SAAxBA,qBAAwB,CAACnX,KAAD,EAAyB;YACrD,IAAI;cACF,IAAMxC,UAAUwC,MAAM5I,IAAtB;;cAEA,IAAIoG,QAAQ6C,IAAR,KAAiByW,SAArB,EAAgC;gBAC9BhR,QAAQtI,OAAR;cACF;YACF,CANA,CAMA,OAASrE,MAAT,EAAE;cACA+d,OAAO/d,MAAP;YACF;UACF,CAVA;;UAYA8d,SAAS3J,IAAT,CACEjX,QAAQsJ,MAAR,CAAesU,WAAf,CACE/V,UAAUC,aADZ,EAEE,SAFF,EAGEgZ,qBAHF,CADF,EAME9gB,QAAQsJ,MAAR,CAAesU,WAAf,CACE/V,UAAUC,aADZ,EAEE,cAFF,EAGE+Y,MAHF,CANF;QAYD,CA9BM,EA8BJE,OA9BI,CA8BI,YAAM;UACfH,SAASve,OAAT,CAAiB,UAAC2e,MAAD;YAAA,OAAYA,QAAZ;UAAA,CAAjB;QACD,CAhCM,CAAP;MAiCF;IAvDM,CAvCkC;IAgG1CC,iBACE,EAAE,mBAAmBpZ,SAArB,KAAmCb,SAAS8I,QAAT,KAAsB;EAjGjB,CAA5C;EAoGA,IAAMoR,eAAelhB,QAAQihB,eAAR,GACjBE,oBAAoBnhB,OAApB,CADiB,GAEjBqd,mBAAmBrd,OAAnB,CAFJ;EAGA,IAAMohB,cAAcphB,QAAQihB,eAAR,GAChBI,mBAAmBrhB,OAAnB,CADgB,GAEhB0e,WAAW1e,OAAX,CAFJ;EAIA,OAAO;IACL+f,OAAOuB,oBAAoBJ,YAApB,EAAkClhB,OAAlC,CADF;IAELuhB,IAFK,kBAEE;MACLvhB,QAAQsJ,MAAR,CAAekU,kBAAf;MACAxd,QAAQkb,OAAR,CAAgBsC,kBAAhB;MACA+C,cAAc/C,kBAAd;MACA4D;IACF,CAPK;IASLI,GATK,iBASY;MAAA,oCAAV5S,QAAU;QAAVA,QAAU;MAAA;;MACK4S,oBAAIxhB,QAAQoc,eAAZ,SAAgCxN,QAAhC;IACtB,CAXK;IAaL6S,eAbK,6BAaa;MACIA,iBAAgBzhB,QAAQoc,eAAxB;IACtB,CAfK;IAiBLsF,aAjBK,2BAiB0B;MAAA,oCAAd3C,YAAc;QAAdA,YAAc;MAAA;;MAC7B/e,QAAQoc,eAAR,GAA0BsF,cAAoB,MAApB,UACxBtF,eADwB,SAErB2C,YAFqB,EAA1B;IAIF,CAtBK;IAwBL4C,aAxBK,2BAwBW;MACd3hB,QAAQoc,eAAR,CAAwB/Z,OAAxB,CAAgC,UAAC0M,OAAD,EAAa;QAC3C,qBAA8BA,QAAQyG,IAAtC;QAAA,IAAQoB,MAAR,kBAAQA,MAAR;QAAA,IAAgBtB,SAAhB,kBAAgBA,SAAhB;QACA,IAAMsM,SAAS7S,QAAQyG,IAAR,CAAaqM,cAAb,CAA4B,eAA5B,IACX,WADW,GAEX,QAFJ;QAIAva,QAAQwB,cAAR,WAA0B8Y,MAA1B,cAAoChL,MAApC;;QAEA,IAAItB,SAAJ,EAAe;UACbhO,QAAQyB,GAAR,wBAA4BuM,SAA5B;QACF;;QAEAhO,QAAQyB,GAAR,CAAY,UAAZ,EAAwBgG,OAAxB;;QAEA,IAAIA,mBAAmBlP,YAAvB,EAAoC;UAClCyH,QAAQyB,GAAR,CACE,QADF,uCAEgCgG,QAAQyG,IAAR,CAAanE,IAF7C;QAIF;;QAEA/J,QAAQ4B,QAAR;MACD,CAtBD;IAuBF,CAhDK;IAkDLI,QAAQ;MACNmU,EADM,gBACM;QACV,OAAO8C,cAAc9C,EAAd,gCAAP;MACF,CAHM;MAINqE,cAJM,4BAIkB;QACtB,OAAOvB,cAAcuB,cAAd,gCAAP;MACF,CANM;MAONtE,kBAPM,gCAOsB;QAC1B,OAAO+C,cAAc/C,kBAAd,gCAAP;MACF;IATM;EAlDH,CAAP;AA8DF,C;;;AqD7NA,2BACE/X,MADF,EAEE;EACA,OAAO,UAKL4L,IALK,EAMLgE,QANK,EAgBF;IACH,OAAO,IAAIxV,YAAJ,CAAgB4F,MAAhB,EAAwB4L,IAAxB,EAA8BgE,QAA9B,CAAP;EACF,CAlBA;AAmBF;;AAEO,IAAM5U,QAAO;EAClB6E,KAAKyc,kBAAkB,IAAlB,CADa;EAElBC,MAAMD,kBAAkB;EAAA;EAAlB,CAFY;EAGlBxX,KAAKwX,kBAAkB;EAAA;EAAlB,CAHa;EAIlBE,MAAMF,kBAAkB;EAAA;EAAlB,CAJY;EAKlBG,KAAKH,kBAAkB;EAAA;EAAlB,CALa;EAMlBI,QAAQJ,kBAAkB;EAAA;EAAlB,CANU;EAOlBK,OAAOL,kBAAkB;EAAA;EAAlB,CAPW;EAQlBvf,SAASuf,kBAAkB;EAAA;EAAlB;AARS,CAAb,C;;ACjCP,sBAAgDhgB,kBAAhD;;AAqBA,oCACEsO,aADF,EAEExK,GAFF,EAGE;EACA,OAAO,UAIL0K,aAJK,EAQL8E,QARK,EAYF;IACH,OAAO,IAAI5V,eAAJ,CACL4Q,aADK,EAELE,aAFK,EAGL1K,GAHK,EAILwP,QAJK,CAAP;EAMF,CAnBA;AAoBF;;AAEA,uCAAuCxP,GAAvC,EAAkD;EAChD,OAAO,UAILwP,QAJK,EAQF;IACH,OAAO,IAAI5V,eAAJ,CACL,KADK,EAEL,IAAI+L,MAAJ,CAAW,IAAX,CAFK,EAGL3F,GAHK,EAILwP,QAJK,CAAP;EAMF,CAfA;AAgBF;;AAEA,IAAMgN,0BAA0B;EAS9B/R,WAAWgS,8BAA8B,GAA9B,CATmB;EAmB9B9R,OAAO+R,2BAA2BC,kCAAkBC,KAA7C,EAAoD,GAApD,CAnBuB;EA6B9BC,UAAUH,2BAA2BC,kCAAkBG,QAA7C,EAAuD,GAAvD;AA7BoB,CAAhC;;AAgCA,2BAA2B9c,GAA3B,EAAsE;EACpE,OAAO;IACLyK,WAAWgS,8BAA8Bzc,GAA9B,CADN;IAEL2K,OAAO+R,2BAA2BC,kCAAkBC,KAA7C,EAAoD5c,GAApD,CAFF;IAGL6c,UAAUH,2BAA2BC,kCAAkBG,QAA7C,EAAuD9c,GAAvD;EAHL,CAAP;AAKF;;AAEO,IAAMzF,WAAUiF,iCAClBgd,uBADkB;EAErBO,MAAMC;AAFe,EAAhB,C","names":["__export","GraphQLHandler","MockedRequest","RESTMethods","RequestHandler","RestHandler","cleanUrl","compose","context","createResponseComposition","defaultContext","defaultResponse","graphql","graphqlContext","handleRequest","matchRequestUrl","response","rest","restContext","setupWorker","module","body","cookie","data","delay","errors","extensions","fetch","json","set","status","text","xml","__toESM","statusCode","statusText","res","import_codes","String","require","args","name","value","headers","append","forEach","value2","name2","options","serializedCookie","cookieUtils","document","JSON","parse","error2","Array","isArray","left","right","Object","entries","reduce","result","key","rightValue","leftValue","concat","isObject","mergeRight","assign","body2","stringify","payload","prevBody","jsonParse","nextBody","SET_TIMEOUT_MAX_ALLOWED_INT","MIN_SERVER_RESPONSE_TIME","MAX_SERVER_RESPONSE_TIME","NODE_SERVER_RESPONSE_TIME","getRandomServerResponseTime","Math","floor","random","durationOrMode","delayTime","Error","errorsList","useFetch","window","augmentRequestInit","requestInit","import_headers_polyfill2","__spreadProps","all","createFetchRequestParameters","input","method","requestParameters","includes","derivedRequestInit","url","href","getWorkerByRegistration","registration","absoluteWorkerUrl","findWorker","allStates","active","installing","waiting","existingStates","filter","Boolean","mockWorker","find","worker","scriptURL","relativeUrl","URL","location","origin","LIBRARY_PREFIX","message","positionals","interpolatedMessage","console","warn","formatMessage","error","devUtils","getWorkerInstance","getAbsoluteWorkerUrl","navigator","serviceWorker","getRegistrations","then","registrations","mockRegistrations","controller","length","reload","existingRegistration","update","register","instance","isWorkerMissing","scopeUrl","scope","quiet","groupCollapsed","log","workerUrl","workerScope","groupEnd","enableMocking","workerChannel","send","events","once","isMockingEnabled","printStartMessage","port","event","rest2","data2","transfer","postMessage","type","cookieUtils2","request","credentials","getAllCookies","headersString","contentType","get","disposition","directives","split","acc","chunk","trim","join","slice","filename","boundary","d","startsWith","map","s","replace","boundaryRegExp","RegExp","fields","endsWith","trimStart","parsedBody","field2","contentHeaders","contentBody","parseContentHeaders","contentType2","File","parsedValue","toLowerCase","hasMultipartContent","parseMultipartData","toString","hasJsonContent","actual","expected","init","id","cache","destination","integrity","keepalive","mode","priority","redirect","referrer","referrerPolicy","cookies","getCookies","text2","parseBody","isStringEqual","import_lib","passthrough","requestCookiesString","ownCookies","cookieUtils3","import_cookies","hydrate","cookiesFromStore","from","cookiesFromDocument","getRequestCookies","forwardedCookies","__spreadValues","import_interceptors","rawRequest","import_headers_polyfill4","getResponse","handlers","resolutionContext","relevantHandlers","handler","test","executionResult","previousResults","run","result2","shouldSkip","parsedResult","markAsSkipped","Promise","resolve","publicRequest","parsedRequest","getPublicUrlFromRequest","pathname","protocol","host","node","operationDef","definitions","def","kind","operationType","operation","operationName","query","ast","parseDocumentNode","variables","files","operations","pathArray","dotPath","reverse","lastPath","reversedPaths","paths","target","path","searchParams","__objRest","_c","parsedOperations","parsedMap","extractMultipartVariables","getGraphQLInput","parseQuery","requestPublicUrl","status2","now","Date","getHours","getMinutes","getSeconds","padStart","responseHeaders","REDUNDANT_CHARACTERS_EXP","baseUrl","isAbsoluteUrl","baseURI","decodeURI","encodeURI","maybeAbsoluteUrl","getAbsoluteUrl","_","parameterName","wildcard","expression","normalizedPath","normalizePath","cleanPath","coercePath","cleanUrl2","decode","decodeURIComponent","params","matches","fns","reduceRight","leftFn","rightFn","defaultResponseTransformers","responseOverrides","defaultTransformers","initialResponse","import_headers_polyfill6","transformers","resolvedTransformers","resolvedResponse","networkError","NetworkError","SOURCE_FRAME","BUILD_FRAME","stack","frames","declarationFrame","frame","declarationPath","fn","Symbol","iterator","ctx","resolver","callFrame","getCallFrame","info","_request","_resolutionContext","predicate","_parsedResult","shouldIntercept","getPublicRequest","executeResolver","wrapResolver","mockedResponse","createExecutionResult","req","resolverGenerator","isIterable","next","done","nextResponse","resolverGeneratorResult","response2","RESTMethods2","header","checkRedundantQueryParameters","getSearchParams","queryParams","paramName","push","RestRequest","matchesMethod","publicUrl","loggedRequest","prepareRequest","loggedResponse","prepareResponse","statusColor","getStatusCodeColor","getTimestamp","mask","field","fieldName","fieldValue","validateFieldName","onException","endpoint","resolvedOperationName","isDocumentNode","parsedNode","tryCatch","parseGraphQLRequest","GraphQLRequest","hasMatchingUrl","hasMatchingOperationType","hasMatchingOperationName","requestInfo","MAX_MATCH_SCORE","MAX_SUGGESTION_COUNT","TYPE_MATCH_DELTA","groups","Infinity","hasSameMethod","methodScoreDelta","score","parsedQuery","hasSameOperationType","operationTypeScoreDelta","getScore","suggestedHandlers","suggestions","sort","leftScore","rightScore","strategy","parsedGraphQLQuery","handlerGroups","groupHandlersByType","getSuggestedHandler","getGraphQLHandlerScore","getRestHandlerScore","getSuggestedHandlersMessage","requestHeader","handlerSuggestion","generateHandlerSuggestion","messageTemplate","strategy2","generateUnhandledRequestMessage","warning","applyStrategy","bind","import_cookies2","add","persist","emitter","handleRequestOptions","emit","onPassthroughResponse","lookupError","lookupResult","onUnhandledRequest","readResponseCookies","requiredLookupResult","transformedResponse","transformResponse","onMockedResponse","onMockedResponseSent","createRequestListener","messageChannel","WorkerChannel","ports","parseWorkerRequest","requestHandlers","ReadableStream","responseInstance","Response","arrayBuffer","responseBodyBuffer","responseBody","requestIntegrityCheck","actualChecksum","predicatePromise","originalXhrSend","XMLHttpRequest","prototype","originalFetch","responseJson","isMockedResponse","requestId","createStartHandler","customOptions","startWorkerInstance","removeAllListeners","on","createResponseListener","missingWorkerMessage","addListener","state","clearInterval","keepAliveInterval","integrityError","setInterval","validateWorkerScope","startOptions","workerRegistration","pendingInstance","addEventListener","catch","waitUntilReady","deferNetworkRequestsUntil","createStop","printStopMessage","currentHandlers","unshift","initialHandlers","nextHandlers","DEFAULT_START_OPTIONS","mockServiceWorkerUrl","initialOptions","resolveStartOptions","interceptor","import_interceptors3","interceptors","import_fetch3","import_XMLHttpRequest","mockedRequest","response3","respondWith","apply","fallbackInterceptor","createFallbackRequestListener","start","dispose","source","rawEmit","_isPiped","call","listeners","import_strict_event_emitter","publicEmitter","pipeEvents","eventType","callback","removeEventListener","bindings","reject","handleIncomingMessage","finally","unbind","useFallbackMode","startHandler","createFallbackStart","stopHandler","createFallbackStop","prepareStartHandler","stop","use","restoreHandlers","resetHandlers","printHandlers","pragma","hasOwnProperty","removeListener","createRestHandler","head","post","put","delete","patch","standardGraphQLHandlers","createGraphQLOperationHandler","createScopedGraphQLHandler","import_graphql2","QUERY","mutation","MUTATION","link","createGraphQLLink"],"sources":["/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/index.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/context/index.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/context/status.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/context/set.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/context/cookie.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/context/body.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/internal/jsonParse.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/internal/isObject.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/internal/mergeRight.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/context/json.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/context/data.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/context/extensions.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/context/delay.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/context/errors.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/context/fetch.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/context/text.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/context/xml.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/setupWorker/setupWorker.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/setupWorker/start/createStartHandler.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/setupWorker/start/utils/getWorkerInstance.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/setupWorker/start/utils/getWorkerByRegistration.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/url/getAbsoluteWorkerUrl.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/internal/devUtils.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/setupWorker/start/utils/printStartMessage.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/setupWorker/start/utils/enableMocking.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/setupWorker/start/utils/createMessageChannel.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/NetworkError.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/request/parseWorkerRequest.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/request/MockedRequest.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/request/getRequestCookies.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/internal/parseMultipartData.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/request/parseBody.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/internal/isStringEqual.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/handleRequest.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/getResponse.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/request/onUnhandledRequest.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/internal/parseGraphQLRequest.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/request/getPublicUrlFromRequest.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/logging/getStatusCodeColor.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/logging/getTimestamp.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/logging/prepareRequest.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/logging/prepareResponse.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/matching/matchRequestUrl.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/url/cleanUrl.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/url/isAbsoluteUrl.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/url/getAbsoluteUrl.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/matching/normalizePath.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/handlers/RequestHandler.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/response.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/internal/compose.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/internal/getCallFrame.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/internal/isIterable.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/handlers/RestHandler.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/context/field.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/internal/tryCatch.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/handlers/GraphQLHandler.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/request/readResponseCookies.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/setupWorker/start/createRequestListener.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/internal/requestIntegrityCheck.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/deferNetworkRequestsUntil.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/setupWorker/start/createResponseListener.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/setupWorker/start/utils/validateWorkerScope.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/setupWorker/stop/utils/printStopMessage.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/setupWorker/stop/createStop.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/internal/requestHandlerUtils.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/setupWorker/start/utils/prepareStartHandler.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/setupWorker/start/createFallbackRequestListener.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/setupWorker/start/createFallbackStart.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/setupWorker/stop/createFallbackStop.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/utils/internal/pipeEvents.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/rest.ts","/Users/singco/dev/projects/S07P12C104/client/node_modules/msw/src/graphql.ts"],"sourcesContent":["import * as context from './context'\nexport { context }\n\nexport { setupWorker } from './setupWorker/setupWorker'\nexport {\n  response,\n  defaultResponse,\n  createResponseComposition,\n} from './response'\n\n/* Request handlers */\nexport { RequestHandler, defaultContext } from './handlers/RequestHandler'\nexport { rest } from './rest'\nexport { RestHandler, RESTMethods, restContext } from './handlers/RestHandler'\nexport { graphql } from './graphql'\nexport { GraphQLHandler, graphqlContext } from './handlers/GraphQLHandler'\n\n/* Utils */\nexport { matchRequestUrl } from './utils/matching/matchRequestUrl'\nexport { compose } from './utils/internal/compose'\nexport * from './utils/handleRequest'\nexport { cleanUrl } from './utils/url/cleanUrl'\n\n/**\n * Type definitions.\n */\nexport type { SetupWorkerApi, StartOptions } from './setupWorker/glossary'\nexport type { SharedOptions } from './sharedOptions'\n\nexport * from './utils/request/MockedRequest'\nexport type {\n  ResponseResolver,\n  ResponseResolverReturnType,\n  AsyncResponseResolverReturnType,\n  DefaultBodyType,\n  DefaultRequestMultipartBody,\n} from './handlers/RequestHandler'\n\nexport type {\n  MockedResponse,\n  ResponseTransformer,\n  ResponseComposition,\n  ResponseCompositionOptions,\n  ResponseFunction,\n} from './response'\n\nexport type {\n  RestRequest,\n  RestContext,\n  RequestQuery,\n  ParsedRestRequest,\n} from './handlers/RestHandler'\n\nexport type {\n  GraphQLContext,\n  GraphQLVariables,\n  GraphQLRequest,\n  GraphQLRequestBody,\n  GraphQLJsonRequestBody,\n} from './handlers/GraphQLHandler'\n\nexport type { Path, PathParams, Match } from './utils/matching/matchRequestUrl'\nexport type { DelayMode } from './context/delay'\nexport { ParsedGraphQLRequest } from './utils/internal/parseGraphQLRequest'\n","export { status } from './status'\nexport { set } from './set'\nexport { cookie } from './cookie'\nexport { body } from './body'\nexport { data } from './data'\nexport { extensions } from './extensions'\nexport { delay } from './delay'\nexport { errors } from './errors'\nexport { fetch } from './fetch'\nexport { json } from './json'\nexport { text } from './text'\nexport { xml } from './xml'\n","import statuses from 'statuses/codes.json'\nimport { ResponseTransformer } from '../response'\n\n/**\n * Sets a response status code and text.\n * @example\n * res(ctx.status(301))\n * res(ctx.status(400, 'Custom status text'))\n * @see {@link https://mswjs.io/docs/api/context/status `ctx.status()`}\n */\nexport const status = (\n  statusCode: number,\n  statusText?: string,\n): ResponseTransformer => {\n  return (res) => {\n    res.status = statusCode\n    res.statusText =\n      statusText || statuses[String(statusCode) as keyof typeof statuses]\n\n    return res\n  }\n}\n","import { objectToHeaders } from 'headers-polyfill'\nimport { ResponseTransformer } from '../response'\n\nexport type HeadersObject<KeyType extends string = string> = Record<\n  KeyType,\n  string | string[]\n>\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\n */\nexport type ForbiddenHeaderNames =\n  | 'cookie'\n  | 'cookie2'\n  | 'set-cookie'\n  | 'set-cookie2'\n\nexport type ForbiddenHeaderError<HeaderName extends string> =\n  `SafeResponseHeader: the '${HeaderName}' header cannot be set on the response. Please use the 'ctx.cookie()' function instead.`\n\n/**\n * Sets one or multiple response headers.\n * @example\n * ctx.set('Content-Type', 'text/plain')\n * ctx.set({\n *   'Accept': 'application/javascript',\n *   'Content-Type': \"text/plain\"\n * })\n * @see {@link https://mswjs.io/docs/api/context/set `ctx.set()`}\n */\nexport function set<N extends string | HeadersObject>(\n  ...args: N extends string\n    ? Lowercase<N> extends ForbiddenHeaderNames\n      ? ForbiddenHeaderError<N>\n      : [N, string]\n    : N extends HeadersObject<infer CookieName>\n    ? Lowercase<CookieName> extends ForbiddenHeaderNames\n      ? ForbiddenHeaderError<CookieName>\n      : [N]\n    : [N]\n): ResponseTransformer {\n  return (res) => {\n    const [name, value] = args\n\n    if (typeof name === 'string') {\n      res.headers.append(name, value as string)\n    } else {\n      const headers = objectToHeaders(name)\n      headers.forEach((value, name) => {\n        res.headers.append(name, value)\n      })\n    }\n\n    return res\n  }\n}\n","import * as cookieUtils from 'cookie'\nimport { ResponseTransformer } from '../response'\n\n/**\n * Sets a given cookie on the mocked response.\n * @example res(ctx.cookie('name', 'value'))\n */\nexport const cookie = (\n  name: string,\n  value: string,\n  options?: cookieUtils.CookieSerializeOptions,\n): ResponseTransformer => {\n  return (res) => {\n    const serializedCookie = cookieUtils.serialize(name, value, options)\n    res.headers.append('Set-Cookie', serializedCookie)\n\n    if (typeof document !== 'undefined') {\n      document.cookie = serializedCookie\n    }\n\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets a raw response body. Does not append any `Content-Type` headers.\n * @example\n * res(ctx.body('Successful response'))\n * res(ctx.body(JSON.stringify({ key: 'value' })))\n * @see {@link https://mswjs.io/docs/api/context/body `ctx.body()`}\n */\nexport const body = <\n  BodyType extends string | Blob | BufferSource | ReadableStream | FormData,\n>(\n  value: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.body = value\n    return res\n  }\n}\n","/**\n * Parses a given value into a JSON.\n * Does not throw an exception on an invalid JSON string.\n */\nexport function jsonParse<ValueType extends Record<string, any>>(\n  value: any,\n): ValueType | undefined {\n  try {\n    return JSON.parse(value)\n  } catch (error) {\n    return undefined\n  }\n}\n","/**\n * Determines if the given value is an object.\n */\nexport function isObject(value: any): boolean {\n  return value != null && typeof value === 'object' && !Array.isArray(value)\n}\n","import { isObject } from './isObject'\n\n/**\n * Deeply merges two given objects with the right one\n * having a priority during property assignment.\n */\nexport function mergeRight(\n  left: Record<string, any>,\n  right: Record<string, any>,\n) {\n  return Object.entries(right).reduce((result, [key, rightValue]) => {\n    const leftValue = result[key]\n\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue)\n      return result\n    }\n\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue)\n      return result\n    }\n\n    result[key] = rightValue\n    return result\n  }, Object.assign({}, left))\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets the given value as the JSON body of the response.\n * Appends a `Content-Type: application/json` header on the\n * mocked response.\n * @example\n * res(ctx.json('Some string'))\n * res(ctx.json({ key: 'value' }))\n * res(ctx.json([1, '2', false, { ok: true }]))\n * @see {@link https://mswjs.io/docs/api/context/json `ctx.json()`}\n */\nexport const json = <BodyTypeJSON>(\n  body: BodyTypeJSON,\n): ResponseTransformer<BodyTypeJSON> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'application/json')\n    res.body = JSON.stringify(body) as any\n\n    return res\n  }\n}\n","import { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\nimport { GraphQLPayloadContext } from '../typeUtils'\n\n/**\n * Sets a given payload as a GraphQL response body.\n * @example\n * res(ctx.data({ user: { firstName: 'John' }}))\n * @see {@link https://mswjs.io/docs/api/context/data `ctx.data()`}\n */\nexport const data: GraphQLPayloadContext<Record<string, unknown>> = (\n  payload,\n) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { data: payload })\n\n    return json(nextBody)(res)\n  }\n}\n","import { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\nimport { GraphQLPayloadContext } from '../typeUtils'\n\n/**\n * Sets the GraphQL extensions on a given response.\n * @example\n * res(ctx.extensions({ tracing: { version: 1 }}))\n * @see {@link https://mswjs.io/docs/api/context/extensions `ctx.extensions()`}\n */\nexport const extensions: GraphQLPayloadContext<Record<string, unknown>> = (\n  payload,\n) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { extensions: payload })\n    return json(nextBody)(res)\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { ResponseTransformer } from '../response'\n\nexport const SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647\nexport const MIN_SERVER_RESPONSE_TIME = 100\nexport const MAX_SERVER_RESPONSE_TIME = 400\nexport const NODE_SERVER_RESPONSE_TIME = 5\n\nconst getRandomServerResponseTime = () => {\n  if (isNodeProcess()) {\n    return NODE_SERVER_RESPONSE_TIME\n  }\n\n  return Math.floor(\n    Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) +\n      MIN_SERVER_RESPONSE_TIME,\n  )\n}\n\nexport type DelayMode = 'real' | 'infinite'\n\n/**\n * Delays the response by the given duration (ms).\n * @example\n * res(ctx.delay(1200)) // delay response by 1200ms\n * res(ctx.delay()) // emulate realistic server response time\n * res(ctx.delay('infinite')) // delay response infinitely\n * @see {@link https://mswjs.io/docs/api/context/delay `ctx.delay()`}\n */\nexport const delay = (\n  durationOrMode?: DelayMode | number,\n): ResponseTransformer => {\n  return (res) => {\n    let delayTime: number\n\n    if (typeof durationOrMode === 'string') {\n      switch (durationOrMode) {\n        case 'infinite': {\n          // Using `Infinity` as a delay value executes the response timeout immediately.\n          // Instead, use the maximum allowed integer for `setTimeout`.\n          delayTime = SET_TIMEOUT_MAX_ALLOWED_INT\n          break\n        }\n        case 'real': {\n          delayTime = getRandomServerResponseTime()\n          break\n        }\n        default: {\n          throw new Error(\n            `Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number to \"ctx.delay\".`,\n          )\n        }\n      }\n    } else if (typeof durationOrMode === 'undefined') {\n      // Use random realistic server response time when no explicit delay duration was provided.\n      delayTime = getRandomServerResponseTime()\n    } else {\n      // Guard against passing values like `Infinity` or `Number.MAX_VALUE`\n      // as the response delay duration. They don't produce the result you may expect.\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(\n          `Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`,\n        )\n      }\n\n      delayTime = durationOrMode\n    }\n\n    res.delay = delayTime\n    return res\n  }\n}\n","import { GraphQLError } from 'graphql'\nimport { ResponseTransformer } from '../response'\nimport { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\n\n/**\n * Sets a given list of GraphQL errors on the mocked response.\n * @example res(ctx.errors([{ message: 'Unauthorized' }]))\n * @see {@link https://mswjs.io/docs/api/context/errors}\n */\nexport const errors = <\n  ErrorsType extends readonly Partial<GraphQLError>[] | null | undefined,\n>(\n  errorsList: ErrorsType,\n): ResponseTransformer<string> => {\n  return (res) => {\n    if (errorsList == null) {\n      return res\n    }\n\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { errors: errorsList })\n\n    return json(nextBody)(res as any) as any\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { Headers } from 'headers-polyfill'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nconst useFetch: (input: RequestInfo, init?: RequestInit) => Promise<Response> =\n  isNodeProcess() ? require('node-fetch') : window.fetch\n\nexport const augmentRequestInit = (requestInit: RequestInit): RequestInit => {\n  const headers = new Headers(requestInit.headers)\n  headers.set('x-msw-bypass', 'true')\n\n  return {\n    ...requestInit,\n    headers: headers.all(),\n  }\n}\n\nconst createFetchRequestParameters = (input: MockedRequest): RequestInit => {\n  const { body, method } = input\n  const requestParameters: RequestInit = {\n    ...input,\n    body: undefined,\n  }\n\n  if (['GET', 'HEAD'].includes(method)) {\n    return requestParameters\n  }\n\n  if (\n    typeof body === 'object' ||\n    typeof body === 'number' ||\n    typeof body === 'boolean'\n  ) {\n    requestParameters.body = JSON.stringify(body)\n  } else {\n    requestParameters.body = body\n  }\n\n  return requestParameters\n}\n\n/**\n * Performs a bypassed request inside a request handler.\n * @example\n * const originalResponse = await ctx.fetch(req)\n * @see {@link https://mswjs.io/docs/api/context/fetch `ctx.fetch()`}\n */\nexport const fetch = (\n  input: string | MockedRequest,\n  requestInit: RequestInit = {},\n): Promise<Response> => {\n  if (typeof input === 'string') {\n    return useFetch(input, augmentRequestInit(requestInit))\n  }\n\n  const requestParameters = createFetchRequestParameters(input)\n  const derivedRequestInit = augmentRequestInit(requestParameters)\n\n  return useFetch(input.url.href, derivedRequestInit)\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets a textual response body. Appends a `Content-Type: text/plain`\n * header on the mocked response.\n * @example res(ctx.text('Successful response'))\n * @see {@link https://mswjs.io/docs/api/context/text `ctx.text()`}\n */\nexport const text = <BodyType extends string>(\n  body: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'text/plain')\n    res.body = body\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets an XML response body. Appends a `Content-Type: text/xml` header\n * on the mocked response.\n * @example\n * res(ctx.xml('<node key=\"value\">Content</node>'))\n * @see {@link https://mswjs.io/docs/api/context/xml `ctx.xml()`}\n */\nexport const xml = <BodyType extends string>(\n  body: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'text/xml')\n    res.body = body\n    return res\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { StrictEventEmitter } from 'strict-event-emitter'\nimport {\n  SetupWorkerInternalContext,\n  SetupWorkerApi,\n  ServiceWorkerIncomingEventsMap,\n  WorkerLifecycleEventsMap,\n} from './glossary'\nimport { createStartHandler } from './start/createStartHandler'\nimport { createStop } from './stop/createStop'\nimport * as requestHandlerUtils from '../utils/internal/requestHandlerUtils'\nimport { ServiceWorkerMessage } from './start/utils/createMessageChannel'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { RestHandler } from '../handlers/RestHandler'\nimport { prepareStartHandler } from './start/utils/prepareStartHandler'\nimport { createFallbackStart } from './start/createFallbackStart'\nimport { createFallbackStop } from './stop/createFallbackStop'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { pipeEvents } from '../utils/internal/pipeEvents'\n\ninterface Listener {\n  target: EventTarget\n  eventType: string\n  callback: EventListener\n}\n\n// Declare the list of event handlers on the module's scope\n// so it persists between Fash refreshes of the application's code.\nlet listeners: Listener[] = []\n\n/**\n * Creates a new mock Service Worker registration\n * with the given request handlers.\n * @param {RequestHandler[]} requestHandlers List of request handlers\n * @see {@link https://mswjs.io/docs/api/setup-worker `setupWorker`}\n */\nexport function setupWorker(\n  ...requestHandlers: RequestHandler[]\n): SetupWorkerApi {\n  requestHandlers.forEach((handler) => {\n    if (Array.isArray(handler))\n      throw new Error(\n        devUtils.formatMessage(\n          'Failed to call \"setupWorker\" given an Array of request handlers (setupWorker([a, b])), expected to receive each handler individually: setupWorker(a, b).',\n        ),\n      )\n  })\n\n  // Error when attempting to run this function in a Node.js environment.\n  if (isNodeProcess()) {\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.',\n      ),\n    )\n  }\n\n  const emitter = new StrictEventEmitter<WorkerLifecycleEventsMap>()\n  const publicEmitter = new StrictEventEmitter<WorkerLifecycleEventsMap>()\n  pipeEvents(emitter, publicEmitter)\n\n  const context: SetupWorkerInternalContext = {\n    // Mocking is not considered enabled until the worker\n    // signals back the successful activation event.\n    isMockingEnabled: false,\n    startOptions: undefined,\n    worker: null,\n    registration: null,\n    requestHandlers: [...requestHandlers],\n    emitter,\n    workerChannel: {\n      on(eventType, callback) {\n        context.events.addListener(\n          navigator.serviceWorker,\n          'message',\n          (event: MessageEvent) => {\n            // Avoid messages broadcasted from unrelated workers.\n            if (event.source !== context.worker) {\n              return\n            }\n\n            const message = event.data as ServiceWorkerMessage<\n              typeof eventType,\n              any\n            >\n\n            if (!message) {\n              return\n            }\n\n            if (message.type === eventType) {\n              callback(event, message)\n            }\n          },\n        )\n      },\n      send(type) {\n        context.worker?.postMessage(type)\n      },\n    },\n    events: {\n      addListener(\n        target: EventTarget,\n        eventType: string,\n        callback: EventListener,\n      ) {\n        target.addEventListener(eventType, callback)\n        listeners.push({ eventType, target, callback })\n\n        return () => {\n          target.removeEventListener(eventType, callback)\n        }\n      },\n      removeAllListeners() {\n        for (const { target, eventType, callback } of listeners) {\n          target.removeEventListener(eventType, callback)\n        }\n        listeners = []\n      },\n      once(eventType) {\n        const bindings: Array<() => void> = []\n\n        return new Promise<\n          ServiceWorkerMessage<\n            typeof eventType,\n            ServiceWorkerIncomingEventsMap[typeof eventType]\n          >\n        >((resolve, reject) => {\n          const handleIncomingMessage = (event: MessageEvent) => {\n            try {\n              const message = event.data\n\n              if (message.type === eventType) {\n                resolve(message)\n              }\n            } catch (error) {\n              reject(error)\n            }\n          }\n\n          bindings.push(\n            context.events.addListener(\n              navigator.serviceWorker,\n              'message',\n              handleIncomingMessage,\n            ),\n            context.events.addListener(\n              navigator.serviceWorker,\n              'messageerror',\n              reject,\n            ),\n          )\n        }).finally(() => {\n          bindings.forEach((unbind) => unbind())\n        })\n      },\n    },\n    useFallbackMode:\n      !('serviceWorker' in navigator) || location.protocol === 'file:',\n  }\n\n  const startHandler = context.useFallbackMode\n    ? createFallbackStart(context)\n    : createStartHandler(context)\n  const stopHandler = context.useFallbackMode\n    ? createFallbackStop(context)\n    : createStop(context)\n\n  return {\n    start: prepareStartHandler(startHandler, context),\n    stop() {\n      context.events.removeAllListeners()\n      context.emitter.removeAllListeners()\n      publicEmitter.removeAllListeners()\n      stopHandler()\n    },\n\n    use(...handlers) {\n      requestHandlerUtils.use(context.requestHandlers, ...handlers)\n    },\n\n    restoreHandlers() {\n      requestHandlerUtils.restoreHandlers(context.requestHandlers)\n    },\n\n    resetHandlers(...nextHandlers) {\n      context.requestHandlers = requestHandlerUtils.resetHandlers(\n        requestHandlers,\n        ...nextHandlers,\n      )\n    },\n\n    printHandlers() {\n      context.requestHandlers.forEach((handler) => {\n        const { header, callFrame } = handler.info\n        const pragma = handler.info.hasOwnProperty('operationType')\n          ? '[graphql]'\n          : '[rest]'\n\n        console.groupCollapsed(`${pragma} ${header}`)\n\n        if (callFrame) {\n          console.log(`Declaration: ${callFrame}`)\n        }\n\n        console.log('Handler:', handler)\n\n        if (handler instanceof RestHandler) {\n          console.log(\n            'Match:',\n            `https://mswjs.io/repl?path=${handler.info.path}`,\n          )\n        }\n\n        console.groupEnd()\n      })\n    },\n\n    events: {\n      on(...args) {\n        return publicEmitter.on(...args)\n      },\n      removeListener(...args) {\n        return publicEmitter.removeListener(...args)\n      },\n      removeAllListeners(...args) {\n        return publicEmitter.removeAllListeners(...args)\n      },\n    },\n  }\n}\n","import { until } from '@open-draft/until'\nimport { getWorkerInstance } from './utils/getWorkerInstance'\nimport { enableMocking } from './utils/enableMocking'\nimport { SetupWorkerInternalContext, StartHandler } from '../glossary'\nimport { createRequestListener } from './createRequestListener'\nimport { requestIntegrityCheck } from '../../utils/internal/requestIntegrityCheck'\nimport { deferNetworkRequestsUntil } from '../../utils/deferNetworkRequestsUntil'\nimport { createResponseListener } from './createResponseListener'\nimport { validateWorkerScope } from './utils/validateWorkerScope'\nimport { devUtils } from '../../utils/internal/devUtils'\n\nexport const createStartHandler = (\n  context: SetupWorkerInternalContext,\n): StartHandler => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      // Remove all previously existing event listeners.\n      // This way none of the listeners persists between Fast refresh\n      // of the application's code.\n      context.events.removeAllListeners()\n\n      // Handle requests signaled by the worker.\n      context.workerChannel.on(\n        'REQUEST',\n        createRequestListener(context, options),\n      )\n\n      // Handle responses signaled by the worker.\n      context.workerChannel.on('RESPONSE', createResponseListener(context))\n\n      const instance = await getWorkerInstance(\n        options.serviceWorker.url,\n        options.serviceWorker.options,\n        options.findWorker,\n      )\n\n      const [worker, registration] = instance\n\n      if (!worker) {\n        const missingWorkerMessage = customOptions?.findWorker\n          ? devUtils.formatMessage(\n              `Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`,\n              options.serviceWorker.url,\n            )\n          : devUtils.formatMessage(\n              `Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,\n              options.serviceWorker.url,\n              location.host,\n            )\n\n        throw new Error(missingWorkerMessage)\n      }\n\n      context.worker = worker\n      context.registration = registration\n\n      context.events.addListener(window, 'beforeunload', () => {\n        if (worker.state !== 'redundant') {\n          // Notify the Service Worker that this client has closed.\n          // Internally, it's similar to disabling the mocking, only\n          // client close event has a handler that self-terminates\n          // the Service Worker when there are no open clients.\n          context.workerChannel.send('CLIENT_CLOSED')\n        }\n        // Make sure we're always clearing the interval - there are reports that not doing this can\n        // cause memory leaks in headless browser environments.\n        window.clearInterval(context.keepAliveInterval)\n      })\n\n      // Check if the active Service Worker is the latest published one\n      const [integrityError] = await until(() =>\n        requestIntegrityCheck(context, worker),\n      )\n\n      if (integrityError) {\n        devUtils.error(`\\\nDetected outdated Service Worker: ${integrityError.message}\n\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\n\n$ npx msw init <PUBLIC_DIR>\n\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues\\\n      `)\n      }\n\n      context.keepAliveInterval = window.setInterval(\n        () => context.workerChannel.send('KEEPALIVE_REQUEST'),\n        5000,\n      )\n\n      // Warn the user when loading the page that lies outside\n      // of the worker's scope.\n      validateWorkerScope(registration, context.startOptions)\n\n      return registration\n    }\n\n    const workerRegistration = startWorkerInstance().then(\n      async (registration) => {\n        const pendingInstance = registration.installing || registration.waiting\n\n        // Wait until the worker is activated.\n        // Assume the worker is already activated if there's no pending registration\n        // (i.e. when reloading the page after a successful activation).\n        if (pendingInstance) {\n          await new Promise<void>((resolve) => {\n            pendingInstance.addEventListener('statechange', () => {\n              if (pendingInstance.state === 'activated') {\n                return resolve()\n              }\n            })\n          })\n        }\n\n        // Print the activation message only after the worker has been activated.\n        await enableMocking(context, options).catch((error) => {\n          throw new Error(`Failed to enable mocking: ${error?.message}`)\n        })\n\n        return registration\n      },\n    )\n\n    // Defer any network requests until the Service Worker instance is ready.\n    // This prevents a race condition between the Service Worker registration\n    // and application's runtime requests (i.e. requests on mount).\n    if (options.waitUntilReady) {\n      deferNetworkRequestsUntil(workerRegistration)\n    }\n\n    return workerRegistration\n  }\n}\n","import { until } from '@open-draft/until'\nimport { getWorkerByRegistration } from './getWorkerByRegistration'\nimport { ServiceWorkerInstanceTuple, FindWorker } from '../../glossary'\nimport { getAbsoluteWorkerUrl } from '../../../utils/url/getAbsoluteWorkerUrl'\nimport { devUtils } from '../../../utils/internal/devUtils'\n\n/**\n * Returns an active Service Worker instance.\n * When not found, registers a new Service Worker.\n */\nexport const getWorkerInstance = async (\n  url: string,\n  options: RegistrationOptions = {},\n  findWorker: FindWorker,\n): Promise<ServiceWorkerInstanceTuple> => {\n  // Resolve the absolute Service Worker URL.\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url)\n\n  const mockRegistrations = await navigator.serviceWorker\n    .getRegistrations()\n    .then((registrations) =>\n      registrations.filter((registration) =>\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n      ),\n    )\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    // Reload the page when it has associated workers, but no active controller.\n    // The absence of a controller can mean either:\n    // - page has no Service Worker associated with it\n    // - page has been hard-reloaded and its workers won't be used until the next reload.\n    // Since we've checked that there are registrations associated with this page,\n    // at this point we are sure it's hard reload that falls into this clause.\n    location.reload()\n  }\n\n  const [existingRegistration] = mockRegistrations\n\n  if (existingRegistration) {\n    // When the Service Worker is registered, update it and return the reference.\n    return existingRegistration.update().then(() => {\n      return [\n        getWorkerByRegistration(\n          existingRegistration,\n          absoluteWorkerUrl,\n          findWorker,\n        ),\n        existingRegistration,\n      ]\n    })\n  }\n\n  // When the Service Worker wasn't found, register it anew and return the reference.\n  const [error, instance] = await until<ServiceWorkerInstanceTuple>(\n    async () => {\n      const registration = await navigator.serviceWorker.register(url, options)\n      return [\n        // Compare existing worker registration by its worker URL,\n        // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n        registration,\n      ]\n    },\n  )\n\n  // Handle Service Worker registration errors.\n  if (error) {\n    const isWorkerMissing = error.message.includes('(404)')\n\n    // Produce a custom error message when given a non-existing Service Worker url.\n    // Suggest developers to check their setup.\n    if (isWorkerMissing) {\n      const scopeUrl = new URL(options?.scope || '/', location.href)\n\n      throw new Error(\n        devUtils.formatMessage(`\\\nFailed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`),\n      )\n    }\n\n    // Fallback error message for any other registration errors.\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to register the Service Worker:\\n\\n%s',\n        error.message,\n      ),\n    )\n  }\n\n  return instance\n}\n","import { FindWorker } from '../../glossary'\n\n/**\n * Attempts to resolve a Service Worker instance from a given registration,\n * regardless of its state (active, installing, waiting).\n */\nexport const getWorkerByRegistration = (\n  registration: ServiceWorkerRegistration,\n  absoluteWorkerUrl: string,\n  findWorker: FindWorker,\n): ServiceWorker | null => {\n  const allStates = [\n    registration.active,\n    registration.installing,\n    registration.waiting,\n  ]\n  const existingStates = allStates.filter(Boolean) as ServiceWorker[]\n  const mockWorker = existingStates.find((worker) => {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl)\n  })\n\n  return mockWorker || null\n}\n","/**\n * Returns an absolute Service Worker URL based on the given\n * relative URL (known during the registration).\n */\nexport function getAbsoluteWorkerUrl(relativeUrl: string): string {\n  return new URL(relativeUrl, location.origin).href\n}\n","import { format } from 'outvariant'\n\nconst LIBRARY_PREFIX = '[MSW]'\n\n/**\n * Formats a given message by appending the library's prefix string.\n */\nfunction formatMessage(message: string, ...positionals: any[]): string {\n  const interpolatedMessage = format(message, ...positionals)\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`\n}\n\n/**\n * Prints a library-specific warning.\n */\nfunction warn(message: string, ...positionals: any[]): void {\n  console.warn(formatMessage(message, ...positionals))\n}\n\n/**\n * Prints a library-specific error.\n */\nfunction error(message: string, ...positionals: any[]): void {\n  console.error(formatMessage(message, ...positionals))\n}\n\nexport const devUtils = {\n  formatMessage,\n  warn,\n  error,\n}\n","import { devUtils } from '../../../utils/internal/devUtils'\n\nexport interface PrintStartMessageArgs {\n  quiet?: boolean\n  message?: string\n  workerUrl?: string\n  workerScope?: string\n}\n\n/**\n * Prints a worker activation message in the browser's console.\n */\nexport function printStartMessage(args: PrintStartMessageArgs = {}) {\n  if (args.quiet) {\n    return\n  }\n\n  const message = args.message || 'Mocking enabled.'\n\n  console.groupCollapsed(\n    `%c${devUtils.formatMessage(message)}`,\n    'color:orangered;font-weight:bold;',\n  )\n  console.log(\n    '%cDocumentation: %chttps://mswjs.io/docs',\n    'font-weight:bold',\n    'font-weight:normal',\n  )\n  console.log('Found an issue? https://github.com/mswjs/msw/issues')\n\n  if (args.workerUrl) {\n    console.log('Worker script URL:', args.workerUrl)\n  }\n\n  if (args.workerScope) {\n    console.log('Worker scope:', args.workerScope)\n  }\n\n  console.groupEnd()\n}\n","import { devUtils } from '../../../utils/internal/devUtils'\nimport { StartOptions, SetupWorkerInternalContext } from '../../glossary'\nimport { printStartMessage } from './printStartMessage'\n\n/**\n * Signals the worker to enable the interception of requests.\n */\nexport async function enableMocking(\n  context: SetupWorkerInternalContext,\n  options: StartOptions,\n) {\n  context.workerChannel.send('MOCK_ACTIVATE')\n  await context.events.once('MOCKING_ENABLED')\n\n  // Warn the developer on multiple \"worker.start()\" calls.\n  // While this will not affect the worker in any way,\n  // it likely indicates an issue with the developer's code.\n  if (context.isMockingEnabled) {\n    devUtils.warn(\n      `Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`,\n    )\n    return\n  }\n\n  context.isMockingEnabled = true\n\n  printStartMessage({\n    quiet: options.quiet,\n    workerScope: context.registration?.scope,\n    workerUrl: context.worker?.scriptURL,\n  })\n}\n","import {\n  SerializedResponse,\n  ServiceWorkerIncomingEventsMap,\n} from '../../glossary'\n\nexport interface ServiceWorkerMessage<\n  EventType extends keyof ServiceWorkerIncomingEventsMap,\n  EventPayload,\n> {\n  type: EventType\n  payload: EventPayload\n}\n\ninterface WorkerChannelEventsMap {\n  MOCK_RESPONSE: [data: SerializedResponse<any>, body?: [ArrayBuffer]]\n  NOT_FOUND: []\n  NETWORK_ERROR: [data: { name: string; message: string }]\n}\n\nexport class WorkerChannel {\n  constructor(private readonly port: MessagePort) {}\n\n  public postMessage<Event extends keyof WorkerChannelEventsMap>(\n    event: Event,\n    ...rest: WorkerChannelEventsMap[Event]\n  ): void {\n    const [data, transfer] = rest\n    this.port.postMessage({ type: event, data }, { transfer })\n  }\n}\n","export class NetworkError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'NetworkError'\n  }\n}\n","import { encodeBuffer } from '@mswjs/interceptors'\nimport { Headers } from 'headers-polyfill'\nimport { ServiceWorkerIncomingRequest } from '../../setupWorker/glossary'\nimport { MockedRequest } from './MockedRequest'\n\n/**\n * Converts a given request received from the Service Worker\n * into a `MockedRequest` instance.\n */\nexport function parseWorkerRequest(\n  rawRequest: ServiceWorkerIncomingRequest,\n): MockedRequest {\n  const url = new URL(rawRequest.url)\n  const headers = new Headers(rawRequest.headers)\n\n  return new MockedRequest(url, {\n    ...rawRequest,\n    body: encodeBuffer(rawRequest.body || ''),\n    headers,\n  })\n}\n","import * as cookieUtils from 'cookie'\nimport { store } from '@mswjs/cookies'\nimport { IsomorphicRequest, RequestInit } from '@mswjs/interceptors'\nimport { decodeBuffer } from '@mswjs/interceptors/lib/utils/bufferUtils'\nimport { Headers } from 'headers-polyfill/lib'\nimport { DefaultBodyType } from '../../handlers/RequestHandler'\nimport { MockedResponse } from '../../response'\nimport { getRequestCookies } from './getRequestCookies'\nimport { parseBody } from './parseBody'\nimport { isStringEqual } from '../internal/isStringEqual'\n\nexport type RequestCache =\n  | 'default'\n  | 'no-store'\n  | 'reload'\n  | 'no-cache'\n  | 'force-cache'\n  | 'only-if-cached'\n\nexport type RequestMode = 'navigate' | 'same-origin' | 'no-cors' | 'cors'\n\nexport type RequestRedirect = 'follow' | 'error' | 'manual'\n\nexport type RequestDestination =\n  | ''\n  | 'audio'\n  | 'audioworklet'\n  | 'document'\n  | 'embed'\n  | 'font'\n  | 'frame'\n  | 'iframe'\n  | 'image'\n  | 'manifest'\n  | 'object'\n  | 'paintworklet'\n  | 'report'\n  | 'script'\n  | 'sharedworker'\n  | 'style'\n  | 'track'\n  | 'video'\n  | 'xslt'\n  | 'worker'\n\nexport type RequestPriority = 'high' | 'low' | 'auto'\n\nexport type RequestReferrerPolicy =\n  | ''\n  | 'no-referrer'\n  | 'no-referrer-when-downgrade'\n  | 'origin'\n  | 'origin-when-cross-origin'\n  | 'same-origin'\n  | 'strict-origin'\n  | 'strict-origin-when-cross-origin'\n  | 'unsafe-url'\n\nexport interface MockedRequestInit extends RequestInit {\n  id?: string\n  cache?: RequestCache\n  redirect?: RequestRedirect\n  integrity?: string\n  keepalive?: boolean\n  mode?: RequestMode\n  priority?: RequestPriority\n  destination?: RequestDestination\n  referrer?: string\n  referrerPolicy?: RequestReferrerPolicy\n  cookies?: Record<string, string>\n}\n\nexport class MockedRequest<\n  RequestBody extends DefaultBodyType = DefaultBodyType,\n> extends IsomorphicRequest {\n  public readonly cache: RequestCache\n  public readonly cookies: Record<string, string>\n  public readonly destination: RequestDestination\n  public readonly integrity: string\n  public readonly keepalive: boolean\n  public readonly mode: RequestMode\n  public readonly priority: RequestPriority\n  public readonly redirect: RequestRedirect\n  public readonly referrer: string\n  public readonly referrerPolicy: RequestReferrerPolicy\n\n  constructor(url: URL, init: MockedRequestInit = {}) {\n    super(url, init)\n    if (init.id) {\n      this.id = init.id\n    }\n    this.cache = init.cache || 'default'\n    this.destination = init.destination || ''\n    this.integrity = init.integrity || ''\n    this.keepalive = init.keepalive || false\n    this.mode = init.mode || 'cors'\n    this.priority = init.priority || 'auto'\n    this.redirect = init.redirect || 'follow'\n    this.referrer = init.referrer || ''\n    this.referrerPolicy = init.referrerPolicy || 'no-referrer'\n    this.cookies = init.cookies || this.getCookies()\n  }\n\n  /**\n   * Get parsed request body. The type is inferred from the content type.\n   *\n   * @deprecated - Use `req.text()`, `req.json()` or `req.arrayBuffer()`\n   * to read the request body as a plain text, JSON, or ArrayBuffer.\n   */\n  public get body(): RequestBody {\n    const text = decodeBuffer(this['_body'])\n\n    /**\n     * @deprecated https://github.com/mswjs/msw/issues/1318\n     * @fixme Remove this assumption and let the users read\n     * request body explicitly using \".json()\"/\".text()\"/\".arrayBuffer()\".\n     */\n    // Parse the request's body based on the \"Content-Type\" header.\n    const body = parseBody(text, this.headers)\n\n    if (isStringEqual(this.method, 'GET') && body === '') {\n      return undefined as RequestBody\n    }\n\n    return body as RequestBody\n  }\n\n  /**\n   * Bypass the intercepted request.\n   * This will make a call to the actual endpoint requested.\n   */\n  public passthrough(): MockedResponse<null> {\n    return {\n      // Constructing a dummy \"101 Continue\" mocked response\n      // to keep the return type of the resolver consistent.\n      status: 101,\n      statusText: 'Continue',\n      headers: new Headers(),\n      body: null,\n      // Setting \"passthrough\" to true will signal the response pipeline\n      // to perform this intercepted request as-is.\n      passthrough: true,\n      once: false,\n    }\n  }\n\n  private getCookies(): Record<string, string> {\n    // Parse the cookies passed in the original request \"cookie\" header.\n    const requestCookiesString = this.headers.get('cookie')\n    const ownCookies = requestCookiesString\n      ? cookieUtils.parse(requestCookiesString)\n      : {}\n\n    store.hydrate()\n\n    const cookiesFromStore = Array.from(\n      store.get({ ...this, url: this.url.href })?.entries(),\n    ).reduce((cookies, [name, { value }]) => {\n      return Object.assign(cookies, { [name.trim()]: value })\n    }, {})\n\n    // Get existing document cookies that are applicable\n    // to this request based on its \"credentials\" policy.\n    const cookiesFromDocument = getRequestCookies(this)\n\n    const forwardedCookies = {\n      ...cookiesFromDocument,\n      ...cookiesFromStore,\n    }\n\n    for (const [name, value] of Object.entries(forwardedCookies)) {\n      this.headers.append('cookie', `${name}=${value}`)\n    }\n\n    return {\n      ...forwardedCookies,\n      ...ownCookies,\n    }\n  }\n}\n","import * as cookieUtils from 'cookie'\nimport { MockedRequest } from './MockedRequest'\n\nfunction getAllCookies() {\n  return cookieUtils.parse(document.cookie)\n}\n\n/**\n * Returns relevant document cookies based on the request `credentials` option.\n */\nexport function getRequestCookies(request: MockedRequest) {\n  /**\n   * @note No cookies persist on the document in Node.js: no document.\n   */\n  if (typeof document === 'undefined' || typeof location === 'undefined') {\n    return {}\n  }\n\n  switch (request.credentials) {\n    case 'same-origin': {\n      // Return document cookies only when requested a resource\n      // from the same origin as the current document.\n      return location.origin === request.url.origin ? getAllCookies() : {}\n    }\n\n    case 'include': {\n      // Return all document cookies.\n      return getAllCookies()\n    }\n\n    default: {\n      return {}\n    }\n  }\n}\n","import { stringToHeaders } from 'headers-polyfill'\nimport { DefaultRequestMultipartBody } from '../../handlers/RequestHandler'\n\ninterface ParsedContentHeaders {\n  name: string\n  filename?: string\n  contentType: string\n}\n\ninterface ContentDispositionDirective {\n  [key: string]: string | undefined\n  name: string\n  filename?: string\n  'form-data': string\n}\n\nfunction parseContentHeaders(headersString: string): ParsedContentHeaders {\n  const headers = stringToHeaders(headersString)\n  const contentType = headers.get('content-type') || 'text/plain'\n  const disposition = headers.get('content-disposition')\n\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.')\n  }\n\n  const directives = disposition.split(';').reduce((acc, chunk) => {\n    const [name, ...rest] = chunk.trim().split('=')\n    acc[name] = rest.join('=')\n    return acc\n  }, {} as ContentDispositionDirective)\n\n  const name = directives.name?.slice(1, -1)\n  const filename = directives.filename?.slice(1, -1)\n\n  return {\n    name,\n    filename,\n    contentType,\n  }\n}\n\n/**\n * Parses a given string as a multipart/form-data.\n * Does not throw an exception on an invalid multipart string.\n */\nexport function parseMultipartData<T extends DefaultRequestMultipartBody>(\n  data: string,\n  headers?: Headers,\n): T | undefined {\n  const contentType = headers?.get('content-type')\n\n  if (!contentType) {\n    return undefined\n  }\n\n  const [, ...directives] = contentType.split(/; */)\n  const boundary = directives\n    .filter((d) => d.startsWith('boundary='))\n    .map((s) => s.replace(/^boundary=/, ''))[0]\n\n  if (!boundary) {\n    return undefined\n  }\n\n  const boundaryRegExp = new RegExp(`--+${boundary}`)\n  const fields = data\n    .split(boundaryRegExp)\n    .filter((chunk) => chunk.startsWith('\\r\\n') && chunk.endsWith('\\r\\n'))\n    .map((chunk) => chunk.trimStart().replace(/\\r\\n$/, ''))\n\n  if (!fields.length) {\n    return undefined\n  }\n\n  const parsedBody: DefaultRequestMultipartBody = {}\n\n  try {\n    for (const field of fields) {\n      const [contentHeaders, ...rest] = field.split('\\r\\n\\r\\n')\n      const contentBody = rest.join('\\r\\n\\r\\n')\n      const { contentType, filename, name } =\n        parseContentHeaders(contentHeaders)\n\n      const value =\n        filename === undefined\n          ? contentBody\n          : new File([contentBody], filename, { type: contentType })\n\n      const parsedValue = parsedBody[name]\n\n      if (parsedValue === undefined) {\n        parsedBody[name] = value\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value]\n      } else {\n        parsedBody[name] = [parsedValue, value]\n      }\n    }\n\n    return parsedBody as T\n  } catch (error) {\n    return undefined\n  }\n}\n","import { jsonParse } from '../internal/jsonParse'\nimport { parseMultipartData } from '../internal/parseMultipartData'\nimport { MockedRequest } from './MockedRequest'\n\n/**\n * Parses a given request/response body based on the \"Content-Type\" header.\n */\nexport function parseBody(body?: MockedRequest['body'], headers?: Headers) {\n  // Return whatever falsey body value is given.\n  if (!body) {\n    return body\n  }\n\n  const contentType = headers?.get('content-type')?.toLowerCase() || ''\n\n  // If the body has a Multipart Content-Type\n  // parse it into an object.\n  const hasMultipartContent = contentType.startsWith('multipart/form-data')\n  if (hasMultipartContent && typeof body !== 'object') {\n    return parseMultipartData(body.toString(), headers) || body\n  }\n\n  // If the intercepted request's body has a JSON Content-Type\n  // parse it into an object.\n  const hasJsonContent = contentType.includes('json')\n\n  if (hasJsonContent && typeof body !== 'object') {\n    return jsonParse(body.toString()) || body\n  }\n\n  // Otherwise leave as-is.\n  return body\n}\n","/**\n * Performs a case-insensitive comparison of two given strings.\n */\nexport function isStringEqual(actual: string, expected: string): boolean {\n  return actual.toLowerCase() === expected.toLowerCase()\n}\n","import { until } from '@open-draft/until'\nimport { StrictEventEmitter } from 'strict-event-emitter'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { ServerLifecycleEventsMap } from '../node/glossary'\nimport { MockedResponse } from '../response'\nimport { SharedOptions } from '../sharedOptions'\nimport { RequiredDeep } from '../typeUtils'\nimport { ResponseLookupResult, getResponse } from './getResponse'\nimport { devUtils } from './internal/devUtils'\nimport { MockedRequest } from './request/MockedRequest'\nimport { onUnhandledRequest } from './request/onUnhandledRequest'\nimport { readResponseCookies } from './request/readResponseCookies'\n\nexport interface HandleRequestOptions<ResponseType> {\n  /**\n   * Options for the response resolution process.\n   */\n  resolutionContext?: {\n    baseUrl?: string\n  }\n\n  /**\n   * Transforms a `MockedResponse` instance returned from a handler\n   * to a response instance supported by the lower tooling (i.e. interceptors).\n   */\n  transformResponse?(response: MockedResponse<string>): ResponseType\n\n  /**\n   * Invoked whenever a request is performed as-is.\n   */\n  onPassthroughResponse?(request: MockedRequest): void\n\n  /**\n   * Invoked when the mocked response is ready to be sent.\n   */\n  onMockedResponse?(\n    response: ResponseType,\n    handler: RequiredDeep<ResponseLookupResult>,\n  ): void\n\n  /**\n   * Invoked when the mocked response is sent.\n   * Respects the response delay duration.\n   */\n  onMockedResponseSent?(\n    response: ResponseType,\n    handler: RequiredDeep<ResponseLookupResult>,\n  ): void\n}\n\nexport async function handleRequest<\n  ResponseType extends Record<string, any> = MockedResponse<string>,\n>(\n  request: MockedRequest,\n  handlers: RequestHandler[],\n  options: RequiredDeep<SharedOptions>,\n  emitter: StrictEventEmitter<ServerLifecycleEventsMap>,\n  handleRequestOptions?: HandleRequestOptions<ResponseType>,\n): Promise<ResponseType | undefined> {\n  emitter.emit('request:start', request)\n\n  // Perform bypassed requests (i.e. issued via \"ctx.fetch\") as-is.\n  if (request.headers.get('x-msw-bypass') === 'true') {\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Resolve a mocked response from the list of request handlers.\n  const [lookupError, lookupResult] = await until(() => {\n    return getResponse(\n      request,\n      handlers,\n      handleRequestOptions?.resolutionContext,\n    )\n  })\n\n  if (lookupError) {\n    // Allow developers to react to unhandled exceptions in request handlers.\n    emitter.emit('unhandledException', lookupError, request)\n    throw lookupError\n  }\n\n  const { handler, response } = lookupResult\n\n  // When there's no handler for the request, consider it unhandled.\n  // Allow the developer to react to such cases.\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest)\n    emitter.emit('request:unhandled', request)\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // When the handled request returned no mocked response, warn the developer,\n  // as it may be an oversight on their part. Perform the request as-is.\n  if (!response) {\n    devUtils.warn(\n      `\\\nExpected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\\\n\\n\n  \\u2022 %s\n    %s\\\n`,\n      response,\n      handler.info.header,\n      handler.info.callFrame,\n    )\n\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // When the developer explicitly returned \"req.passthrough()\" do not warn them.\n  // Perform the request as-is.\n  if (response.passthrough) {\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Store all the received response cookies in the virtual cookie store.\n  readResponseCookies(request, response)\n\n  emitter.emit('request:match', request)\n\n  const requiredLookupResult =\n    lookupResult as RequiredDeep<ResponseLookupResult>\n\n  const transformedResponse =\n    handleRequestOptions?.transformResponse?.(response) ||\n    (response as any as ResponseType)\n\n  handleRequestOptions?.onMockedResponse?.(\n    transformedResponse,\n    requiredLookupResult,\n  )\n\n  handleRequestOptions?.onMockedResponseSent?.(\n    transformedResponse,\n    requiredLookupResult,\n  )\n  emitter.emit('request:end', request)\n\n  return transformedResponse\n}\n","import { MockedResponse } from '../response'\nimport {\n  RequestHandler,\n  RequestHandlerExecutionResult,\n} from '../handlers/RequestHandler'\nimport { MockedRequest } from './request/MockedRequest'\n\nexport interface ResponseLookupResult {\n  handler?: RequestHandler\n  publicRequest?: any\n  parsedRequest?: any\n  response?: MockedResponse\n}\n\nexport interface ResponseResolutionContext {\n  baseUrl?: string\n}\n\n/**\n * Returns a mocked response for a given request using following request handlers.\n */\nexport const getResponse = async <\n  Request extends MockedRequest,\n  Handler extends RequestHandler[],\n>(\n  request: Request,\n  handlers: Handler,\n  resolutionContext?: ResponseResolutionContext,\n): Promise<ResponseLookupResult> => {\n  const relevantHandlers = handlers.filter((handler) => {\n    return handler.test(request, resolutionContext)\n  })\n\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: undefined,\n      response: undefined,\n    }\n  }\n\n  const result = await relevantHandlers.reduce<\n    Promise<RequestHandlerExecutionResult<any> | null>\n  >(async (executionResult, handler) => {\n    const previousResults = await executionResult\n\n    if (!!previousResults?.response) {\n      return executionResult\n    }\n\n    const result = await handler.run(request, resolutionContext)\n\n    if (result === null || result.handler.shouldSkip) {\n      return null\n    }\n\n    if (!result.response) {\n      return {\n        request: result.request,\n        handler: result.handler,\n        response: undefined,\n        parsedResult: result.parsedResult,\n      }\n    }\n\n    if (result.response.once) {\n      handler.markAsSkipped(true)\n    }\n\n    return result\n  }, Promise.resolve(null))\n\n  // Although reducing a list of relevant request handlers, it's possible\n  // that in the end there will be no handler associted with the request\n  // (i.e. if relevant handlers are fall-through).\n  if (!result) {\n    return {\n      handler: undefined,\n      response: undefined,\n    }\n  }\n\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response,\n  }\n}\n","import getStringMatchScore from 'js-levenshtein'\nimport {\n  ParsedGraphQLQuery,\n  parseGraphQLRequest,\n} from '../internal/parseGraphQLRequest'\nimport { getPublicUrlFromRequest } from './getPublicUrlFromRequest'\nimport { isStringEqual } from '../internal/isStringEqual'\nimport { RestHandler } from '../../handlers/RestHandler'\nimport { GraphQLHandler } from '../../handlers/GraphQLHandler'\nimport { RequestHandler } from '../../handlers/RequestHandler'\nimport { tryCatch } from '../internal/tryCatch'\nimport { devUtils } from '../internal/devUtils'\nimport { MockedRequest } from './MockedRequest'\n\nconst MAX_MATCH_SCORE = 3\nconst MAX_SUGGESTION_COUNT = 4\nconst TYPE_MATCH_DELTA = 0.5\n\nexport interface UnhandledRequestPrint {\n  warning(): void\n  error(): void\n}\n\nexport type UnhandledRequestCallback = (\n  request: MockedRequest,\n  print: UnhandledRequestPrint,\n) => void\n\nexport type UnhandledRequestStrategy =\n  | 'bypass'\n  | 'warn'\n  | 'error'\n  | UnhandledRequestCallback\n\ninterface RequestHandlerGroups {\n  rest: RestHandler[]\n  graphql: GraphQLHandler[]\n}\n\nfunction groupHandlersByType(handlers: RequestHandler[]): RequestHandlerGroups {\n  return handlers.reduce<RequestHandlerGroups>(\n    (groups, handler) => {\n      if (handler instanceof RestHandler) {\n        groups.rest.push(handler)\n      }\n\n      if (handler instanceof GraphQLHandler) {\n        groups.graphql.push(handler)\n      }\n\n      return groups\n    },\n    {\n      rest: [],\n      graphql: [],\n    },\n  )\n}\n\ntype RequestHandlerSuggestion = [number, RequestHandler]\n\ntype ScoreGetterFn<RequestHandlerType extends RequestHandler> = (\n  request: MockedRequest,\n  handler: RequestHandlerType,\n) => number\n\nfunction getRestHandlerScore(): ScoreGetterFn<RestHandler> {\n  return (request, handler) => {\n    const { path, method } = handler.info\n\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity\n    }\n\n    const hasSameMethod = isStringEqual(request.method, method)\n\n    // Always treat a handler with the same method as a more similar one.\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0\n    const requestPublicUrl = getPublicUrlFromRequest(request)\n    const score = getStringMatchScore(requestPublicUrl, path)\n\n    return score - methodScoreDelta\n  }\n}\n\nfunction getGraphQLHandlerScore(\n  parsedQuery: ParsedGraphQLQuery,\n): ScoreGetterFn<GraphQLHandler> {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === 'undefined') {\n      return Infinity\n    }\n\n    const { operationType, operationName } = handler.info\n\n    if (typeof operationName !== 'string') {\n      return Infinity\n    }\n\n    const hasSameOperationType = parsedQuery.operationType === operationType\n    // Always treat a handler with the same operation type as a more similar one.\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0\n    const score = getStringMatchScore(parsedQuery.operationName, operationName)\n\n    return score - operationTypeScoreDelta\n  }\n}\n\nfunction getSuggestedHandler(\n  request: MockedRequest,\n  handlers: RestHandler[] | GraphQLHandler[],\n  getScore: ScoreGetterFn<RestHandler> | ScoreGetterFn<GraphQLHandler>,\n): RequestHandler[] {\n  const suggestedHandlers = (handlers as RequestHandler[])\n    .reduce<RequestHandlerSuggestion[]>((suggestions, handler) => {\n      const score = getScore(request, handler as any)\n      return suggestions.concat([[score, handler]])\n    }, [])\n    .sort(([leftScore], [rightScore]) => leftScore - rightScore)\n    .filter(([score]) => score <= MAX_MATCH_SCORE)\n    .slice(0, MAX_SUGGESTION_COUNT)\n    .map(([, handler]) => handler)\n\n  return suggestedHandlers\n}\n\nfunction getSuggestedHandlersMessage(handlers: RequestHandler[]) {\n  if (handlers.length > 1) {\n    return `\\\nDid you mean to request one of the following resources instead?\n\n${handlers.map((handler) => `  • ${handler.info.header}`).join('\\n')}`\n  }\n\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`\n}\n\nexport function onUnhandledRequest(\n  request: MockedRequest,\n  handlers: RequestHandler[],\n  strategy: UnhandledRequestStrategy = 'warn',\n): void {\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request))\n\n  function generateHandlerSuggestion(): string {\n    /**\n     * @note Ignore exceptions during GraphQL request parsing because at this point\n     * we cannot assume the unhandled request is a valid GraphQL request.\n     * If the GraphQL parsing fails, just don't treat it as a GraphQL request.\n     */\n    const handlerGroups = groupHandlersByType(handlers)\n    const relevantHandlers = parsedGraphQLQuery\n      ? handlerGroups.graphql\n      : handlerGroups.rest\n\n    const suggestedHandlers = getSuggestedHandler(\n      request,\n      relevantHandlers,\n      parsedGraphQLQuery\n        ? getGraphQLHandlerScore(parsedGraphQLQuery)\n        : getRestHandlerScore(),\n    )\n\n    return suggestedHandlers.length > 0\n      ? getSuggestedHandlersMessage(suggestedHandlers)\n      : ''\n  }\n\n  function generateUnhandledRequestMessage(): string {\n    const publicUrl = getPublicUrlFromRequest(request)\n    const requestHeader = parsedGraphQLQuery\n      ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})`\n      : `${request.method} ${publicUrl}`\n    const handlerSuggestion = generateHandlerSuggestion()\n\n    const messageTemplate = [\n      `captured a request without a matching request handler:`,\n      `  \\u2022 ${requestHeader}`,\n      handlerSuggestion,\n      `\\\nIf you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks\\\n`,\n    ].filter(Boolean)\n    return messageTemplate.join('\\n\\n')\n  }\n\n  function applyStrategy(strategy: UnhandledRequestStrategy) {\n    // Generate handler suggestions only when applying the strategy.\n    // This saves bandwidth for scenarios when developers opt-out\n    // from the default unhandled request handling strategy.\n    const message = generateUnhandledRequestMessage()\n\n    switch (strategy) {\n      case 'error': {\n        // Print a developer-friendly error.\n        devUtils.error('Error: %s', message)\n\n        // Throw an exception to halt request processing and not perform the original request.\n        throw new Error(\n          devUtils.formatMessage(\n            'Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.',\n          ),\n        )\n      }\n\n      case 'warn': {\n        devUtils.warn('Warning: %s', message)\n        break\n      }\n\n      case 'bypass':\n        break\n\n      default:\n        throw new Error(\n          devUtils.formatMessage(\n            'Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.',\n            strategy,\n          ),\n        )\n    }\n  }\n\n  if (typeof strategy === 'function') {\n    strategy(request, {\n      warning: applyStrategy.bind(null, 'warn'),\n      error: applyStrategy.bind(null, 'error'),\n    })\n    return\n  }\n\n  applyStrategy(strategy)\n}\n","import {\n  DocumentNode,\n  OperationDefinitionNode,\n  OperationTypeNode,\n  parse,\n} from 'graphql'\nimport { GraphQLVariables } from '../../handlers/GraphQLHandler'\nimport { getPublicUrlFromRequest } from '../request/getPublicUrlFromRequest'\nimport { MockedRequest } from '../request/MockedRequest'\nimport { devUtils } from './devUtils'\nimport { jsonParse } from './jsonParse'\n\ninterface GraphQLInput {\n  query: string | null\n  variables?: GraphQLVariables\n}\n\nexport interface ParsedGraphQLQuery {\n  operationType: OperationTypeNode\n  operationName?: string\n}\n\nexport type ParsedGraphQLRequest<\n  VariablesType extends GraphQLVariables = GraphQLVariables,\n> =\n  | (ParsedGraphQLQuery & {\n      variables?: VariablesType\n    })\n  | undefined\n\nexport function parseDocumentNode(node: DocumentNode): ParsedGraphQLQuery {\n  const operationDef = node.definitions.find((def) => {\n    return def.kind === 'OperationDefinition'\n  }) as OperationDefinitionNode\n\n  return {\n    operationType: operationDef?.operation,\n    operationName: operationDef?.name?.value,\n  }\n}\n\nfunction parseQuery(query: string): ParsedGraphQLQuery | Error {\n  try {\n    const ast = parse(query)\n    return parseDocumentNode(ast)\n  } catch (error) {\n    return error as Error\n  }\n}\n\nexport type GraphQLParsedOperationsMap = Record<string, string[]>\nexport type GraphQLMultipartRequestBody = {\n  operations: string\n  map?: string\n} & {\n  [fileName: string]: File\n}\n\nfunction extractMultipartVariables<VariablesType extends GraphQLVariables>(\n  variables: VariablesType,\n  map: GraphQLParsedOperationsMap,\n  files: Record<string, File>,\n) {\n  const operations = { variables }\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`)\n    }\n\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split('.').reverse()\n      const paths = reversedPaths.reverse()\n      let target: Record<string, any> = operations\n\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`)\n        }\n\n        target = target[path]\n      }\n\n      target[lastPath] = files[key]\n    }\n  }\n  return operations.variables\n}\n\nfunction getGraphQLInput(request: MockedRequest<any>): GraphQLInput | null {\n  switch (request.method) {\n    case 'GET': {\n      const query = request.url.searchParams.get('query')\n      const variables = request.url.searchParams.get('variables') || ''\n\n      return {\n        query,\n        variables: jsonParse(variables),\n      }\n    }\n\n    case 'POST': {\n      if (request.body?.query) {\n        const { query, variables } = request.body\n\n        return {\n          query,\n          variables,\n        }\n      }\n\n      // Handle multipart body operations.\n      if (request.body?.operations) {\n        const { operations, map, ...files } =\n          request.body as GraphQLMultipartRequestBody\n        const parsedOperations =\n          jsonParse<{ query?: string; variables?: GraphQLVariables }>(\n            operations,\n          ) || {}\n\n        if (!parsedOperations.query) {\n          return null\n        }\n\n        const parsedMap = jsonParse<GraphQLParsedOperationsMap>(map || '') || {}\n        const variables = parsedOperations.variables\n          ? extractMultipartVariables(\n              parsedOperations.variables,\n              parsedMap,\n              files,\n            )\n          : {}\n\n        return {\n          query: parsedOperations.query,\n          variables,\n        }\n      }\n    }\n\n    default:\n      return null\n  }\n}\n\n/**\n * Determines if a given request can be considered a GraphQL request.\n * Does not parse the query and does not guarantee its validity.\n */\nexport function parseGraphQLRequest(\n  request: MockedRequest<any>,\n): ParsedGraphQLRequest {\n  const input = getGraphQLInput(request)\n\n  if (!input || !input.query) {\n    return undefined\n  }\n\n  const { query, variables } = input\n  const parsedResult = parseQuery(query)\n\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request)\n\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s',\n        request.method,\n        requestPublicUrl,\n        parsedResult.message,\n      ),\n    )\n  }\n\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables,\n  }\n}\n","import { MockedRequest } from './MockedRequest'\n\n/**\n * Returns a relative URL if the given request URL is relative to the current origin.\n * Otherwise returns an absolute URL.\n */\nexport const getPublicUrlFromRequest = (request: MockedRequest) => {\n  return request.referrer.startsWith(request.url.origin)\n    ? request.url.pathname\n    : new URL(\n        request.url.pathname,\n        `${request.url.protocol}//${request.url.host}`,\n      ).href\n}\n","export enum StatusCodeColor {\n  Success = '#69AB32',\n  Warning = '#F0BB4B',\n  Danger = '#E95F5D',\n}\n\n/**\n * Returns a HEX color for a given response status code number.\n */\nexport function getStatusCodeColor(status: number): StatusCodeColor {\n  if (status < 300) {\n    return StatusCodeColor.Success\n  }\n\n  if (status < 400) {\n    return StatusCodeColor.Warning\n  }\n\n  return StatusCodeColor.Danger\n}\n","/**\n * Returns a timestamp string in a \"HH:MM:SS\" format.\n */\nexport function getTimestamp(): string {\n  const now = new Date()\n\n  return [now.getHours(), now.getMinutes(), now.getSeconds()]\n    .map(String)\n    .map((chunk) => chunk.slice(0, 2))\n    .map((chunk) => chunk.padStart(2, '0'))\n    .join(':')\n}\n","import { MockedRequest } from '../request/MockedRequest.js'\n\n/**\n * Formats a mocked request for introspection in browser's console.\n */\nexport function prepareRequest(request: MockedRequest) {\n  return {\n    ...request,\n    body: request.body,\n    headers: request.headers.all(),\n  }\n}\n","import { objectToHeaders } from 'headers-polyfill'\nimport { SerializedResponse } from '../../setupWorker/glossary'\nimport { parseBody } from '../request/parseBody'\n\n/**\n * Formats a mocked response for introspection in the browser's console.\n */\nexport function prepareResponse(res: SerializedResponse<any>) {\n  const responseHeaders = objectToHeaders(res.headers)\n\n  return {\n    ...res,\n    // Parse a response JSON body for preview in the logs\n    body: parseBody(res.body, responseHeaders),\n  }\n}\n","import { match } from 'path-to-regexp'\nimport { getCleanUrl } from '@mswjs/interceptors/lib/utils/getCleanUrl'\nimport { normalizePath } from './normalizePath'\n\nexport type Path = string | RegExp\nexport type PathParams<KeyType extends keyof any = string> = {\n  [ParamName in KeyType]: string | ReadonlyArray<string>\n}\n\nexport interface Match {\n  matches: boolean\n  params?: PathParams\n}\n\n/**\n * Coerce a path supported by MSW into a path\n * supported by \"path-to-regexp\".\n */\nexport function coercePath(path: string): string {\n  return (\n    path\n      /**\n       * Replace wildcards (\"*\") with unnamed capturing groups\n       * because \"path-to-regexp\" doesn't support wildcards.\n       * Ignore path parameter' modifiers (i.e. \":name*\").\n       */\n      .replace(\n        /([:a-zA-Z_-]*)(\\*{1,2})+/g,\n        (_, parameterName: string | undefined, wildcard: string) => {\n          const expression = '(.*)'\n\n          if (!parameterName) {\n            return expression\n          }\n\n          return parameterName.startsWith(':')\n            ? `${parameterName}${wildcard}`\n            : `${parameterName}${expression}`\n        },\n      )\n      /**\n       * Escape the port so that \"path-to-regexp\" can match\n       * absolute URLs including port numbers.\n       */\n      .replace(/([^\\/])(:)(?=\\d+)/, '$1\\\\$2')\n      /**\n       * Escape the protocol so that \"path-to-regexp\" could match\n       * absolute URL.\n       * @see https://github.com/pillarjs/path-to-regexp/issues/259\n       */\n      .replace(/^([^\\/]+)(:)(?=\\/\\/)/, '$1\\\\$2')\n  )\n}\n\n/**\n * Returns the result of matching given request URL against a mask.\n */\nexport function matchRequestUrl(url: URL, path: Path, baseUrl?: string): Match {\n  const normalizedPath = normalizePath(path, baseUrl)\n  const cleanPath =\n    typeof normalizedPath === 'string'\n      ? coercePath(normalizedPath)\n      : normalizedPath\n\n  const cleanUrl = getCleanUrl(url)\n  const result = match(cleanPath, { decode: decodeURIComponent })(cleanUrl)\n  const params = (result && (result.params as PathParams)) || {}\n\n  return {\n    matches: result !== false,\n    params,\n  }\n}\n","const REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g\n\nexport function getSearchParams(path: string) {\n  return new URL(`/${path}`, 'http://localhost').searchParams\n}\n\n/**\n * Removes query parameters and hashes from a given URL string.\n */\nexport function cleanUrl(path: string): string {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, '')\n}\n","/**\n * Determines if the given URL string is an absolute URL.\n */\nexport function isAbsoluteUrl(url: string): boolean {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url)\n}\n","import { isAbsoluteUrl } from './isAbsoluteUrl'\n\n/**\n * Returns an absolute URL based on the given path.\n */\nexport function getAbsoluteUrl(path: string, baseUrl?: string): string {\n  // already absolute URL\n  if (isAbsoluteUrl(path)) {\n    return path\n  }\n\n  // Ignore path with pattern start with *\n  if (path.startsWith('*')) {\n    return path\n  }\n\n  // Resolve a relative request URL against a given custom \"baseUrl\"\n  // or the document baseURI (in the case of browser/browser-like environments).\n  const origin =\n    baseUrl || (typeof document !== 'undefined' && document.baseURI)\n\n  return origin\n    ? // Encode and decode the path to preserve escaped characters.\n      decodeURI(new URL(encodeURI(path), origin).href)\n    : path\n}\n","import type { Path } from './matchRequestUrl'\nimport { cleanUrl } from '../url/cleanUrl'\nimport { getAbsoluteUrl } from '../url/getAbsoluteUrl'\n\n/**\n * Normalizes a given request handler path:\n * - Preserves RegExp.\n * - Removes query parameters and hashes.\n * - Rebases relative URLs against the \"baseUrl\" or the current location.\n * - Preserves relative URLs in Node.js, unless specified otherwise.\n */\nexport function normalizePath(path: Path, baseUrl?: string): Path {\n  // RegExp paths do not need normalization.\n  if (path instanceof RegExp) {\n    return path\n  }\n\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl)\n\n  return cleanUrl(maybeAbsoluteUrl)\n}\n","import { Headers } from 'headers-polyfill'\nimport {\n  MaybePromise,\n  MockedResponse,\n  response,\n  ResponseComposition,\n} from '../response'\nimport { getCallFrame } from '../utils/internal/getCallFrame'\nimport { isIterable } from '../utils/internal/isIterable'\nimport { status } from '../context/status'\nimport { set } from '../context/set'\nimport { delay } from '../context/delay'\nimport { fetch } from '../context/fetch'\nimport { ResponseResolutionContext } from '../utils/getResponse'\nimport { SerializedResponse } from '../setupWorker/glossary'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nexport type DefaultContext = {\n  status: typeof status\n  set: typeof set\n  delay: typeof delay\n  fetch: typeof fetch\n}\n\nexport const defaultContext: DefaultContext = {\n  status,\n  set,\n  delay,\n  fetch,\n}\n\nexport type DefaultRequestMultipartBody = Record<\n  string,\n  string | File | (string | File)[]\n>\n\nexport type DefaultBodyType =\n  | Record<string, any>\n  | DefaultRequestMultipartBody\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n\nexport interface RequestHandlerDefaultInfo {\n  header: string\n}\n\nexport interface RequestHandlerInternalInfo {\n  callFrame?: string\n}\n\ntype ContextMap = Record<string, (...args: any[]) => any>\n\nexport type ResponseResolverReturnType<ReturnType> =\n  | ReturnType\n  | undefined\n  | void\n\nexport type MaybeAsyncResponseResolverReturnType<ReturnType> = MaybePromise<\n  ResponseResolverReturnType<ReturnType>\n>\n\nexport type AsyncResponseResolverReturnType<ReturnType> =\n  | MaybeAsyncResponseResolverReturnType<ReturnType>\n  | Generator<\n      MaybeAsyncResponseResolverReturnType<ReturnType>,\n      MaybeAsyncResponseResolverReturnType<ReturnType>,\n      MaybeAsyncResponseResolverReturnType<ReturnType>\n    >\n\nexport type ResponseResolver<\n  RequestType = MockedRequest,\n  ContextType = typeof defaultContext,\n  BodyType = any,\n> = (\n  req: RequestType,\n  res: ResponseComposition<BodyType>,\n  context: ContextType,\n) => AsyncResponseResolverReturnType<MockedResponse<BodyType>>\n\nexport interface RequestHandlerOptions<HandlerInfo> {\n  info: HandlerInfo\n  resolver: ResponseResolver<any, any>\n  ctx?: ContextMap\n}\n\nexport interface RequestHandlerExecutionResult<PublicRequestType> {\n  handler: RequestHandler\n  parsedResult: any\n  request: PublicRequestType\n  response?: MockedResponse\n}\n\nexport abstract class RequestHandler<\n  HandlerInfo extends RequestHandlerDefaultInfo = RequestHandlerDefaultInfo,\n  Request extends MockedRequest = MockedRequest,\n  ParsedResult = any,\n  PublicRequest extends MockedRequest = Request,\n> {\n  public info: HandlerInfo & RequestHandlerInternalInfo\n  public shouldSkip: boolean\n\n  private ctx: ContextMap\n  private resolverGenerator?: Generator<\n    MaybeAsyncResponseResolverReturnType<any>,\n    MaybeAsyncResponseResolverReturnType<any>,\n    MaybeAsyncResponseResolverReturnType<any>\n  >\n  private resolverGeneratorResult?: MaybeAsyncResponseResolverReturnType<any>\n\n  protected resolver: ResponseResolver<any, any>\n\n  constructor(options: RequestHandlerOptions<HandlerInfo>) {\n    this.shouldSkip = false\n    this.ctx = options.ctx || defaultContext\n    this.resolver = options.resolver\n\n    const callFrame = getCallFrame(new Error())\n\n    this.info = {\n      ...options.info,\n      callFrame,\n    }\n  }\n\n  /**\n   * Determine if the captured request should be mocked.\n   */\n  abstract predicate(\n    request: MockedRequest,\n    parsedResult: ParsedResult,\n    resolutionContext?: ResponseResolutionContext,\n  ): boolean\n\n  /**\n   * Print out the successfully handled request.\n   */\n  abstract log(\n    request: Request,\n    response: SerializedResponse<any>,\n    handler: this,\n    parsedResult: ParsedResult,\n  ): void\n\n  /**\n   * Parse the captured request to extract additional information from it.\n   * Parsed result is then exposed to other methods of this request handler.\n   */\n  parse(\n    _request: MockedRequest,\n    _resolutionContext?: ResponseResolutionContext,\n  ): ParsedResult {\n    return null as any\n  }\n\n  /**\n   * Test if this handler matches the given request.\n   */\n  public test(\n    request: MockedRequest,\n    resolutionContext?: ResponseResolutionContext,\n  ): boolean {\n    return this.predicate(\n      request,\n      this.parse(request, resolutionContext),\n      resolutionContext,\n    )\n  }\n\n  /**\n   * Derive the publicly exposed request (`req`) instance of the response resolver\n   * from the captured request and its parsed result.\n   */\n  protected getPublicRequest(\n    request: MockedRequest,\n    _parsedResult: ParsedResult,\n  ) {\n    return request as PublicRequest\n  }\n\n  public markAsSkipped(shouldSkip = true) {\n    this.shouldSkip = shouldSkip\n  }\n\n  /**\n   * Execute this request handler and produce a mocked response\n   * using the given resolver function.\n   */\n  public async run(\n    request: MockedRequest,\n    resolutionContext?: ResponseResolutionContext,\n  ): Promise<RequestHandlerExecutionResult<PublicRequest> | null> {\n    if (this.shouldSkip) {\n      return null\n    }\n\n    const parsedResult = this.parse(request, resolutionContext)\n    const shouldIntercept = this.predicate(\n      request,\n      parsedResult,\n      resolutionContext,\n    )\n\n    if (!shouldIntercept) {\n      return null\n    }\n\n    const publicRequest = this.getPublicRequest(request, parsedResult)\n\n    // Create a response extraction wrapper around the resolver\n    // since it can be both an async function and a generator.\n    const executeResolver = this.wrapResolver(this.resolver)\n    const mockedResponse = await executeResolver(\n      publicRequest,\n      response,\n      this.ctx,\n    )\n\n    return this.createExecutionResult(\n      parsedResult,\n      publicRequest,\n      mockedResponse,\n    )\n  }\n\n  private wrapResolver(\n    resolver: ResponseResolver<any, any>,\n  ): ResponseResolver<AsyncResponseResolverReturnType<any>, any> {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || (await resolver(req, res, ctx))\n\n      if (isIterable<AsyncResponseResolverReturnType<any>>(result)) {\n        const { value, done } = result[Symbol.iterator]().next()\n        const nextResponse = await value\n\n        // If the generator is done and there is no next value,\n        // return the previous generator's value.\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult\n        }\n\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result\n        }\n\n        this.resolverGeneratorResult = nextResponse\n        return nextResponse\n      }\n\n      return result\n    }\n  }\n\n  private createExecutionResult(\n    parsedResult: ParsedResult,\n    request: PublicRequest,\n    response: any,\n  ): RequestHandlerExecutionResult<PublicRequest> {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response || null,\n    }\n  }\n}\n\n/**\n * Bypass this intercepted request.\n * This will make a call to the actual endpoint requested.\n */\nexport function passthrough(): MockedResponse<null> {\n  // Constructing a dummy \"101 Continue\" mocked response\n  // to keep the return type of the resolver consistent.\n  return {\n    status: 101,\n    statusText: 'Continue',\n    headers: new Headers(),\n    body: null,\n    // Setting \"passthrough\" to true will signal the response pipeline\n    // to perform this intercepted request as-is.\n    passthrough: true,\n    once: false,\n  }\n}\n","import { Headers } from 'headers-polyfill'\nimport { DefaultBodyType } from './handlers/RequestHandler'\nimport { compose } from './utils/internal/compose'\nimport { NetworkError } from './utils/NetworkError'\n\nexport type MaybePromise<ValueType = any> = ValueType | Promise<ValueType>\n\n/**\n * Internal representation of a mocked response instance.\n */\nexport interface MockedResponse<BodyType extends DefaultBodyType = any> {\n  body: BodyType\n  status: number\n  statusText: string\n  headers: Headers\n  once: boolean\n  passthrough: boolean\n  delay?: number\n}\n\nexport type ResponseTransformer<\n  BodyType extends TransformerBodyType = any,\n  TransformerBodyType = any,\n> = (\n  res: MockedResponse<TransformerBodyType>,\n) => MaybePromise<MockedResponse<BodyType>>\n\nexport type ResponseFunction<BodyType = any> = (\n  ...transformers: ResponseTransformer<BodyType>[]\n) => MaybePromise<MockedResponse<BodyType>>\n\nexport type ResponseComposition<BodyType = any> = ResponseFunction<BodyType> & {\n  /**\n   * Respond using a given mocked response to the first captured request.\n   * Does not affect any subsequent captured requests.\n   */\n  once: ResponseFunction<BodyType>\n  networkError: (message: string) => void\n}\n\nexport const defaultResponse: Omit<MockedResponse, 'headers'> = {\n  status: 200,\n  statusText: 'OK',\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false,\n}\n\nexport type ResponseCompositionOptions<BodyType> = {\n  defaultTransformers?: ResponseTransformer<BodyType>[]\n  mockedResponseOverrides?: Partial<MockedResponse>\n}\n\nexport const defaultResponseTransformers: ResponseTransformer<any>[] = []\n\nexport function createResponseComposition<BodyType>(\n  responseOverrides?: Partial<MockedResponse<BodyType>>,\n  defaultTransformers: ResponseTransformer<BodyType>[] = defaultResponseTransformers,\n): ResponseFunction {\n  return async (...transformers) => {\n    const initialResponse: MockedResponse = Object.assign(\n      {},\n      defaultResponse,\n      {\n        headers: new Headers({\n          'x-powered-by': 'msw',\n        }),\n      },\n      responseOverrides,\n    )\n\n    const resolvedTransformers = [\n      ...defaultTransformers,\n      ...transformers,\n    ].filter(Boolean)\n\n    const resolvedResponse =\n      resolvedTransformers.length > 0\n        ? compose(...resolvedTransformers)(initialResponse)\n        : initialResponse\n\n    return resolvedResponse\n  }\n}\n\nexport const response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({ once: true }),\n  networkError(message: string) {\n    throw new NetworkError(message)\n  },\n})\n","type ArityOneFunction = (arg: any) => any\n\ntype LengthOfTuple<Tuple extends any[]> = Tuple extends { length: infer L }\n  ? L\n  : never\n\ntype DropFirstInTuple<Tuple extends any[]> = ((...args: Tuple) => any) extends (\n  arg: any,\n  ...rest: infer LastArg\n) => any\n  ? LastArg\n  : Tuple\n\ntype LastInTuple<Tuple extends any[]> = Tuple[LengthOfTuple<\n  DropFirstInTuple<Tuple>\n>]\n\ntype FirstFnParameterType<Functions extends ArityOneFunction[]> = Parameters<\n  LastInTuple<Functions>\n>[any]\n\ntype LastFnParameterType<Functions extends ArityOneFunction[]> = ReturnType<\n  Functions[0]\n>\n\n/**\n * Composes a given list of functions into a new function that\n * executes from right to left.\n */\nexport function compose<\n  Functions extends ArityOneFunction[],\n  LeftReturnType extends FirstFnParameterType<Functions>,\n  RightReturnType extends LastFnParameterType<Functions>,\n>(\n  ...fns: Functions\n): (\n  ...args: [LeftReturnType] extends [never] ? never[] : [LeftReturnType]\n) => RightReturnType {\n  return (...args) => {\n    return fns.reduceRight((leftFn: any, rightFn) => {\n      return leftFn instanceof Promise\n        ? Promise.resolve(leftFn).then(rightFn)\n        : rightFn(leftFn)\n    }, args[0])\n  }\n}\n","// Ignore the source files traces for local testing.\nconst SOURCE_FRAME = /\\/msw\\/src\\/(.+)/\n\nconst BUILD_FRAME =\n  /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/\n\n/**\n * Return the stack trace frame of a function's invocation.\n */\nexport function getCallFrame(error: Error) {\n  // In <IE11, new Error may return an undefined stack\n  const stack = error.stack\n\n  if (!stack) {\n    return\n  }\n\n  const frames: string[] = stack.split('\\n').slice(1)\n\n  // Get the first frame that doesn't reference the library's internal trace.\n  // Assume that frame is the invocation frame.\n  const declarationFrame = frames.find((frame) => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame))\n  })\n\n  if (!declarationFrame) {\n    return\n  }\n\n  // Extract file reference from the stack frame.\n  const declarationPath = declarationFrame\n    .replace(/\\s*at [^()]*\\(([^)]+)\\)/, '$1')\n    .replace(/^@/, '')\n  return declarationPath\n}\n","/**\n * Determines if the given function is an iterator.\n */\nexport function isIterable<IteratorType>(\n  fn: any,\n): fn is Generator<IteratorType, IteratorType, IteratorType> {\n  if (!fn) {\n    return false\n  }\n\n  return typeof (fn as Generator<unknown>)[Symbol.iterator] == 'function'\n}\n","import { body, cookie, json, text, xml } from '../context'\nimport { SerializedResponse } from '../setupWorker/glossary'\nimport { ResponseResolutionContext } from '../utils/getResponse'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { isStringEqual } from '../utils/internal/isStringEqual'\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor'\nimport { getTimestamp } from '../utils/logging/getTimestamp'\nimport { prepareRequest } from '../utils/logging/prepareRequest'\nimport { prepareResponse } from '../utils/logging/prepareResponse'\nimport {\n  Match,\n  matchRequestUrl,\n  Path,\n  PathParams,\n} from '../utils/matching/matchRequestUrl'\nimport { getPublicUrlFromRequest } from '../utils/request/getPublicUrlFromRequest'\nimport { MockedRequest } from '../utils/request/MockedRequest'\nimport { cleanUrl, getSearchParams } from '../utils/url/cleanUrl'\nimport {\n  DefaultBodyType,\n  defaultContext,\n  DefaultContext,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n  ResponseResolver,\n} from './RequestHandler'\n\ntype RestHandlerMethod = string | RegExp\n\nexport interface RestHandlerInfo extends RequestHandlerDefaultInfo {\n  method: RestHandlerMethod\n  path: Path\n}\n\nexport enum RESTMethods {\n  HEAD = 'HEAD',\n  GET = 'GET',\n  POST = 'POST',\n  PUT = 'PUT',\n  PATCH = 'PATCH',\n  OPTIONS = 'OPTIONS',\n  DELETE = 'DELETE',\n}\n\n// Declaring a context interface infers\n// JSDoc description of the referenced utils.\nexport type RestContext = DefaultContext & {\n  cookie: typeof cookie\n  text: typeof text\n  body: typeof body\n  json: typeof json\n  xml: typeof xml\n}\n\nexport const restContext: RestContext = {\n  ...defaultContext,\n  cookie,\n  body,\n  text,\n  json,\n  xml,\n}\n\nexport type RequestQuery = {\n  [queryName: string]: string\n}\n\nexport type ParsedRestRequest = Match\n\nexport class RestRequest<\n  RequestBody extends DefaultBodyType = DefaultBodyType,\n  RequestParams extends PathParams = PathParams,\n> extends MockedRequest<RequestBody> {\n  constructor(\n    request: MockedRequest<RequestBody>,\n    public readonly params: RequestParams,\n  ) {\n    super(request.url, {\n      ...request,\n      /**\n       * @deprecated https://github.com/mswjs/msw/issues/1318\n       * @note Use internal request body buffer as the body init\n       * because \"request.body\" is a getter that will trigger\n       * request body parsing at this step.\n       */\n      body: request['_body'],\n    })\n    this.id = request.id\n  }\n}\n\n/**\n * Request handler for REST API requests.\n * Provides request matching based on method and URL.\n */\nexport class RestHandler<\n  RequestType extends MockedRequest<DefaultBodyType> = MockedRequest<DefaultBodyType>,\n> extends RequestHandler<\n  RestHandlerInfo,\n  RequestType,\n  ParsedRestRequest,\n  RestRequest<\n    RequestType extends MockedRequest<infer RequestBodyType>\n      ? RequestBodyType\n      : any,\n    PathParams\n  >\n> {\n  constructor(\n    method: RestHandlerMethod,\n    path: Path,\n    resolver: ResponseResolver<any, any>,\n  ) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method,\n      },\n      ctx: restContext,\n      resolver,\n    })\n\n    this.checkRedundantQueryParameters()\n  }\n\n  private checkRedundantQueryParameters() {\n    const { method, path } = this.info\n\n    if (path instanceof RegExp) {\n      return\n    }\n\n    const url = cleanUrl(path)\n\n    // Bypass request handler URLs that have no redundant characters.\n    if (url === path) {\n      return\n    }\n\n    const searchParams = getSearchParams(path)\n    const queryParams: string[] = []\n\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName)\n    })\n\n    devUtils.warn(\n      `Found a redundant usage of query parameters in the request handler URL for \"${method} ${path}\". Please match against a path instead and access query parameters in the response resolver function using \"req.url.searchParams\".`,\n    )\n  }\n\n  parse(request: RequestType, resolutionContext?: ResponseResolutionContext) {\n    return matchRequestUrl(\n      request.url,\n      this.info.path,\n      resolutionContext?.baseUrl,\n    )\n  }\n\n  protected getPublicRequest(\n    request: RequestType,\n    parsedResult: ParsedRestRequest,\n  ): RestRequest<any, PathParams> {\n    return new RestRequest(request, parsedResult.params || {})\n  }\n\n  predicate(request: RequestType, parsedResult: ParsedRestRequest) {\n    const matchesMethod =\n      this.info.method instanceof RegExp\n        ? this.info.method.test(request.method)\n        : isStringEqual(this.info.method, request.method)\n\n    return matchesMethod && parsedResult.matches\n  }\n\n  log(request: RequestType, response: SerializedResponse) {\n    const publicUrl = getPublicUrlFromRequest(request)\n    const loggedRequest = prepareRequest(request)\n    const loggedResponse = prepareResponse(response)\n    const statusColor = getStatusCodeColor(response.status)\n\n    console.groupCollapsed(\n      devUtils.formatMessage('%s %s %s (%c%s%c)'),\n      getTimestamp(),\n      request.method,\n      publicUrl,\n      `color:${statusColor}`,\n      `${response.status} ${response.statusText}`,\n      'color:inherit',\n    )\n    console.log('Request', loggedRequest)\n    console.log('Handler:', {\n      mask: this.info.path,\n      resolver: this.resolver,\n    })\n    console.log('Response', loggedResponse)\n    console.groupEnd()\n  }\n}\n","import { invariant } from 'outvariant'\nimport { ResponseTransformer } from '../response'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\n\ntype ForbiddenFieldNames = '' | 'data' | 'errors' | 'extensions'\n\n/**\n * Set a custom field on the GraphQL mocked response.\n * @example res(ctx.fields('customField', value))\n * @see {@link https://mswjs.io/docs/api/context/field}\n */\nexport const field = <FieldNameType extends string, FieldValueType>(\n  fieldName: FieldNameType extends ForbiddenFieldNames ? never : FieldNameType,\n  fieldValue: FieldValueType,\n): ResponseTransformer<string> => {\n  return (res) => {\n    validateFieldName(fieldName)\n\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { [fieldName]: fieldValue })\n\n    return json(nextBody)(res as any) as any\n  }\n}\n\nfunction validateFieldName(fieldName: string) {\n  invariant(\n    fieldName.trim() !== '',\n    devUtils.formatMessage(\n      'Failed to set a custom field on a GraphQL response: field name cannot be empty.',\n    ),\n  )\n\n  invariant(\n    fieldName !== 'data',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?',\n      fieldName,\n    ),\n  )\n\n  invariant(\n    fieldName !== 'errors',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?',\n      fieldName,\n    ),\n  )\n\n  invariant(\n    fieldName !== 'extensions',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?',\n      fieldName,\n    ),\n  )\n}\n","export function tryCatch<Fn extends (...args: any[]) => any>(\n  fn: Fn,\n  onException?: (error: Error) => void,\n): ReturnType<Fn> | undefined {\n  try {\n    const result = fn()\n    return result\n  } catch (error) {\n    onException?.(error as Error)\n  }\n}\n","import { DocumentNode, OperationTypeNode } from 'graphql'\nimport { SerializedResponse } from '../setupWorker/glossary'\nimport { data } from '../context/data'\nimport { extensions } from '../context/extensions'\nimport { errors } from '../context/errors'\nimport { field } from '../context/field'\nimport { GraphQLPayloadContext } from '../typeUtils'\nimport { cookie } from '../context/cookie'\nimport {\n  defaultContext,\n  DefaultContext,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n  ResponseResolver,\n} from './RequestHandler'\nimport { getTimestamp } from '../utils/logging/getTimestamp'\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor'\nimport { prepareRequest } from '../utils/logging/prepareRequest'\nimport { prepareResponse } from '../utils/logging/prepareResponse'\nimport { matchRequestUrl, Path } from '../utils/matching/matchRequestUrl'\nimport {\n  ParsedGraphQLRequest,\n  GraphQLMultipartRequestBody,\n  parseGraphQLRequest,\n  parseDocumentNode,\n} from '../utils/internal/parseGraphQLRequest'\nimport { getPublicUrlFromRequest } from '../utils/request/getPublicUrlFromRequest'\nimport { tryCatch } from '../utils/internal/tryCatch'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nexport type ExpectedOperationTypeNode = OperationTypeNode | 'all'\nexport type GraphQLHandlerNameSelector = DocumentNode | RegExp | string\n\n// GraphQL related context should contain utility functions\n// useful for GraphQL. Functions like `xml()` bear no value\n// in the GraphQL universe.\nexport type GraphQLContext<QueryType extends Record<string, unknown>> =\n  DefaultContext & {\n    data: GraphQLPayloadContext<QueryType>\n    extensions: GraphQLPayloadContext<QueryType>\n    errors: typeof errors\n    cookie: typeof cookie\n    field: typeof field\n  }\n\nexport const graphqlContext: GraphQLContext<any> = {\n  ...defaultContext,\n  data,\n  extensions,\n  errors,\n  cookie,\n  field,\n}\n\nexport type GraphQLVariables = Record<string, any>\n\nexport interface GraphQLHandlerInfo extends RequestHandlerDefaultInfo {\n  operationType: ExpectedOperationTypeNode\n  operationName: GraphQLHandlerNameSelector\n}\n\nexport type GraphQLRequestBody<VariablesType extends GraphQLVariables> =\n  | GraphQLJsonRequestBody<VariablesType>\n  | GraphQLMultipartRequestBody\n  | Record<string, any>\n  | undefined\n\nexport interface GraphQLJsonRequestBody<Variables extends GraphQLVariables> {\n  query: string\n  variables?: Variables\n}\n\nexport function isDocumentNode(\n  value: DocumentNode | any,\n): value is DocumentNode {\n  if (value == null) {\n    return false\n  }\n\n  return typeof value === 'object' && 'kind' in value && 'definitions' in value\n}\n\nexport class GraphQLRequest<\n  Variables extends GraphQLVariables,\n> extends MockedRequest<GraphQLRequestBody<Variables>> {\n  constructor(request: MockedRequest, public readonly variables: Variables) {\n    super(request.url, {\n      ...request,\n      /**\n       * TODO(https://github.com/mswjs/msw/issues/1318): Cleanup\n       */\n      body: request['_body'],\n    })\n  }\n}\n\nexport class GraphQLHandler<\n  Request extends GraphQLRequest<any> = GraphQLRequest<any>,\n> extends RequestHandler<\n  GraphQLHandlerInfo,\n  Request,\n  ParsedGraphQLRequest | null,\n  GraphQLRequest<any>\n> {\n  private endpoint: Path\n\n  constructor(\n    operationType: ExpectedOperationTypeNode,\n    operationName: GraphQLHandlerNameSelector,\n    endpoint: Path,\n    resolver: ResponseResolver<any, any>,\n  ) {\n    let resolvedOperationName = operationName\n\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName)\n\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`,\n        )\n      }\n\n      if (!parsedNode.operationName) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`,\n        )\n      }\n\n      resolvedOperationName = parsedNode.operationName\n    }\n\n    const header =\n      operationType === 'all'\n        ? `${operationType} (origin: ${endpoint.toString()})`\n        : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`\n\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName,\n      },\n      ctx: graphqlContext,\n      resolver,\n    })\n\n    this.endpoint = endpoint\n  }\n\n  parse(request: MockedRequest) {\n    return tryCatch(\n      () => parseGraphQLRequest(request),\n      (error) => console.error(error.message),\n    )\n  }\n\n  protected getPublicRequest(\n    request: Request,\n    parsedResult: ParsedGraphQLRequest,\n  ): GraphQLRequest<any> {\n    return new GraphQLRequest(request, parsedResult?.variables || {})\n  }\n\n  predicate(request: MockedRequest, parsedResult: ParsedGraphQLRequest) {\n    if (!parsedResult) {\n      return false\n    }\n\n    if (!parsedResult.operationName && this.info.operationType !== 'all') {\n      const publicUrl = getPublicUrlFromRequest(request)\n      devUtils.warn(`\\\nFailed to intercept a GraphQL request at \"${request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation\\\n      `)\n      return false\n    }\n\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint)\n    const hasMatchingOperationType =\n      this.info.operationType === 'all' ||\n      parsedResult.operationType === this.info.operationType\n\n    const hasMatchingOperationName =\n      this.info.operationName instanceof RegExp\n        ? this.info.operationName.test(parsedResult.operationName || '')\n        : parsedResult.operationName === this.info.operationName\n\n    return (\n      hasMatchingUrl.matches &&\n      hasMatchingOperationType &&\n      hasMatchingOperationName\n    )\n  }\n\n  log(\n    request: Request,\n    response: SerializedResponse,\n    handler: this,\n    parsedRequest: ParsedGraphQLRequest,\n  ) {\n    const loggedRequest = prepareRequest(request)\n    const loggedResponse = prepareResponse(response)\n    const statusColor = getStatusCodeColor(response.status)\n    const requestInfo = parsedRequest?.operationName\n      ? `${parsedRequest?.operationType} ${parsedRequest?.operationName}`\n      : `anonymous ${parsedRequest?.operationType}`\n\n    console.groupCollapsed(\n      devUtils.formatMessage('%s %s (%c%s%c)'),\n      getTimestamp(),\n      `${requestInfo}`,\n      `color:${statusColor}`,\n      `${response.status} ${response.statusText}`,\n      'color:inherit',\n    )\n    console.log('Request:', loggedRequest)\n    console.log('Handler:', this)\n    console.log('Response:', loggedResponse)\n    console.groupEnd()\n  }\n}\n","import { store } from '@mswjs/cookies'\nimport { MockedResponse } from '../../response'\nimport { MockedRequest } from './MockedRequest'\n\nexport function readResponseCookies(\n  request: MockedRequest,\n  response: MockedResponse,\n) {\n  store.add({ ...request, url: request.url.toString() }, response)\n  store.persist()\n}\n","import {\n  StartOptions,\n  SerializedResponse,\n  SetupWorkerInternalContext,\n  ServiceWorkerIncomingEventsMap,\n} from '../glossary'\nimport {\n  ServiceWorkerMessage,\n  WorkerChannel,\n} from './utils/createMessageChannel'\nimport { NetworkError } from '../../utils/NetworkError'\nimport { parseWorkerRequest } from '../../utils/request/parseWorkerRequest'\nimport { handleRequest } from '../../utils/handleRequest'\nimport { RequestHandler } from '../../handlers/RequestHandler'\nimport { RequiredDeep } from '../../typeUtils'\nimport { MockedResponse } from '../../response'\nimport { devUtils } from '../../utils/internal/devUtils'\n\nexport const createRequestListener = (\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n) => {\n  return async (\n    event: MessageEvent,\n    message: ServiceWorkerMessage<\n      'REQUEST',\n      ServiceWorkerIncomingEventsMap['REQUEST']\n    >,\n  ) => {\n    const messageChannel = new WorkerChannel(event.ports[0])\n    const request = parseWorkerRequest(message.payload)\n\n    try {\n      await handleRequest<SerializedResponse>(\n        request,\n        context.requestHandlers,\n        options,\n        context.emitter,\n        {\n          transformResponse,\n          onPassthroughResponse() {\n            messageChannel.postMessage('NOT_FOUND')\n          },\n          async onMockedResponse(response) {\n            if (response.body instanceof ReadableStream) {\n              throw new Error(\n                devUtils.formatMessage(\n                  'Failed to construct a mocked response with a \"ReadableStream\" body: mocked streams are not supported. Follow https://github.com/mswjs/msw/issues/1336 for more details.',\n                ),\n              )\n            }\n\n            const responseInstance = new Response(response.body, response)\n            const responseBodyBuffer = await responseInstance.arrayBuffer()\n\n            // If the mocked response has no body, keep it that way.\n            // Sending an empty ArrayBuffer to the worker will cause\n            // the worker constructing \"new Response(new ArrayBuffer(0))\"\n            // which will throw on responses that must have no body (i.e. 204).\n            const responseBody =\n              response.body == null ? null : responseBodyBuffer\n\n            messageChannel.postMessage(\n              'MOCK_RESPONSE',\n              {\n                ...response,\n                body: responseBody,\n              },\n              [responseBodyBuffer],\n            )\n          },\n          onMockedResponseSent(\n            response,\n            { handler, publicRequest, parsedRequest },\n          ) {\n            if (options.quiet) {\n              return\n            }\n\n            handler.log(\n              publicRequest,\n              response,\n              handler as RequestHandler,\n              parsedRequest,\n            )\n          },\n        },\n      )\n    } catch (error) {\n      if (error instanceof NetworkError) {\n        // Treat emulated network error differently,\n        // as it is an intended exception in a request handler.\n        messageChannel.postMessage('NETWORK_ERROR', {\n          name: error.name,\n          message: error.message,\n        })\n\n        return\n      }\n\n      if (error instanceof Error) {\n        devUtils.error(\n          `Uncaught exception in the request handler for \"%s %s\":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`,\n          request.method,\n          request.url,\n          error,\n        )\n\n        // Treat all other exceptions in a request handler as unintended,\n        // alerting that there is a problem that needs fixing.\n        messageChannel.postMessage('MOCK_RESPONSE', {\n          status: 500,\n          statusText: 'Request Handler Error',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n          }),\n        })\n      }\n    }\n  }\n}\n\nfunction transformResponse(\n  response: MockedResponse<string>,\n): SerializedResponse<string> {\n  return {\n    status: response.status,\n    statusText: response.statusText,\n    headers: response.headers.all(),\n    body: response.body,\n    delay: response.delay,\n  }\n}\n","import { SetupWorkerInternalContext } from '../../setupWorker/glossary'\n\nexport async function requestIntegrityCheck(\n  context: SetupWorkerInternalContext,\n  serviceWorker: ServiceWorker,\n): Promise<ServiceWorker> {\n  // Signal Service Worker to report back its integrity\n  context.workerChannel.send('INTEGRITY_CHECK_REQUEST')\n\n  const { payload: actualChecksum } = await context.events.once(\n    'INTEGRITY_CHECK_RESPONSE',\n  )\n\n  // Compare the response from the Service Worker and the\n  // global variable set during the build.\n  if (actualChecksum !== SERVICE_WORKER_CHECKSUM) {\n    throw new Error(\n      `Currently active Service Worker (${actualChecksum}) is behind the latest published one (${SERVICE_WORKER_CHECKSUM}).`,\n    )\n  }\n\n  return serviceWorker\n}\n","import { until } from '@open-draft/until'\n\n/**\n * Intercepts and defers any requests on the page\n * until the Service Worker instance is ready.\n * Must only be used in a browser.\n */\nexport function deferNetworkRequestsUntil(predicatePromise: Promise<any>) {\n  // Defer any `XMLHttpRequest` requests until the Service Worker is ready.\n  const originalXhrSend = window.XMLHttpRequest.prototype.send\n  window.XMLHttpRequest.prototype.send = function (\n    ...args: Parameters<XMLHttpRequest['send']>\n  ) {\n    // Keep this function synchronous to comply with `XMLHttpRequest.prototype.send`,\n    // because that method is always synchronous.\n    until(() => predicatePromise).then(() => {\n      window.XMLHttpRequest.prototype.send = originalXhrSend\n      this.send(...args)\n    })\n  }\n\n  // Defer any `fetch` requests until the Service Worker is ready.\n  const originalFetch = window.fetch\n  window.fetch = async (...args) => {\n    await until(() => predicatePromise)\n    window.fetch = originalFetch\n    return window.fetch(...args)\n  }\n}\n","import {\n  ServiceWorkerIncomingEventsMap,\n  SetupWorkerInternalContext,\n} from '../../setupWorker/glossary'\nimport { ServiceWorkerMessage } from './utils/createMessageChannel'\n\nexport function createResponseListener(context: SetupWorkerInternalContext) {\n  return (\n    _: MessageEvent,\n    message: ServiceWorkerMessage<\n      'RESPONSE',\n      ServiceWorkerIncomingEventsMap['RESPONSE']\n    >,\n  ) => {\n    const { payload: responseJson } = message\n\n    /**\n     * CORS requests with `mode: \"no-cors\"` result in \"opaque\" responses.\n     * That kind of responses cannot be manipulated in JavaScript due\n     * to the security considerations.\n     * @see https://fetch.spec.whatwg.org/#concept-filtered-response-opaque\n     * @see https://github.com/mswjs/msw/issues/529\n     */\n    if (responseJson.type?.includes('opaque')) {\n      return\n    }\n\n    const response = new Response(responseJson.body || null, responseJson)\n    const isMockedResponse = response.headers.get('x-powered-by') === 'msw'\n\n    if (isMockedResponse) {\n      context.emitter.emit('response:mocked', response, responseJson.requestId)\n    } else {\n      context.emitter.emit('response:bypass', response, responseJson.requestId)\n    }\n  }\n}\n","import { devUtils } from '../../../utils/internal/devUtils'\nimport { StartOptions } from '../../glossary'\n\nexport function validateWorkerScope(\n  registration: ServiceWorkerRegistration,\n  options?: StartOptions,\n): void {\n  if (!options?.quiet && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(\n      `\\\nCannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.\\\n`,\n    )\n  }\n}\n","import { devUtils } from '../../../utils/internal/devUtils'\n\nexport function printStopMessage(args: { quiet?: boolean } = {}): void {\n  if (args.quiet) {\n    return\n  }\n\n  console.log(\n    `%c${devUtils.formatMessage('Mocking disabled.')}`,\n    'color:orangered;font-weight:bold;',\n  )\n}\n","import { devUtils } from '../../utils/internal/devUtils'\nimport { SetupWorkerInternalContext, StopHandler } from '../glossary'\nimport { printStopMessage } from './utils/printStopMessage'\n\nexport const createStop = (\n  context: SetupWorkerInternalContext,\n): StopHandler => {\n  return function stop() {\n    // Warn developers calling \"worker.stop()\" more times than necessary.\n    // This likely indicates a mistake in their code.\n    if (!context.isMockingEnabled) {\n      devUtils.warn(\n        'Found a redundant \"worker.stop()\" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this \"worker.stop()\" call.',\n      )\n      return\n    }\n\n    /**\n     * Signal the Service Worker to disable mocking for this client.\n     * Use this an an explicit way to stop the mocking, while preserving\n     * the worker-client relation. Does not affect the worker's lifecycle.\n     */\n    context.workerChannel.send('MOCK_DEACTIVATE')\n    context.isMockingEnabled = false\n    window.clearInterval(context.keepAliveInterval)\n\n    printStopMessage({ quiet: context.startOptions?.quiet })\n  }\n}\n","import { RequestHandler } from '../../handlers/RequestHandler'\n\nexport function use(\n  currentHandlers: RequestHandler[],\n  ...handlers: RequestHandler[]\n): void {\n  currentHandlers.unshift(...handlers)\n}\n\nexport function restoreHandlers(handlers: RequestHandler[]): void {\n  handlers.forEach((handler) => {\n    handler.markAsSkipped(false)\n  })\n}\n\nexport function resetHandlers(\n  initialHandlers: RequestHandler[],\n  ...nextHandlers: RequestHandler[]\n) {\n  return nextHandlers.length > 0 ? [...nextHandlers] : [...initialHandlers]\n}\n","import { RequiredDeep } from '../../../typeUtils'\nimport { mergeRight } from '../../../utils/internal/mergeRight'\nimport {\n  SetupWorkerApi,\n  SetupWorkerInternalContext,\n  StartHandler,\n  StartOptions,\n} from '../../glossary'\n\nexport const DEFAULT_START_OPTIONS: RequiredDeep<StartOptions> = {\n  serviceWorker: {\n    url: '/mockServiceWorker.js',\n    options: null as any,\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: 'warn',\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl\n  },\n}\n\n/**\n * Returns resolved worker start options, merging the default options\n * with the given custom options.\n */\nexport function resolveStartOptions(\n  initialOptions?: StartOptions,\n): RequiredDeep<StartOptions> {\n  return mergeRight(\n    DEFAULT_START_OPTIONS,\n    initialOptions || {},\n  ) as RequiredDeep<StartOptions>\n}\n\nexport function prepareStartHandler(\n  handler: StartHandler,\n  context: SetupWorkerInternalContext,\n): SetupWorkerApi['start'] {\n  return (initialOptions) => {\n    context.startOptions = resolveStartOptions(initialOptions)\n    return handler(context.startOptions, initialOptions || {})\n  }\n}\n","import {\n  Interceptor,\n  BatchInterceptor,\n  HttpRequestEventMap,\n} from '@mswjs/interceptors'\nimport { FetchInterceptor } from '@mswjs/interceptors/lib/interceptors/fetch'\nimport { XMLHttpRequestInterceptor } from '@mswjs/interceptors/lib/interceptors/XMLHttpRequest'\nimport type { RequestHandler } from '../../handlers/RequestHandler'\nimport {\n  SerializedResponse,\n  SetupWorkerInternalContext,\n  StartOptions,\n} from '../glossary'\nimport type { RequiredDeep } from '../../typeUtils'\nimport { handleRequest } from '../../utils/handleRequest'\nimport { MockedRequest } from '../../utils/request/MockedRequest'\n\nexport function createFallbackRequestListener(\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n): Interceptor<HttpRequestEventMap> {\n  const interceptor = new BatchInterceptor({\n    name: 'fallback',\n    interceptors: [new FetchInterceptor(), new XMLHttpRequestInterceptor()],\n  })\n\n  interceptor.on('request', async (request) => {\n    const mockedRequest = new MockedRequest(request.url, {\n      ...request,\n      body: await request.arrayBuffer(),\n    })\n\n    const response = await handleRequest<SerializedResponse>(\n      mockedRequest,\n      context.requestHandlers,\n      options,\n      context.emitter,\n      {\n        transformResponse(response) {\n          return {\n            status: response.status,\n            statusText: response.statusText,\n            headers: response.headers.all(),\n            body: response.body,\n            delay: response.delay,\n          }\n        },\n        onMockedResponseSent(\n          response,\n          { handler, publicRequest, parsedRequest },\n        ) {\n          if (!options.quiet) {\n            handler.log(\n              publicRequest,\n              response,\n              handler as RequestHandler,\n              parsedRequest,\n            )\n          }\n        },\n      },\n    )\n\n    if (response) {\n      request.respondWith(response)\n    }\n  })\n\n  interceptor.apply()\n\n  return interceptor\n}\n","import { createFallbackRequestListener } from './createFallbackRequestListener'\nimport { SetupWorkerInternalContext, StartHandler } from '../glossary'\nimport { printStartMessage } from './utils/printStartMessage'\n\nexport function createFallbackStart(\n  context: SetupWorkerInternalContext,\n): StartHandler {\n  return async function start(options) {\n    context.fallbackInterceptor = createFallbackRequestListener(\n      context,\n      options,\n    )\n\n    printStartMessage({\n      message: 'Mocking enabled (fallback mode).',\n      quiet: options.quiet,\n    })\n\n    return undefined\n  }\n}\n","import { SetupWorkerInternalContext, StopHandler } from '../glossary'\nimport { printStopMessage } from './utils/printStopMessage'\n\nexport function createFallbackStop(\n  context: SetupWorkerInternalContext,\n): StopHandler {\n  return function stop() {\n    context.fallbackInterceptor?.dispose()\n    printStopMessage({ quiet: context.startOptions?.quiet })\n  }\n}\n","import { EventEmitter } from 'stream'\n\n/**\n * Pipes all emitted events from one emitter to another.\n */\nexport function pipeEvents(\n  source: EventEmitter,\n  destination: EventEmitter,\n): void {\n  const rawEmit = source.emit\n\n  // @ts-ignore\n  if (rawEmit._isPiped) {\n    return\n  }\n\n  source.emit = function (event, ...data) {\n    destination.emit(event, ...data)\n    return rawEmit.call(this, event, ...data)\n  }\n\n  // @ts-ignore\n  source.emit._isPiped = true\n}\n","import { DefaultBodyType, ResponseResolver } from './handlers/RequestHandler'\nimport {\n  RESTMethods,\n  RestContext,\n  RestHandler,\n  RestRequest,\n} from './handlers/RestHandler'\nimport { Path, PathParams } from './utils/matching/matchRequestUrl'\n\nfunction createRestHandler<Method extends RESTMethods | RegExp>(\n  method: Method,\n) {\n  return <\n    RequestBodyType extends DefaultBodyType = DefaultBodyType,\n    Params extends PathParams<keyof Params> = PathParams,\n    ResponseBody extends DefaultBodyType = DefaultBodyType,\n  >(\n    path: Path,\n    resolver: ResponseResolver<\n      RestRequest<\n        Method extends RESTMethods.HEAD | RESTMethods.GET\n          ? never\n          : RequestBodyType,\n        Params\n      >,\n      RestContext,\n      ResponseBody\n    >,\n  ) => {\n    return new RestHandler(method, path, resolver)\n  }\n}\n\nexport const rest = {\n  all: createRestHandler(/.+/),\n  head: createRestHandler(RESTMethods.HEAD),\n  get: createRestHandler(RESTMethods.GET),\n  post: createRestHandler(RESTMethods.POST),\n  put: createRestHandler(RESTMethods.PUT),\n  delete: createRestHandler(RESTMethods.DELETE),\n  patch: createRestHandler(RESTMethods.PATCH),\n  options: createRestHandler(RESTMethods.OPTIONS),\n}\n","import { DocumentNode, OperationTypeNode } from 'graphql'\nimport { ResponseResolver } from './handlers/RequestHandler'\nimport {\n  GraphQLHandler,\n  GraphQLContext,\n  GraphQLRequest,\n  GraphQLVariables,\n  ExpectedOperationTypeNode,\n  GraphQLHandlerNameSelector,\n} from './handlers/GraphQLHandler'\nimport { Path } from './utils/matching/matchRequestUrl'\n\nexport interface TypedDocumentNode<\n  Result = { [key: string]: any },\n  Variables = { [key: string]: any },\n> extends DocumentNode {\n  __apiType?: (variables: Variables) => Result\n  __resultType?: Result\n  __variablesType?: Variables\n}\n\nfunction createScopedGraphQLHandler(\n  operationType: ExpectedOperationTypeNode,\n  url: Path,\n) {\n  return <\n    Query extends Record<string, any>,\n    Variables extends GraphQLVariables = GraphQLVariables,\n  >(\n    operationName:\n      | GraphQLHandlerNameSelector\n      | DocumentNode\n      | TypedDocumentNode<Query, Variables>,\n    resolver: ResponseResolver<\n      GraphQLRequest<Variables>,\n      GraphQLContext<Query>\n    >,\n  ) => {\n    return new GraphQLHandler<GraphQLRequest<Variables>>(\n      operationType,\n      operationName,\n      url,\n      resolver,\n    )\n  }\n}\n\nfunction createGraphQLOperationHandler(url: Path) {\n  return <\n    Query extends Record<string, any>,\n    Variables extends GraphQLVariables = GraphQLVariables,\n  >(\n    resolver: ResponseResolver<\n      GraphQLRequest<Variables>,\n      GraphQLContext<Query>\n    >,\n  ) => {\n    return new GraphQLHandler<GraphQLRequest<Variables>>(\n      'all',\n      new RegExp('.*'),\n      url,\n      resolver,\n    )\n  }\n}\n\nconst standardGraphQLHandlers = {\n  /**\n   * Captures any GraphQL operation, regardless of its name, under the current scope.\n   * @example\n   * graphql.operation((req, res, ctx) => {\n   *   return res(ctx.data({ name: 'John' }))\n   * })\n   * @see {@link https://mswjs.io/docs/api/graphql/operation `graphql.operation()`}\n   */\n  operation: createGraphQLOperationHandler('*'),\n\n  /**\n   * Captures a GraphQL query by a given name.\n   * @example\n   * graphql.query('GetUser', (req, res, ctx) => {\n   *   return res(ctx.data({ user: { name: 'John' } }))\n   * })\n   * @see {@link https://mswjs.io/docs/api/graphql/query `graphql.query()`}\n   */\n  query: createScopedGraphQLHandler(OperationTypeNode.QUERY, '*'),\n\n  /**\n   * Captures a GraphQL mutation by a given name.\n   * @example\n   * graphql.mutation('SavePost', (req, res, ctx) => {\n   *   return res(ctx.data({ post: { id: 'abc-123' } }))\n   * })\n   * @see {@link https://mswjs.io/docs/api/graphql/mutation `graphql.mutation()`}\n   */\n  mutation: createScopedGraphQLHandler(OperationTypeNode.MUTATION, '*'),\n}\n\nfunction createGraphQLLink(url: Path): typeof standardGraphQLHandlers {\n  return {\n    operation: createGraphQLOperationHandler(url),\n    query: createScopedGraphQLHandler(OperationTypeNode.QUERY, url),\n    mutation: createScopedGraphQLHandler(OperationTypeNode.MUTATION, url),\n  }\n}\n\nexport const graphql = {\n  ...standardGraphQLHandlers,\n  link: createGraphQLLink,\n}\n"]},"metadata":{},"sourceType":"script"}